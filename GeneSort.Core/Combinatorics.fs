namespace GeneSort.Core
open FSharp.UMX
open System

module Combinatorics =

    // For deterministic testing
    let indexPicker (indices: int[]) : int -> int =
        let mutable counter = 0
        fun _ ->
            let result = indices.[counter % indices.Length]
            counter <- counter + 1
            result

    // For deterministic testing
    let floatPicker (values: float[]) : unit -> float =
        let mutable counter = 0
        fun () ->
            let result = values.[counter % values.Length]
            counter <- counter + 1
            result


    /// Reflects a value across a modulus, computing modulus - value - 1.
    /// <param name="modulus">The modulus for reflection (must be positive).</param>
    /// <param name="value">The value to reflect (must be non-negative and less than modulus).</param>
    /// <returns>The reflected value.</returns>
    /// <exception cref="System.ArgumentException">Thrown when modulus is non-positive or value is invalid.</exception>
    let reflect (modulus: int) (value: int) : int =
        if modulus <= 0 then invalidArg "modulus" "Modulus must be positive"
        if value < 0 || value >= modulus then invalidArg "value" "Value must be non-negative and less than modulus"
        modulus - value - 1


    /// Computes the 2D Cartesian product of two sequences, yielding all possible pairs.
    /// <param name="seq_a">The first sequence.</param>
    /// <param name="seq_b">The second sequence.</param>
    /// <returns>A sequence of tuples representing all pairs (a, b).</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when either sequence is null.</exception>
    let cartesianProduct2d (seq_a: seq<'a>) (seq_b: seq<'b>) =
        if isNull seq_a then invalidArg "seq_a" "Sequence cannot be null"
        if isNull seq_b then invalidArg "seq_b" "Sequence cannot be null"
        seq {  
            for ae in seq_a do
                for be in seq_b do
                    yield (ae, be)
        }


    /// Computes the Cartesian product of a list of lists, yielding all possible combinations.
    /// <param name="lists">A list of sequences to combine.</param>
    /// <returns>A sequence of lists representing all combinations.</returns>
    let rec cartesianProduct (lists: list<list<'a>>) : 'a list seq =
        match lists with
        | [] -> Seq.empty<'a list>
        | [single] ->
            seq { for x in single do yield [x] }
        | hd::tl ->
            seq { for x in hd do
                    for rest in cartesianProduct tl do
                        yield x :: rest }


    //[<Measure>] type key
    //[<Measure>] type description
    ///// Computes the Cartesian product of a list of key-value pairs, yielding all possible maps.
    //let rec cartesianProductMaps<'a when 'a : comparison> (lists: list<string<key> * list<string<description> * 'a>>) 
    //                : Map<string<key>, string<description> * 'a> seq =
    //    match lists with
    //    | [] -> Seq.empty<Map<string<key>, string<description> * 'a>>
    //    | [(key, values)] ->
    //        seq { for value in values do yield Map.ofList [(key, value)] }
    //    | (key, values)::tl ->
    //        seq {
    //            for value in values do
    //                for restMap in cartesianProductMaps tl do
    //                    yield Map.add key value restMap
    //        }

    ///// Finds the index of a map in a list of maps generated by cartesianProductMaps.
    //let findMapIndex<'a when 'a : comparison> (map: Map<string<key>, string<description> * 'a>) (lists: list<string<key> * list<string<description> * 'a>>) 
    //                    : int option =
    //    let targetSeq = Map.toSeq map |> Set.ofSeq
    //    cartesianProductMaps lists
    //    |> Seq.tryFindIndex (fun m -> Map.toSeq m |> Set.ofSeq = targetSeq)



    /// Computes the Cartesian product of a list of key-value pairs, yielding all possible maps.
    let rec cartesianProductMaps (lists: list<string * list<string>>) : Map<string, string> seq =
        match lists with
        | [] -> Seq.empty<Map<string, string>>
        | [(key, values)] ->
            seq { for value in values do yield Map.ofList [(key, value)] }
        | (key, values)::tl ->
            seq {
                for value in values do
                    for restMap in cartesianProductMaps tl do
                        yield Map.add key value restMap
            }

    /// Finds the index of a map in a list of maps generated by cartesianProductMaps.
    let findMapIndex (map: Map<string, string>) (lists: list<string * list<string>>) 
                        : int option =
        let targetSeq = Map.toSeq map |> Set.ofSeq
        cartesianProductMaps lists
        |> Seq.tryFindIndex (fun m -> Map.toSeq m |> Set.ofSeq = targetSeq)


    /// Generates a binomial random variable by simulating trials.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="trials">The number of trials (must be non-negative).</param>
    /// <param name="probability">The success probability (must be in [0,1]).</param>
    /// <returns>The number of successes.</returns>
    /// <exception cref="System.ArgumentException">Thrown when trials or probability is invalid.</exception>
    let binomialSample (floatPicker: unit -> float) (trials: int) (probability: float) : int =
        if trials < 0 then invalidArg "trials" "Number of trials must be non-negative"
        if probability < 0.0 || probability > 1.0 then invalidArg "probability" "Probability must be between 0 and 1"
        let mutable successes = 0
        for _ in 1 .. trials do
            if floatPicker() < probability then
                successes <- successes + 1
        successes


    /// Generates a binomial random variable using normal approximation for large trials.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="trials">The number of trials (must be non-negative).</param>
    /// <param name="probability">The success probability (must be in [0,1]).</param>
    /// <returns>The number of successes.</returns>
    /// <exception cref="System.ArgumentException">Thrown when trials or probability is invalid.</exception>
    let binomialSampleWithApprox (floatPicker: unit -> float) (trials: int) (probability: float) : int =
        if trials < 0 then invalidArg "trials" "Number of trials must be non-negative"
        if probability < 0.0 || probability > 1.0 then invalidArg "probability" "Probability must be between 0 and 1"
        let np = float trials * probability
        let npq = np * (1.0 - probability)
        if trials > 500 && np > 5.0 && npq > 5.0 then
            let stdDev = sqrt npq
            // Improved normal random variable using Box-Muller (simplified)
            let u1 = floatPicker()
            let u2 = floatPicker()
            let normal = sqrt (-2.0 * log u1) * cos (2.0 * System.Math.PI * u2)
            let normalSample = np + stdDev * normal
            max 0 (min trials (int (round normalSample)))
        else
            let mutable successes = 0
            for _ in 1 .. trials do
                if floatPicker() < probability then
                    successes <- successes + 1
            successes


    /// Performs a Fisher-Yates shuffle, yielding a sequence of shuffled items.
    /// <param name="indexShuffler">A function generating random indices in [0, nLeft).</param>
    /// <param name="initialList">The input array to shuffle.</param>
    /// <returns>A sequence of shuffled items.</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when initialList is null.</exception>
    /// <exception cref="System.ArgumentException">Thrown when indexShuffler returns an invalid index.</exception>
    let fisherYatesShuffle (indexShuffler: int -> int) 
                           (initialList: 'a array) : 'a seq =
        let availableFlags = Array.init initialList.Length (fun i -> (i, true))
    
        let nextItem nLeft =
            let nItem = indexShuffler nLeft // Random index from remaining items
            let index =
                availableFlags
                |> Array.filter (fun (_, flag) -> flag)
                |> Array.item nItem
                |> fst
            availableFlags.[index] <- (index, false) // Mark as used
            initialList.[index]
    
        seq { for n in initialList.Length .. -1 .. 1 -> nextItem n }


    /// Picks two distinct numbers from 0 to n-1 and returns them in ascending order.
    /// <param name="indexPicker">A function generating random indices in [0, n).</param>
    /// <param name="n">The range of indices (must be at least 2).</param>
    /// <returns>A tuple of two distinct indices in ascending order.</returns>
    /// <exception cref="System.ArgumentException">Thrown when n is less than 2 or indexPicker returns invalid indices.</exception>
    let pickAndOrderTwoDistinct (indexPicker: int -> int) (n: int) : int * int =
        if n < 2 then invalidArg "n" "n must be at least 2 to pick two distinct numbers"
        let first = indexPicker n
        if first < 0 || first >= n then invalidArg "indexPicker" $"First index {first} out of range [0, {n})"
        let second = 
            let rec pickDistinct () =
                let candidate = indexPicker n
                if candidate < 0 || candidate >= n then invalidArg "indexPicker" $"Second index {candidate} out of range [0, {n})"
                if candidate <> first then candidate
                else pickDistinct ()
            pickDistinct ()
        if first < second then (first, second) else (second, first)


    /// Picks three distinct numbers from 0 to n-1 and returns them in ascending order.
    /// <param name="indexPicker">A function generating random indices in [0, n).</param>
    /// <param name="n">The range of indices (must be at least 3).</param>
    /// <returns>A tuple of three distinct indices in ascending order.</returns>
    /// <exception cref="System.ArgumentException">Thrown when n is less than 3 or indexPicker returns invalid indices.</exception>
    let pickAndOrderThreeDistinct (indexPicker: int -> int) (n: int) : int * int * int =
        // Validate input
        if n < 3 then
            failwith "n must be at least 3 to pick three distinct numbers"
        
        // Pick the first number
        let first = indexPicker n
        
        // Pick a second number, ensuring it's distinct from the first
        let second =
            let rec pickDistinctFromFirst () =
                let candidate = indexPicker n
                if candidate <> first then candidate
                else pickDistinctFromFirst ()
            pickDistinctFromFirst ()
        
        // Pick a third number, ensuring it's distinct from both first and second
        let third =
            let rec pickDistinctFromFirstAndSecond () =
                let candidate = indexPicker n
                if candidate <> first && candidate <> second then candidate
                else pickDistinctFromFirstAndSecond ()
            pickDistinctFromFirstAndSecond ()
        
        // Sort the three numbers in ascending order
        let numbers = [first; second; third] |> List.sort
        (numbers.[0], numbers.[1], numbers.[2])


    /// Picks items without replacement from an array, filtering based on a chooser function.
    /// <param name="indexShuffler">A function generating random indices for shuffling.</param>
    /// <param name="chooser">A function determining whether to include an item.</param>
    /// <param name="initialList">The input array.</param>
    /// <returns>A sequence of selected items.</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when initialList is null.</exception>
    let pickWithoutReplacement (indexShuffler: int -> int) (chooser: unit -> bool) (initialList: 'a array) : 'a seq =
        if isNull initialList then invalidArg "initialList" "Array cannot be null"
        let shuffled = initialList |> fisherYatesShuffle indexShuffler
        seq {
            for sh in shuffled do
                if chooser() then
                    yield sh
        }


    /// Generates a sequence of items sampled with replacement based on weights, optimized for long lists.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="items">A list of (item, weight) pairs, where weights are non-negative.</param>
    /// <returns>An infinite sequence of sampled items.</returns>
    /// <exception cref="System.ArgumentException">Thrown when items is empty or weights are invalid.</exception>
    let pickWithReplacementLong (floatPicker: unit -> float) (items: ('a * float) list) : seq<'a> =
        if items.IsEmpty then invalidArg "items" "Item list cannot be empty"
        let weights = items |> List.map snd
        if weights |> List.exists (fun w -> w < 0.0) then invalidArg "items" "Weights must be non-negative"
        let totalWeight = weights |> List.sum
        if totalWeight <= 0.0 then invalidArg "items" "Total weight must be positive"
        let cumulativeWeights = 
            weights 
            |> List.scan (+) 0.0 
            |> List.tail 
            |> Array.ofList
        let itemArray = items |> List.map fst |> Array.ofList
        let findIndex r =
            let rec binarySearch low high =
                if low >= high then low
                else
                    let mid = (low + high) / 2
                    if cumulativeWeights.[mid] >= r then binarySearch low mid
                    else binarySearch (mid + 1) high
            binarySearch 0 (Array.length cumulativeWeights)
        seq {
            while true do
                let r = floatPicker() * totalWeight
                yield itemArray.[findIndex r]
        }


    /// Generates a sequence of items sampled with replacement based on weights, optimized for short lists.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="items">A list of (item, weight) pairs, where weights are non-negative.</param>
    /// <returns>An infinite sequence of sampled items.</returns>
    /// <exception cref="System.ArgumentException">Thrown when items is empty or weights are invalid.</exception>
    let pickWithReplacementShort (floatPicker: unit -> float) (items: ('a * float) list) : seq<'a> =
        if items.IsEmpty then failwith "Empty list"
        if (items |> List.forall (fun tup -> (snd tup ) < 0)) then
            failwith "weights must all be positive"
        let totalWeight = items |> List.sumBy snd
        if totalWeight = 0 then
            failwith "all weights cannot be zero"

        seq {
            while true do
                let r = floatPicker() * totalWeight
                let rec select acc weightSum =
                    match acc with
                    | [] -> failwith "Unexpected empty list"
                    | (item, weight) :: rest ->
                        if weightSum + weight >= r then item
                        else select rest (weightSum + weight)
                yield select items 0.0
        }

    /// Picks a single item from a weighted array.
    /// <param name="items">An array of (item, weight) pairs, where weights are non-negative.</param>
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <returns>A randomly selected item based on weights.</returns>
    /// <exception cref="System.ArgumentException">Thrown when items is empty or weights are invalid.</exception>
    let pick (items: ('a * float)[]) (floatPicker: unit -> float) : 'a =
        if items.Length = 0 then invalidArg "items" "Item list cannot be empty"
        if items |> Array.exists (fun (_, w) -> w < 0.0) then invalidArg "items" "Weights must be non-negative"
        let totalWeight = items |> Array.sumBy snd
        if totalWeight <= 0.0 then invalidArg "items" "Total weight must be positive"
        let r = floatPicker() * totalWeight
        let mutable weightSum = 0.0
        let mutable selectedItem = fst items.[items.Length - 1] // Fallback to last item
        let mutable i = 0
        while i < items.Length && weightSum <= r do
            let (item, weight) = items.[i]
            weightSum <- weightSum + weight
            if weightSum >= r then
                selectedItem <- item
            i <- i + 1
        selectedItem




