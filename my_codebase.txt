namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Core")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Core")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Core")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Core")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd0ecb4b7b45c20f3de2591024c41fde4f7aea3a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Core")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Core")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("MergeSort.Core")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")>]
[<assembly: System.Reflection.AssemblyProductAttribute("MergeSort.Core")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("MergeSort.Core")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Core")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Release")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+c0cdc112d9c5b01145f143569ebe9e98ebe2e8d2")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Core")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Core")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace GeneSort.Core

open System
open FSharp.UMX
open Combinatorics


module Perm_RsOps = 

    // Create a random Perm_Rs
    let makeRandomPerm_Rs
            (indexPicker: int -> int) 
            (floatPicker: unit -> float)
            (opsGenRates: OpsGenRates) 
            (order: int)  : Perm_Rs =
        if(order % 2 <> 0) then
            failwith "Perm_Rs order must be even"
            
        let mutationModePicker () = 
                opsGenRates.PickMode floatPicker

        let rsPairTracker = Array.init (order / 2) (fun dex -> ((dex, reflect order dex), true))
        let _availableFlags () = rsPairTracker |> Seq.filter (fun (_, f) -> f)

        let twoOrbits =
            seq {
                while (_availableFlags () |> Seq.length > 0) do
                    if (_availableFlags () |> Seq.length < 2) then
                        // Since only one pair is left, just yield it
                        let lastOne = _availableFlags () |> Seq.head |> fst
                        rsPairTracker.[fst lastOne] <- (lastOne, false)
                        yield lastOne
                    else
                        let (dex1, dex2) = pickAndOrderTwoDistinct indexPicker (_availableFlags () |> Seq.length)
                        let pair1 = rsPairTracker.[dex1] |> fst
                        let pair2 = rsPairTracker.[dex2] |> fst 
                        rsPairTracker.[dex1] <- (pair1, false)
                        rsPairTracker.[dex2] <- (pair2, false)
                        let mode = mutationModePicker ()
                        match mode with
                        | OpsGenMode.SelfRefl ->
                            // return original self-symmetric pairs
                            yield pair1
                            yield pair2
                        | OpsGenMode.Ortho ->
                            // reconfigure pairs as Ortho pairs
                            yield (fst pair1, fst pair2)
                            yield (snd pair1, snd pair2)
                        | OpsGenMode.Para ->
                            // reconfigure pairs as Para pairs
                            yield (fst pair1, snd pair2)
                            yield (fst pair2, snd pair1)
            } |> Seq.toList

        
        let perm_Si = twoOrbits |> Perm_Si.fromTranspositions order

        Perm_Rs.create perm_Si.Array




    /// Analyzes two distinct points in a Perm_Rs permutation to determine their symmetry properties.
    /// <param name="indexPicker">Function to select a random index from 0 to n-1.</param>
    /// <param name="permRs">The Perm_Rs permutation to analyze, which must be self-inverse.</param>
    /// <returns>A TwoOrbitPair </returns>
    /// <exception cref="ArgumentException">Thrown if permRs.Order is less than 4 or not even, or if PermPair constraints are violated.</exception>
    let findRsPoints (indexPicker: int -> int) (permRs: Perm_Rs) : TwoOrbitPair =
        // Validate input
        let order = %permRs.Order
        let permArray = permRs.Array

        let _randomlyFindOtherReflectionSymmetricTwoOrbits (indexToExclude:int) =
            let rsTwoOrbs = permRs.Perm_Si 
                           |> Perm_Si.getTwoOrbits 
                           |> Array.filter(fun tob -> 
                            (tob |> TwoOrbit.isReflectionSymmetric %permRs.Order) && (tob.First <> indexToExclude))
            if rsTwoOrbs.Length = 0 then
               None
            else
               Some (rsTwoOrbs[indexPicker (rsTwoOrbs.Length)])

        // Select two distinct indices in ascending order
        let first, second = pickAndOrderTwoDistinct indexPicker (order / 2)
        
        // Compute reflection indices
        let firstReflect = reflect order first
        let secondReflect = reflect order second
        
        // Get mapped values from the permutation
        let firstMap = permArray.[first]
        let secondMap = permArray.[second]
        
        if firstReflect = firstMap then
            if secondReflect = secondMap then
                // Both points are self-symmetric
                TwoOrbitPair.create order (TwoOrbit.create [ first; firstMap ]) (TwoOrbit.create [ second; secondMap] |> Some) 
            else
                // First point is self-symmetric, second is not
                let otherRsTwoOrbit = _randomlyFindOtherReflectionSymmetricTwoOrbits first
                match otherRsTwoOrbit with
                | Some orb -> 
                    TwoOrbitPair.create order (TwoOrbit.create [ first; firstMap ]) (orb |> Some) 
                | None ->
                    let secondReflectMap = permArray.[secondReflect]
                    TwoOrbitPair.create order (TwoOrbit.create [ second; secondMap ]) (TwoOrbit.create [ secondReflect; secondReflectMap] |> Some) 
        else
            // Neither point is self-symmetric, use first point's reflection
            let firstReflectMap = permArray.[firstReflect]
            TwoOrbitPair.create order (TwoOrbit.create [ first; firstMap ]) (TwoOrbit.create [ firstReflect; firstReflectMap] |> Some) 



    // Mutates a Perm_Rs based on opsActionMode
    let mutatePerm_Rs
            (indexPicker: int -> int) 
            (opsActionMode:OpsActionMode) 
            (permRs: Perm_Rs) : Perm_Rs =

        if (opsActionMode = OpsActionMode.NoAction) then
            // for NoAction mode, return the permutation as is
            permRs
        else
            let newArray = Array.copy permRs.Array
            // Find two points in the permutation to mutate
            let twoOrbitPair = findRsPoints indexPicker permRs

            let twoOrbitTypeOpt = twoOrbitPair |> TwoOrbitPairOps.getTwoOrbitPairTypeOption
            let twoOrbitPairTypeFound = 
                match twoOrbitTypeOpt with
                | Some t -> t
                | None -> failwith "TwoOrbitPair must have a valid TwoOrbitPairType"
            let secondPair = 
                match twoOrbitPair.SecondOrbit with
                | Some sto -> sto
                | None -> failwith "TwoOrbitPair must have a SecondOrbit"

            let firstL = twoOrbitPair.FirstOrbit.First
            let firstH = twoOrbitPair.FirstOrbit.Second
            let secondL = secondPair.First
            let secondH = secondPair.Second

            match opsActionMode with
            | OpsActionMode.Ortho -> 
                match twoOrbitPairTypeFound with
                | TwoOrbitPairType.Ortho -> ()

                | _ -> 
                    newArray.[firstL] <- secondL
                    newArray.[secondL] <- firstL 
                    newArray.[firstH] <- secondH
                    newArray.[secondH] <- firstH 

            | OpsActionMode.Para -> 
                match twoOrbitPairTypeFound with
                | TwoOrbitPairType.Ortho -> 
                    newArray.[firstL] <- secondL
                    newArray.[secondL] <- firstL 
                    newArray.[firstH] <- secondH
                    newArray.[secondH] <- firstH

                | TwoOrbitPairType.Para -> ()

                | TwoOrbitPairType.SelfRefl -> 
                    newArray.[firstL] <- secondH
                    newArray.[secondH] <- firstL 
                    newArray.[firstH] <- secondL
                    newArray.[secondL] <- firstH 

            | OpsActionMode.SelfRefl -> 
                match twoOrbitPairTypeFound with
                | TwoOrbitPairType.SelfRefl -> ()
                | _ -> 
                    newArray.[firstL] <- secondH
                    newArray.[secondH] <- firstL 
                    newArray.[secondL] <- firstH
                    newArray.[firstH] <- secondL 
            | OpsActionMode.NoAction -> failwith "NoAction mode should not reach here"

            newArray |> Perm_Rs.createUnsafe

namespace GeneSort.Core

module TwoOrbitTypeOps =

    ///makeTwoOrbitTypeGen
    let makeTwoOrbitTypes 
            (floatPicker:unit -> float)
            (opsGenRates:OpsGenRates) 
            : TwoOrbitType seq =
        seq {
            while true do
                floatPicker |> opsGenRates.PickMode |> OpsGenMode.toTwoOrbitType
        }

    let mutateTwoOrbitTypes
            (floatPicker:unit -> float)
            (opsTransitionRates:OpsTransitionRates)
            (twoOrbitTypes:TwoOrbitType seq)
             : TwoOrbitType seq =

         twoOrbitTypes |> Seq.map( fun topt ->
                match topt with
                | TwoOrbitType.Ortho -> 
                    match (opsTransitionRates.PickMode floatPicker TwoOrbitType.Ortho) with
                    | OpsActionMode.Para -> TwoOrbitType.Para
                    | OpsActionMode.SelfRefl -> TwoOrbitType.SelfRefl
                    | _ -> TwoOrbitType.Ortho
 
                | TwoOrbitType.Para -> 
                    match (opsTransitionRates.PickMode floatPicker TwoOrbitType.Para) with
                    | OpsActionMode.Ortho -> TwoOrbitType.Ortho
                    | OpsActionMode.SelfRefl -> TwoOrbitType.SelfRefl
                    | _ -> TwoOrbitType.Para

                | TwoOrbitType.SelfRefl -> 
                    match (opsTransitionRates.PickMode floatPicker TwoOrbitType.SelfRefl) with
                    | OpsActionMode.Para -> TwoOrbitType.Para
                    | OpsActionMode.Ortho -> TwoOrbitType.Ortho
                    | _ -> TwoOrbitType.SelfRefl
                )


    // makeTwoOrbitUnfolderStep
    let makeTwoOrbitUnfolderStep
                (floatPicker:unit -> float)
                (order:int) 
                (opsGenRates:OpsGenRates) 
                : TwoOrbitUfStep =
        TwoOrbitUfStep.create 
                (makeTwoOrbitTypes floatPicker opsGenRates 
                    |> Seq.take (order / 2)
                    |> Seq.toList)
                order


    // mutateTwoOrbitUnfolderStep
    let mutateTwoOrbitUnfolderStep
                (floatPicker:unit -> float)
                (opsTransitionRates:OpsTransitionRates) 
                (twoOrbitUfStep:TwoOrbitUfStep) =
        TwoOrbitUfStep.create 
                (mutateTwoOrbitTypes floatPicker opsTransitionRates twoOrbitUfStep.twoOrbitTypes
                    |> Seq.take (twoOrbitUfStep.Order / 2)
                    |> Seq.toList)
                twoOrbitUfStep.Order
namespace GeneSort.Core

module UnfolderOps4 = 

    // makeTwoOrbitUnfolder4
    let makeTwoOrbitUf4 (floatPicker:unit -> float) (uf4GenRates:Uf4GenRates)
                        : TwoOrbitUf4 =

        let seedTypeUf4 = floatPicker |> uf4GenRates.seedOpsGenRates.PickMode |> OpsGenMode.toTwoOrbitType
        let twoOrbitUnfolderSteps = 
            uf4GenRates.opsGenRatesList
                |> List.mapi(fun dex rates ->
                    TwoOrbitTypeOps.makeTwoOrbitUnfolderStep floatPicker (4 * (MathUtils.integerPower 2 dex)) rates)
        TwoOrbitUf4.create seedTypeUf4 twoOrbitUnfolderSteps


    // mutateTwoOrbitUnfolder4
    let mutateTwoOrbitUf4
                (floatPicker:unit -> float)
                (uf4MutationRates:Uf4MutationRates) 
                (twoOrbitUf4:TwoOrbitUf4) : TwoOrbitUf4 =

        let twoOrbitTypeMutated = 
                uf4MutationRates.seedOpsTransitionRates.TransitionMode 
                        floatPicker 
                        (twoOrbitUf4.TwoOrbitType |> OpsGenMode.fromTwoOrbitType )
                        |> OpsGenMode.toTwoOrbitType

        let twoOrbitUnfolderSteps = 
                                uf4MutationRates.twoOrbitPairOpsTransitionRates
                                |> List.mapi(fun dex rates -> 
                    TwoOrbitTypeOps.mutateTwoOrbitUnfolderStep floatPicker rates twoOrbitUf4.TwoOrbitUnfolderSteps[dex])

        TwoOrbitUf4.create twoOrbitTypeMutated twoOrbitUnfolderSteps



module UnfolderOps6 =
 
    // makeTwoOrbitUnfolder6
    let makeTwoOrbitUf6 (floatPicker:unit -> float) (uf6GenRates:Uf6GenRates) 
                : TwoOrbitUf6 =

        let seed6TwoOrbitType = 
                uf6GenRates.seedGenRatesUf6.PickMode floatPicker |> Seed6GenMode.toSeed6TwoOrbitType

        let twoOrbitUfSteps = uf6GenRates.opsGenRatesList
                                |> List.mapi(
            fun dex rates -> TwoOrbitTypeOps.makeTwoOrbitUnfolderStep floatPicker (6 * (MathUtils.integerPower 2 dex)) rates)

        TwoOrbitUf6.create seed6TwoOrbitType twoOrbitUfSteps


    // mutateTwoOrbitUnfolder6
    let mutateTwoOrbitUf6
                (floatPicker:unit -> float)
                (uf6MutationRates:Uf6MutationRates) 
                (twoOrbitUf6:TwoOrbitUf6) : TwoOrbitUf6 =

        let seed6TwoOrbitTypeMutated = 
                uf6MutationRates.seed6TransitionRates.TransitionMode
                        floatPicker
                        (twoOrbitUf6.Seed6TwoOrbitType |> Seed6GenMode.fromSeed6TwoOrbitType)
                        |> Seed6GenMode.toSeed6TwoOrbitType

        let twoOrbitUnfolderSteps = 
                    uf6MutationRates.opsTransitionRates
                    |> List.mapi(
                fun dex rates -> 
                    TwoOrbitTypeOps.mutateTwoOrbitUnfolderStep floatPicker rates twoOrbitUf6.TwoOrbitUnfolderSteps[dex])

        TwoOrbitUf6.create seed6TwoOrbitTypeMutated twoOrbitUnfolderSteps



namespace GeneSort.Core
open System
open Combinatorics

type IndelMode =
    | NoAction
    | Mutation
    | Insertion
    | Deletion


[<Struct; CustomEquality; NoComparison>]
type IndelRates = 
    private 
        { mutationThresh: float; insertionThresh: float; deletionThresh: float }

    static member create (mutationRate: float, insertionRate: float, deletionRate: float) : IndelRates =
        let noAction = 1.0 - mutationRate - insertionRate - deletionRate
        let epsilon = 1e-10
        if mutationRate < 0.0 || mutationRate > 1.0 then failwith "mutationRate must be between 0 and 1"
        else if insertionRate < 0.0 || insertionRate > 1.0 then failwith "insertionRate must be between 0 and 1"
        else if deletionRate < 0.0 || deletionRate > 1.0 then failwith "deletionRate must be between 0 and 1"
        else if noAction < -epsilon then failwith "Sum of Indel rates must not exceed 1.0"
        {
            mutationThresh = mutationRate
            insertionThresh = mutationRate + insertionRate
            deletionThresh = mutationRate + insertionRate + deletionRate
        }

    member this.MutationRate with get() = this.mutationThresh
    member this.InsertionRate with get() = this.insertionThresh - this.mutationThresh
    member this.DeletionRate with get() = this.deletionThresh - this.insertionThresh
    member this.NoActionRate with get() = 1.0 - this.deletionThresh
    member this.toString() =
        sprintf "IndelRates(Mutation: %.2f, Insertion: %.2f, Deletion: %.2f)" 
                this.MutationRate this.InsertionRate this.DeletionRate  

    /// Assumes that floatPicker returns a float in the range [0.0, 1.0).
    member this.PickMode (floatPicker: unit -> float) : IndelMode =
        let r = floatPicker()
        if r < this.mutationThresh then
            IndelMode.Mutation
        elif r < this.insertionThresh then
            IndelMode.Insertion
        elif r < this.deletionThresh then
            IndelMode.Deletion
        else
        IndelMode.NoAction

    override this.Equals(obj) = 
        match obj with
        | :? IndelRates as other -> 
            this.mutationThresh = other.mutationThresh &&
            this.insertionThresh = other.insertionThresh &&
            this.deletionThresh = other.deletionThresh
        | _ -> false

    override this.GetHashCode() = 
        hash (this.mutationThresh, this.insertionThresh, this.deletionThresh)

    interface IEquatable<IndelRates> with
        member this.Equals(other) = 
            this.mutationThresh = other.mutationThresh &&
            this.insertionThresh = other.insertionThresh &&
            this.deletionThresh = other.deletionThresh



namespace GeneSort.Core

open System

[<Struct; CustomEquality; NoComparison>]
type IndelRatesArray =

    private { Rates: IndelRates array }
    static member create (rates: IndelRates array) : IndelRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        { Rates = rates }
    member this.Length = this.Rates.Length
    member this.Item(index: int) = this.Rates.[index]
    member this.RatesArray = this.Rates
    member this.toString() =
        String.Join(", ", Array.map (fun r -> r.ToString()) this.Rates)

    override this.Equals(obj) =
        match obj with
        | :? IndelRatesArray as other ->
            if this.Rates.Length <> other.Rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.Rates other.Rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.Rates do
            hash <- hash * 23 + rate.GetHashCode()
        hash

    interface IEquatable<IndelRatesArray> with
        member this.Equals(other) =
            if this.Rates.Length <> other.Rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.Rates other.Rates


module IndelRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    // Smooth variation: Linear interpolation from startRates to endRates
    let createLinearVariation (length: int) (startRates: IndelRates) (endRates: IndelRates) : IndelRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let m = startRates.MutationRate + t * (endRates.MutationRate - startRates.MutationRate)
                let i = startRates.InsertionRate + t * (endRates.InsertionRate - startRates.InsertionRate)
                let d = startRates.DeletionRate + t * (endRates.DeletionRate - startRates.DeletionRate)
                IndelRates.create (m, i, d))
        IndelRatesArray.create rates

    // Smooth variation: Sinusoidal variation around base rates
    let createSinusoidalVariation (length: int) (baseRates: IndelRates) (amplitudes: IndelRates) (frequency: float) : IndelRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let m = clamp (baseRates.MutationRate + amplitudes.MutationRate * Math.Sin(t)) 0.0 1.0
                let i = clamp (baseRates.InsertionRate + amplitudes.InsertionRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0
                let d = clamp (baseRates.DeletionRate + amplitudes.DeletionRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0
                IndelRates.create (m, i, d))
        IndelRatesArray.create rates

    // Hot spot: Gaussian peak at specified index
    let createGaussianHotSpot (length: int) (baseRates: IndelRates) (hotSpotIndex: int) (hotSpotRates: IndelRates) (sigma: float) : IndelRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let m = baseRates.MutationRate + (hotSpotRates.MutationRate - baseRates.MutationRate) * weight
                let i = baseRates.InsertionRate + (hotSpotRates.InsertionRate - baseRates.InsertionRate) * weight
                let d = baseRates.DeletionRate + (hotSpotRates.DeletionRate - baseRates.DeletionRate) * weight
                IndelRates.create (m, i, d))
        IndelRatesArray.create rates

    // Hot spot: Step function creating a region of elevated rates
    let createStepHotSpot (length: int) (baseRates: IndelRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: IndelRates) : IndelRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                IndelRates.create (rates.MutationRate, rates.InsertionRate, rates.DeletionRate))
        IndelRatesArray.create rates

    /// Mutates an arry based on the provided rates. Returns a new array, with the same length as the input array.
    /// If Deletion is done d times, and Insertion is done i times, and p = d - i > 0, then Insertion is called p times at the end so the 
    /// returned array has the same length as the input array.
    let mutate<'a> 
        (indelRatesArray: IndelRatesArray) 
        (inserter: unit -> 'a) 
        (mutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if indelRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
    
        let mutable deletionCount = 0
        let mutable insertionCount = 0
    
        let results = 
            seq {
                for i in 0 .. arrayToMutate.Length - 1 do
                    let rate = indelRatesArray.Item(i)
                    match rate.PickMode floatPicker with
                    | IndelMode.Mutation -> 
                        yield mutator arrayToMutate.[i]
                    | IndelMode.Insertion -> 
                        insertionCount <- insertionCount + 1
                        yield inserter ()
                        yield arrayToMutate.[i]
                    | IndelMode.Deletion -> 
                        deletionCount <- deletionCount + 1
                    | IndelMode.NoAction -> 
                        yield arrayToMutate.[i]
            } |> Seq.toArray
    
        let p = deletionCount - insertionCount
        if p > 0 then
            // Append p insertions to match input length
            Array.append results (Array.init p (fun _ -> inserter ()))
        elif p < 0 then
            // Trim excess elements to match input length
            Array.take arrayToMutate.Length results
        else
            results
namespace GeneSort.Core
open System

type OpActionMode =
    | NoAction
    | Ortho
    | Para


[<Struct; CustomEquality; NoComparison>]
type OpActionRates = 
    private 
        { orthoThresh: float; paraThresh: float; }

    static member create (orthoRate: float, paraRate: float) : OpActionRates =
        let noAction = 1.0 - orthoRate - paraRate
        let epsilon = 1e-10
        if orthoRate < 0.0 || orthoRate > 1.0 then failwith "orthoRate must be between 0 and 1"
        else if paraRate < 0.0 || paraRate > 1.0 then failwith "paraRate must be between 0 and 1"
        else if noAction < -epsilon then failwith "Sum of OpActionRates rates must not exceed 1.0"
        {
            orthoThresh = orthoRate
            paraThresh = orthoRate + paraRate
        }

    static member createUniform (amt:float) : OpActionRates =
        OpActionRates.create(amt, amt)

    static member createBiased(opActionMode: OpActionMode, baseAmt:float, biasAmt: float) : OpActionRates =
        match opActionMode with
        | OpActionMode.Ortho -> OpActionRates.create(baseAmt + biasAmt, baseAmt - biasAmt)
        | OpActionMode.Para -> OpActionRates.create(baseAmt - biasAmt, baseAmt + biasAmt)
        | OpActionMode.NoAction -> failwith "NoAction mode is not valid for OpActionRates"


    member this.OrthoRate with get() = this.orthoThresh
    member this.ParaRate with get() = this.paraThresh - this.orthoThresh
    member this.NoActionRate with get() = 1.0 - this.paraThresh
    member this.toString() =
        sprintf "OpActionRates(Ortho: %.2f, Para: %.2f)" 
                this.OrthoRate this.ParaRate    

    /// Assumes that floatPicker returns a float in the range [0.0, 1.0).
    member this.PickMode (floatPicker: unit -> float) : OpActionMode =
        let r = floatPicker()
        if r < this.orthoThresh then
            OpActionMode.Ortho
        elif r < this.paraThresh then
            OpActionMode.Para
        else
        OpActionMode.NoAction

    override this.Equals(obj) = 
        match obj with
        | :? OpActionRates as other -> 
            this.orthoThresh = other.orthoThresh &&
            this.paraThresh = other.paraThresh
        | _ -> false

    override this.GetHashCode() = 
        hash (this.orthoThresh, this.paraThresh)

    interface IEquatable<IndelRates> with
        member this.Equals(other) = 
            this.orthoThresh = other.mutationThresh &&
            this.paraThresh = other.insertionThresh


namespace GeneSort.Core

open System

[<Struct; CustomEquality; NoComparison>]
type OpActionRatesArray =

    private { Rates: OpActionRates array }
    static member create (rates: OpActionRates array) : OpActionRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        { Rates = rates }
    member this.Length = this.Rates.Length
    member this.Item(index: int) = this.Rates.[index]
    member this.RatesArray = this.Rates
    member this.toString() =
        String.Join(", ", Array.map (fun r -> r.ToString()) this.Rates)

    override this.Equals(obj) =
        match obj with
        | :? OpActionRatesArray as other ->
            if this.Rates.Length <> other.Rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.Rates other.Rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.Rates do
            hash <- hash * 23 + rate.GetHashCode()
        hash

    interface IEquatable<OpActionRatesArray> with
        member this.Equals(other) =
            if this.Rates.Length <> other.Rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.Rates other.Rates

module OpActionRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    // Smooth variation: Linear interpolation from startRates to endRates
    let createLinearVariation (length: int) (startRates: OpActionRates) (endRates: OpActionRates) : OpActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let o = startRates.OrthoRate + t * (endRates.OrthoRate - startRates.OrthoRate)
                let p = startRates.ParaRate + t * (endRates.ParaRate - startRates.ParaRate)
                OpActionRates.create (o, p))
        OpActionRatesArray.create rates

    // Smooth variation: Sinusoidal variation around base rates
    let createSinusoidalVariation (length: int) (baseRates: OpActionRates) (amplitudes: OpActionRates) (frequency: float) : OpActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let o = clamp (baseRates.OrthoRate + amplitudes.OrthoRate * Math.Sin(t)) 0.0 1.0
                let p = clamp (baseRates.ParaRate + amplitudes.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0
                OpActionRates.create (o, p))
        OpActionRatesArray.create rates

    // Hot spot: Gaussian peak at specified index
    let createGaussianHotSpot (length: int) (baseRates: OpActionRates) (hotSpotIndex: int) (hotSpotRates: OpActionRates) (sigma: float) : OpActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let o = baseRates.OrthoRate + (hotSpotRates.OrthoRate - baseRates.OrthoRate) * weight
                let p = baseRates.ParaRate + (hotSpotRates.ParaRate - baseRates.ParaRate) * weight
                OpActionRates.create (o, p))
        OpActionRatesArray.create rates

    // Hot spot: Step function creating a region of elevated rates
    let createStepHotSpot (length: int) (baseRates: OpActionRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: OpActionRates) : OpActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                OpActionRates.create (rates.OrthoRate, rates.ParaRate))
        OpActionRatesArray.create rates

    /// Mutates an arrayToMutate based on the provided rates. Returns a new array.
    /// Unlike IndelRatesArray, no length adjustments are needed since SiMutationMode does not include insertion or deletion.
    let mutate<'a> 
        (opActionRatesArray: OpActionRatesArray) 
        (orthoMutator: 'a -> 'a) 
        (paraMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if opActionRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
    
        Array.init arrayToMutate.Length (fun i ->
            let rate = opActionRatesArray.Item(i)
            match rate.PickMode floatPicker with
            | OpActionMode.Ortho -> orthoMutator arrayToMutate.[i]
            | OpActionMode.Para -> paraMutator arrayToMutate.[i]
            | OpActionMode.NoAction -> arrayToMutate.[i])
namespace GeneSort.Core
open System

type OpsActionMode =
    | NoAction
    | Ortho
    | Para
    | SelfRefl


[<Struct; CustomEquality; NoComparison>]
type OpsActionRates = 
    private 
        { orthoThresh: float; paraThresh: float; selfSymThresh: float; }

    static member create (orthoRate: float, paraRate: float, selfSymRate: float) : OpsActionRates =
        let noAction = 1.0 - orthoRate - paraRate - selfSymRate
        let epsilon = 1e-10
        if orthoRate < 0.0 || orthoRate > 1.0 then failwith "orthoRate must be between 0 and 1"
        else if paraRate < 0.0 || paraRate > 1.0 then failwith "paraRate must be between 0 and 1"
        else if noAction < -epsilon then failwith "Sum of SiMutationRates rates must not exceed 1.0"
        {
            orthoThresh = orthoRate
            paraThresh = orthoRate + paraRate
            selfSymThresh = orthoRate + paraRate + selfSymRate
        }

    static member createUniform (amt:float) : OpsActionRates =
            OpsActionRates.create(amt, amt, amt)

    static member createBiased(opsActionMode: OpsActionMode, baseAmt:float, biasAmt: float) : OpsActionRates =
        match opsActionMode with
        | OpsActionMode.Ortho -> OpsActionRates.create(baseAmt + biasAmt, baseAmt - (biasAmt / 2.0), baseAmt - (biasAmt / 2.0))
        | OpsActionMode.Para -> OpsActionRates.create(baseAmt - (biasAmt / 2.0), baseAmt + biasAmt, baseAmt - (biasAmt / 2.0))
        | OpsActionMode.SelfRefl -> OpsActionRates.create(baseAmt - (biasAmt / 2.0), baseAmt - (biasAmt / 2.0), baseAmt + biasAmt)
        | OpsActionMode.NoAction -> failwith "NoAction mode is not valid for OpsActionRates"


    member this.OrthoRate with get() = this.orthoThresh
    member this.ParaRate with get() = this.paraThresh - this.orthoThresh
    member this.SelfReflRate with get() = this.selfSymThresh - this.paraThresh
    member this.NoActionRate with get() = 1.0 - this.selfSymThresh
    member this.toString() =
        sprintf "OpsActionRates(Ortho: %.2f, Para: %.2f, SelfSym: %.2f)" 
                this.OrthoRate this.ParaRate this.SelfReflRate


    /// Assumes that floatPicker returns a float in the range [0.0, 1.0).
    member this.PickMode (floatPicker: unit -> float) : OpsActionMode =
        let r = floatPicker()
        if r < this.orthoThresh then
            OpsActionMode.Ortho
        elif r < this.paraThresh then
            OpsActionMode.Para
        elif r < this.selfSymThresh then
            OpsActionMode.SelfRefl
        else
        OpsActionMode.NoAction


    member this.PickModeWithDefault 
                (opsGenMode:OpsGenMode) 
                (floatPicker: unit -> float) : OpsGenMode =

        let r = floatPicker()
        if r < this.orthoThresh then
            OpsGenMode.Ortho
        elif r < this.paraThresh then
            OpsGenMode.Para
        elif r < this.selfSymThresh then
            OpsGenMode.SelfRefl
        else
            opsGenMode


    override this.Equals(obj) = 
        match obj with
        | :? OpsActionRates as other -> 
            this.orthoThresh = other.orthoThresh &&
            this.paraThresh = other.paraThresh &&
            this.selfSymThresh = other.selfSymThresh
        | _ -> false

    override this.GetHashCode() = 
        hash (this.orthoThresh, this.paraThresh)

    interface IEquatable<OpsActionRates> with
        member this.Equals(other) = 
            this.orthoThresh = other.orthoThresh &&
            this.paraThresh = other.paraThresh &&
            this.selfSymThresh = other.selfSymThresh


namespace GeneSort.Core

open System

[<Struct; CustomEquality; NoComparison>]
type OpsActionRatesArray =

    private { rates: OpsActionRates array }
    static member create (rates: OpsActionRates array) : OpsActionRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        { rates = rates }
    member this.Length = this.rates.Length
    member this.Item(index: int) = this.rates.[index]
    member this.RatesArray = this.rates
    member this.toString() =
        String.Join(", ", Array.map (fun r -> r.ToString()) this.rates)

    override this.Equals(obj) =
        match obj with
        | :? OpsActionRatesArray as other ->
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.rates other.rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.rates do
            hash <- hash * 23 + rate.GetHashCode()
        hash

    interface IEquatable<OpsActionRatesArray> with
        member this.Equals(other) =
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.rates other.rates


module OpsActionRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    // Smooth variation: Linear interpolation from startRates to endRates
    let createLinearVariation (length: int) (startRates: OpsActionRates) (endRates: OpsActionRates) : OpsActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let o = startRates.OrthoRate + t * (endRates.OrthoRate - startRates.OrthoRate)
                let p = startRates.ParaRate + t * (endRates.ParaRate - startRates.ParaRate)
                let s = startRates.SelfReflRate + t * (endRates.SelfReflRate - startRates.SelfReflRate)
                OpsActionRates.create (o, p, s))
        OpsActionRatesArray.create rates

    // Smooth variation: Sinusoidal variation around base rates
    let createSinusoidalVariation (length: int) (baseRates: OpsActionRates) (amplitudes: OpsActionRates) (frequency: float) : OpsActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let o = clamp (baseRates.OrthoRate + amplitudes.OrthoRate * Math.Sin(t)) 0.0 1.0
                let p = clamp (baseRates.ParaRate + amplitudes.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0
                let s = clamp (baseRates.SelfReflRate + amplitudes.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0
                OpsActionRates.create (o, p, s))
        OpsActionRatesArray.create rates

    // Hot spot: Gaussian peak at specified index
    let createGaussianHotSpot (length: int) (baseRates: OpsActionRates) (hotSpotIndex: int) (hotSpotRates: OpsActionRates) (sigma: float) : OpsActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let o = baseRates.OrthoRate + (hotSpotRates.OrthoRate - baseRates.OrthoRate) * weight
                let p = baseRates.ParaRate + (hotSpotRates.ParaRate - baseRates.ParaRate) * weight
                let s = baseRates.SelfReflRate + (hotSpotRates.SelfReflRate - baseRates.SelfReflRate) * weight
                OpsActionRates.create (o, p, s))
        OpsActionRatesArray.create rates

    // Hot spot: Step function creating a region of elevated rates
    let createStepHotSpot (length: int) (baseRates: OpsActionRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: OpsActionRates) : OpsActionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                OpsActionRates.create (rates.OrthoRate, rates.ParaRate, rates.SelfReflRate))
        OpsActionRatesArray.create rates

    /// Mutates an array based on the provided rates. Returns a new array.
    /// Unlike IndelRatesArray, no length adjustments are needed since OpsMutationMode does not include insertion or deletion.
    let mutate<'a> 
        (opsActionRatesArray: OpsActionRatesArray) 
        (orthoMutator: 'a -> 'a) 
        (paraMutator: 'a -> 'a) 
        (selfSymMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if opsActionRatesArray.Length <> arrayToMutate.Length then
            failwith "ARRAY length does not match rates length"
    
        Array.init arrayToMutate.Length (fun i ->
            let rate = opsActionRatesArray.Item(i)
            match rate.PickMode floatPicker with
            | OpsActionMode.Ortho -> orthoMutator arrayToMutate.[i]
            | OpsActionMode.Para -> paraMutator arrayToMutate.[i]
            | OpsActionMode.SelfRefl -> selfSymMutator arrayToMutate.[i]
            | OpsActionMode.NoAction -> arrayToMutate.[i])


    let createNewItems<'a> 
        (opsActionRatesArray: OpsActionRatesArray)
        (itemChooser: OpsActionRates -> 'a)
            : 'a[] =
        Array.init opsActionRatesArray.Length (fun i ->
            itemChooser (opsActionRatesArray.Item(i)) )
namespace GeneSort.Core
open System

type OpsGenMode =
| Ortho
| Para
| SelfRefl


[<Struct; CustomEquality; NoComparison>]
type OpsGenRates = 
    private 
        { orthoThresh: float; paraThresh: float; selfReflThresh: float }

    static member create (orthoRate: float, paraRate: float, selfSymRate: float) : OpsGenRates =
        let sum = orthoRate + paraRate + selfSymRate
        let epsilon = 1e-10
        if orthoRate < 0.0 || orthoRate > 1.0 then failwith "orthoRate must be between 0 and 1"
        else if paraRate < 0.0 || paraRate > 1.0 then failwith "paraRate must be between 0 and 1"
        else if selfSymRate < 0.0 || selfSymRate > 1.0 then failwith "selfSymRate must be between 0 and 1"
        else if abs (sum - 1.0) > epsilon then failwith "Sum of OpsGenRates rates must equal 1.0"
        {
            orthoThresh = orthoRate
            paraThresh = orthoRate + paraRate
            selfReflThresh = orthoRate + paraRate + selfSymRate
        }

    static member createUniform () : OpsGenRates =
        OpsGenRates.create(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0)

    static member createBiased(opsGenMode: OpsGenMode, bias: float) : OpsGenRates =
        match opsGenMode with
        | OpsGenMode.Ortho -> OpsGenRates.create(bias, (1.0 - bias) / 2.0, (1.0 - bias) / 2.0)
        | OpsGenMode.Para -> OpsGenRates.create((1.0 - bias) / 2.0, bias, (1.0 - bias) / 2.0)
        | OpsGenMode.SelfRefl -> OpsGenRates.create((1.0 - bias) / 2.0, (1.0 - bias) / 2.0, bias)


    member this.OrthoRate with get() = this.orthoThresh
    member this.ParaRate with get() = this.paraThresh - this.orthoThresh
    member this.SelfReflRate with get() = this.selfReflThresh - this.paraThresh
    member this.toString() =
        sprintf "OpsGenRates(Ortho: %.2f, Para: %.2f, SelfSym: %.2f)" 
                this.OrthoRate this.ParaRate this.SelfReflRate

    /// Assumes that floatPicker returns a float in the range [0.0, 1.0).
    member this.PickMode (floatPicker: unit -> float) : OpsGenMode =
        let r = floatPicker()
        if r < this.orthoThresh then
            OpsGenMode.Ortho
        elif r < this.paraThresh then
            OpsGenMode.Para
        else
            OpsGenMode.SelfRefl

    override this.Equals(obj) = 
        match obj with
        | :? OpsGenRates as other -> 
            this.orthoThresh = other.orthoThresh &&
            this.paraThresh = other.paraThresh &&
            this.selfReflThresh = other.selfReflThresh
        | _ -> false

    override this.GetHashCode() = 
        hash (this.orthoThresh, this.paraThresh, this.selfReflThresh)

    interface IEquatable<OpsGenRates> with
        member this.Equals(other) = 
            this.orthoThresh = other.orthoThresh &&
            this.paraThresh = other.paraThresh &&
            this.selfReflThresh = other.selfReflThresh


module OpsGenMode =

    let fromTwoOrbitType (twoOrbitType:TwoOrbitType) : OpsGenMode =
            match twoOrbitType with
            | TwoOrbitType.Ortho -> OpsGenMode.Ortho
            | TwoOrbitType.Para -> OpsGenMode.Para
            | TwoOrbitType.SelfRefl ->  OpsGenMode.SelfRefl

    let toTwoOrbitType (opsGenMode:OpsGenMode) : TwoOrbitType =
            match opsGenMode with
            | OpsGenMode.Ortho -> TwoOrbitType.Ortho
            | OpsGenMode.Para -> TwoOrbitType.Para
            | OpsGenMode.SelfRefl ->  TwoOrbitType.SelfRefl

namespace GeneSort.Core

open System

[<Struct; CustomEquality; NoComparison>]
type OpsGenRatesArray =

    private { Rates: OpsGenRates array }
    static member create (rates: OpsGenRates array) : OpsGenRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        { Rates = rates }
    member this.Length = this.Rates.Length
    member this.Item(index: int) = this.Rates.[index]
    member this.RatesArray = this.Rates
    member this.toString() =
        String.Join(", ", Array.map (fun r -> r.ToString()) this.Rates)

    override this.Equals(obj) =
        match obj with
        | :? OpsGenRatesArray as other ->
            if this.Rates.Length <> other.Rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.Rates other.Rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.Rates do
            hash <- hash * 23 + rate.GetHashCode()
        hash

    interface IEquatable<OpsGenRatesArray> with
        member this.Equals(other) =
            if this.Rates.Length <> other.Rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.Rates other.Rates


module OpsGenRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    let private normalizeRates (ortho: float) (para: float) (selfSym: float) : float * float * float =
        let sum = ortho + para + selfSym
        if sum <= 0.0 then
            (1.0/3.0, 1.0/3.0, 1.0/3.0) // Default to equal distribution if sum is zero
        else
            let scale = 1.0 / sum
            (ortho * scale, para * scale, selfSym * scale)

    // Smooth variation: Linear interpolation from startRates to endRates
    let createLinearVariation (length: int) (startRates: OpsGenRates) (endRates: OpsGenRates) : OpsGenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let o = startRates.OrthoRate + t * (endRates.OrthoRate - startRates.OrthoRate)
                let p = startRates.ParaRate + t * (endRates.ParaRate - startRates.ParaRate)
                let s = startRates.SelfReflRate + t * (endRates.SelfReflRate - startRates.SelfReflRate)
                let (oNorm, pNorm, sNorm) = normalizeRates o p s
                OpsGenRates.create (oNorm, pNorm, sNorm))
        OpsGenRatesArray.create rates

    // Smooth variation: Sinusoidal variation around base rates
    let createSinusoidalVariation (length: int) (baseRates: OpsGenRates) (amplitudes: OpsGenRates) (frequency: float) : OpsGenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let o = clamp (baseRates.OrthoRate + amplitudes.OrthoRate * Math.Sin(t)) 0.0 1.0
                let p = clamp (baseRates.ParaRate + amplitudes.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0
                let s = clamp (baseRates.SelfReflRate + amplitudes.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0
                let (oNorm, pNorm, sNorm) = normalizeRates o p s
                OpsGenRates.create (oNorm, pNorm, sNorm))
        OpsGenRatesArray.create rates

    // Hot spot: Gaussian peak at specified index
    let createGaussianHotSpot (length: int) (baseRates: OpsGenRates) (hotSpotIndex: int) (hotSpotRates: OpsGenRates) (sigma: float) : OpsGenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let o = baseRates.OrthoRate + (hotSpotRates.OrthoRate - baseRates.OrthoRate) * weight
                let p = baseRates.ParaRate + (hotSpotRates.ParaRate - baseRates.ParaRate) * weight
                let s = baseRates.SelfReflRate + (hotSpotRates.SelfReflRate - baseRates.SelfReflRate) * weight
                let (oNorm, pNorm, sNorm) = normalizeRates o p s
                OpsGenRates.create (oNorm, pNorm, sNorm))
        OpsGenRatesArray.create rates

    // Hot spot: Step function creating a region of elevated rates
    let createStepHotSpot (length: int) (baseRates: OpsGenRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: OpsGenRates) : OpsGenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                OpsGenRates.create (rates.OrthoRate, rates.ParaRate, rates.SelfReflRate))
        OpsGenRatesArray.create rates

    /// Mutates an array based on the provided rates. Returns a new array.
    /// No length adjustments are needed since OpsGenMode does not include insertion or deletion.
    let mutate<'a> 
        (opsGenRatesArray: OpsGenRatesArray) 
        (orthoMutator: 'a -> 'a) 
        (paraMutator: 'a -> 'a) 
        (selfSymMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if opsGenRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
    
        Array.init arrayToMutate.Length (fun i ->
            let rate = opsGenRatesArray.Item(i)
            match rate.PickMode floatPicker with
            | OpsGenMode.Ortho -> orthoMutator arrayToMutate.[i]
            | OpsGenMode.Para -> paraMutator arrayToMutate.[i]
            | OpsGenMode.SelfRefl -> selfSymMutator arrayToMutate.[i])
namespace GeneSort.Core
open System

[<Struct; CustomEquality; NoComparison>]
type OpsTransitionRates = 
    private 
        { orthoRates: OpsActionRates
          paraRates: OpsActionRates
          selfReflRates: OpsActionRates }

    static member create (orthoRates: OpsActionRates, paraRates: OpsActionRates, selfReflRates: OpsActionRates) : OpsTransitionRates =
        { 
            orthoRates = orthoRates
            paraRates = paraRates
            selfReflRates = selfReflRates
        }

    static member createUniform (amt: float) : OpsTransitionRates =
        let rates = OpsActionRates.createUniform amt
        OpsTransitionRates.create(rates, rates, rates)


    static member createBiased (twoOrbitType: TwoOrbitType) (baseAmt:float) (biasAmt:float) : OpsTransitionRates =
        match twoOrbitType with
        | TwoOrbitType.Ortho -> 
            let orthoRates = OpsActionRates.createBiased(OpsActionMode.Ortho, baseAmt, biasAmt)
            let paraRates = OpsActionRates.createBiased(OpsActionMode.Ortho, baseAmt, biasAmt)
            let selfReflRates = OpsActionRates.createBiased(OpsActionMode.Ortho, baseAmt, biasAmt)
            OpsTransitionRates.create(orthoRates, paraRates, selfReflRates)
        | TwoOrbitType.Para -> 
            let orthoRates = OpsActionRates.createBiased(OpsActionMode.Para, baseAmt, biasAmt)
            let paraRates = OpsActionRates.createBiased(OpsActionMode.Para, baseAmt + biasAmt, biasAmt)
            let selfReflRates = OpsActionRates.createBiased(OpsActionMode.Para, baseAmt, biasAmt)
            OpsTransitionRates.create(orthoRates, paraRates, selfReflRates)
        | TwoOrbitType.SelfRefl -> 
            let orthoRates = OpsActionRates.createBiased(OpsActionMode.SelfRefl, baseAmt, biasAmt)
            let paraRates = OpsActionRates.createBiased(OpsActionMode.SelfRefl, baseAmt, biasAmt)
            let selfReflRates = OpsActionRates.createBiased(OpsActionMode.SelfRefl, baseAmt, biasAmt)
            OpsTransitionRates.create(orthoRates, paraRates, selfReflRates)


    member this.OrthoRates with get() = this.orthoRates
    member this.ParaRates with get() = this.paraRates
    member this.SelfReflRates with get() = this.selfReflRates

    member this.PickMode (floatPicker: unit -> float) (twoOrbitType: TwoOrbitType) : OpsActionMode =
        match twoOrbitType with
        | TwoOrbitType.Ortho -> this.orthoRates.PickMode floatPicker
        | TwoOrbitType.Para -> this.paraRates.PickMode floatPicker
        | TwoOrbitType.SelfRefl -> this.selfReflRates.PickMode floatPicker


    member this.TransitionMode (floatPicker: unit -> float) (opsGenMode : OpsGenMode) : OpsGenMode =
        match opsGenMode with 
        | OpsGenMode.Ortho -> this.orthoRates.PickModeWithDefault opsGenMode floatPicker
        | OpsGenMode.Para -> this.paraRates.PickModeWithDefault opsGenMode floatPicker
        | OpsGenMode.SelfRefl -> this.selfReflRates.PickModeWithDefault opsGenMode floatPicker


    member this.toString() =
        sprintf "TwoOrbitPairActionRates(Ortho: %s, Para: %s, SelfRefl: %s)"
                (this.orthoRates.toString())
                (this.paraRates.toString())
                (this.selfReflRates.toString())

    override this.Equals(obj) = 
        match obj with
        | :? OpsTransitionRates as other -> 
            this.orthoRates.Equals(other.orthoRates) &&
            this.paraRates.Equals(other.paraRates) &&
            this.selfReflRates.Equals(other.selfReflRates)
        | _ -> false

    override this.GetHashCode() = 
        hash (this.orthoRates, this.paraRates, this.selfReflRates)

    interface IEquatable<OpsTransitionRates> with
        member this.Equals(other) = 
            this.orthoRates.Equals(other.orthoRates) &&
            this.paraRates.Equals(other.paraRates) &&
            this.selfReflRates.Equals(other.selfReflRates)
namespace GeneSort.Core
open System

[<Struct; CustomEquality; NoComparison>]
type OpsTransitionRatesArray =
    private { rates: OpsTransitionRates array }

    static member create (rates: OpsTransitionRates array) : OpsTransitionRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        { rates = rates }

    member this.Length = this.rates.Length
    member this.Item(index: int) = this.rates.[index]
    member this.RatesArray = this.rates

    member this.toString() =
        String.Join(", ", Array.map (fun (r: OpsTransitionRates) -> r.toString()) this.rates)

    override this.Equals(obj) =
        match obj with
        | :? OpsTransitionRatesArray as other ->
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.rates other.rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.rates do
            hash <- hash * 23 + rate.GetHashCode()
        hash

    interface IEquatable<OpsTransitionRatesArray> with
        member this.Equals(other) =
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> a.Equals(b)) this.rates other.rates


module OpsTransitionRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    // Smooth variation: Linear interpolation from startRates to endRates
    let createLinearVariation (length: int) (startRates: OpsTransitionRates) (endRates: OpsTransitionRates) : OpsTransitionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let ortho = OpsActionRates.create(
                    startRates.OrthoRates.OrthoRate + t * (endRates.OrthoRates.OrthoRate - startRates.OrthoRates.OrthoRate),
                    startRates.OrthoRates.ParaRate + t * (endRates.OrthoRates.ParaRate - startRates.OrthoRates.ParaRate),
                    startRates.OrthoRates.SelfReflRate + t * (endRates.OrthoRates.SelfReflRate - startRates.OrthoRates.SelfReflRate))
                let para = OpsActionRates.create(
                    startRates.ParaRates.OrthoRate + t * (endRates.ParaRates.OrthoRate - startRates.ParaRates.OrthoRate),
                    startRates.ParaRates.ParaRate + t * (endRates.ParaRates.ParaRate - startRates.ParaRates.ParaRate),
                    startRates.ParaRates.SelfReflRate + t * (endRates.ParaRates.SelfReflRate - startRates.ParaRates.SelfReflRate))
                let selfRefl = OpsActionRates.create(
                    startRates.SelfReflRates.OrthoRate + t * (endRates.SelfReflRates.OrthoRate - startRates.SelfReflRates.OrthoRate),
                    startRates.SelfReflRates.ParaRate + t * (endRates.SelfReflRates.ParaRate - startRates.SelfReflRates.ParaRate),
                    startRates.SelfReflRates.SelfReflRate + t * (endRates.SelfReflRates.SelfReflRate - startRates.SelfReflRates.SelfReflRate))
                OpsTransitionRates.create(ortho, para, selfRefl))
        OpsTransitionRatesArray.create rates

    // Smooth variation: Sinusoidal variation around base rates
    let createSinusoidalVariation (length: int) (baseRates: OpsTransitionRates) (amplitudes: OpsTransitionRates) (frequency: float) : OpsTransitionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let ortho = OpsActionRates.create(
                    clamp (baseRates.OrthoRates.OrthoRate + amplitudes.OrthoRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                    clamp (baseRates.OrthoRates.ParaRate + amplitudes.OrthoRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                    clamp (baseRates.OrthoRates.SelfReflRate + amplitudes.OrthoRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0)
                let para = OpsActionRates.create(
                    clamp (baseRates.ParaRates.OrthoRate + amplitudes.ParaRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                    clamp (baseRates.ParaRates.ParaRate + amplitudes.ParaRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                    clamp (baseRates.ParaRates.SelfReflRate + amplitudes.ParaRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0)
                let selfRefl = OpsActionRates.create(
                    clamp (baseRates.SelfReflRates.OrthoRate + amplitudes.SelfReflRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                    clamp (baseRates.SelfReflRates.ParaRate + amplitudes.SelfReflRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                    clamp (baseRates.SelfReflRates.SelfReflRate + amplitudes.SelfReflRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0)
                OpsTransitionRates.create(ortho, para, selfRefl))
        OpsTransitionRatesArray.create rates

    // Hot spot: Gaussian peak at specified index
    let createGaussianHotSpot (length: int) (baseRates: OpsTransitionRates) (hotSpotIndex: int) (hotSpotRates: OpsTransitionRates) (sigma: float) : OpsTransitionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let ortho = OpsActionRates.create(
                    baseRates.OrthoRates.OrthoRate + (hotSpotRates.OrthoRates.OrthoRate - baseRates.OrthoRates.OrthoRate) * weight,
                    baseRates.OrthoRates.ParaRate + (hotSpotRates.OrthoRates.ParaRate - baseRates.OrthoRates.ParaRate) * weight,
                    baseRates.OrthoRates.SelfReflRate + (hotSpotRates.OrthoRates.SelfReflRate - baseRates.OrthoRates.SelfReflRate) * weight)
                let para = OpsActionRates.create(
                    baseRates.ParaRates.OrthoRate + (hotSpotRates.ParaRates.OrthoRate - baseRates.ParaRates.OrthoRate) * weight,
                    baseRates.ParaRates.ParaRate + (hotSpotRates.ParaRates.ParaRate - baseRates.ParaRates.ParaRate) * weight,
                    baseRates.ParaRates.SelfReflRate + (hotSpotRates.ParaRates.SelfReflRate - baseRates.ParaRates.SelfReflRate) * weight)
                let selfRefl = OpsActionRates.create(
                    baseRates.SelfReflRates.OrthoRate + (hotSpotRates.SelfReflRates.OrthoRate - baseRates.SelfReflRates.OrthoRate) * weight,
                    baseRates.SelfReflRates.ParaRate + (hotSpotRates.SelfReflRates.ParaRate - baseRates.SelfReflRates.ParaRate) * weight,
                    baseRates.SelfReflRates.SelfReflRate + (hotSpotRates.SelfReflRates.SelfReflRate - baseRates.SelfReflRates.SelfReflRate) * weight)
                OpsTransitionRates.create(ortho, para, selfRefl))
        OpsTransitionRatesArray.create rates

    // Hot spot: Step function creating a region of elevated rates
    let createStepHotSpot (length: int) (baseRates: OpsTransitionRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: OpsTransitionRates) : OpsTransitionRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                OpsTransitionRates.create(
                    OpsActionRates.create(rates.OrthoRates.OrthoRate, rates.OrthoRates.ParaRate, rates.OrthoRates.SelfReflRate),
                    OpsActionRates.create(rates.ParaRates.OrthoRate, rates.ParaRates.ParaRate, rates.ParaRates.SelfReflRate),
                    OpsActionRates.create(rates.SelfReflRates.OrthoRate, rates.SelfReflRates.ParaRate, rates.SelfReflRates.SelfReflRate)))
        OpsTransitionRatesArray.create rates

    /// Mutates an array based on the provided rates. Returns a new array.
    /// Unlike IndelRatesArray, no length adjustments are needed since OpsMutationMode does not include insertion or deletion.
    let mutate<'a> 
        (opsTransitionRatesArray: OpsTransitionRatesArray) 
        (orthoMutator: 'a -> 'a) 
        (paraMutator: 'a -> 'a) 
        (selfSymMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (twoOrbitType: TwoOrbitType) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if opsTransitionRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
    
        Array.init arrayToMutate.Length (fun i ->
            let rate = opsTransitionRatesArray.Item(i)
            match rate.PickMode floatPicker twoOrbitType with
            | OpsActionMode.Ortho -> orthoMutator arrayToMutate.[i]
            | OpsActionMode.Para -> paraMutator arrayToMutate.[i]
            | OpsActionMode.SelfRefl -> selfSymMutator arrayToMutate.[i]
            | OpsActionMode.NoAction -> arrayToMutate.[i])

    let createNewItems<'a> 
        (opsTransitionRatesArray: OpsTransitionRatesArray)
        (itemChooser: OpsTransitionRates -> 'a)
            : 'a[] =
        Array.init opsTransitionRatesArray.Length (fun i ->
            itemChooser (opsTransitionRatesArray.Item(i)))
namespace GeneSort.Core
open System

type Seed6ActionMode =
    | Ortho1
    | Ortho2
    | Para1
    | Para2
    | Para3
    | Para4
    | SelfRefl
    | NoAction


[<Struct; CustomEquality; NoComparison>]
type Seed6ActionRates = 
    private 
        { 
            ortho1Thresh: float
            ortho2Thresh: float
            para1Thresh: float
            para2Thresh: float
            para3Thresh: float
            para4Thresh: float
            selfReflThresh: float
        }

    static member create (ortho1Rate: float, ortho2Rate: float, para1Rate: float, para2Rate: float, 
                         para3Rate: float, para4Rate: float, selfReflRate: float) : Seed6ActionRates =
        let noAction = 1.0 - ortho1Rate - ortho2Rate - para1Rate - para2Rate - para3Rate - para4Rate - selfReflRate
        let epsilon = 1e-10
        if ortho1Rate < 0.0 || ortho1Rate > 1.0 then failwith "ortho1Rate must be between 0 and 1"
        else if ortho2Rate < 0.0 || ortho2Rate > 1.0 then failwith "ortho2Rate must be between 0 and 1"
        else if para1Rate < 0.0 || para1Rate > 1.0 then failwith "para1Rate must be between 0 and 1"
        else if para2Rate < 0.0 || para2Rate > 1.0 then failwith "para2Rate must be between 0 and 1"
        else if para3Rate < 0.0 || para3Rate > 1.0 then failwith "para3Rate must be between 0 and 1"
        else if para4Rate < 0.0 || para4Rate > 1.0 then failwith "para4Rate must be between 0 and 1"
        else if selfReflRate < 0.0 || selfReflRate > 1.0 then failwith "selfReflRate must be between 0 and 1"
        else if noAction < -epsilon then failwith "Sum of Seed6ActionRates rates must not exceed 1.0"
        {
            ortho1Thresh = ortho1Rate
            ortho2Thresh = ortho1Rate + ortho2Rate
            para1Thresh = ortho1Rate + ortho2Rate + para1Rate
            para2Thresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate
            para3Thresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate
            para4Thresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate + para4Rate
            selfReflThresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate + para4Rate + selfReflRate
        }

    static member createUniform (amt: float) : Seed6ActionRates =
        let rate = amt / 7.0
        Seed6ActionRates.create(rate, rate, rate, rate, rate, rate, rate)

    static member createBiased (mode: Seed6ActionMode, baseAmt: float, biasAmt: float) : Seed6ActionRates =
        if baseAmt < 0.0 || baseAmt > 1.0 then failwith "baseAmt must be between 0 and 1"
        if biasAmt < 0.0 || biasAmt > 1.0 then failwith "biasAmt must be between 0 and 1"
        let adjustedBase = baseAmt - (biasAmt / 6.0)
        if adjustedBase < 0.0 then failwith "Adjusted base rate must not be negative"
        let biasedRate = baseAmt + biasAmt
        match mode with
        | Seed6ActionMode.Ortho1 -> Seed6ActionRates.create(biasedRate, adjustedBase, adjustedBase, adjustedBase, adjustedBase, adjustedBase, adjustedBase)
        | Seed6ActionMode.Ortho2 -> Seed6ActionRates.create(adjustedBase, biasedRate, adjustedBase, adjustedBase, adjustedBase, adjustedBase, adjustedBase)
        | Seed6ActionMode.Para1 -> Seed6ActionRates.create(adjustedBase, adjustedBase, biasedRate, adjustedBase, adjustedBase, adjustedBase, adjustedBase)
        | Seed6ActionMode.Para2 -> Seed6ActionRates.create(adjustedBase, adjustedBase, adjustedBase, biasedRate, adjustedBase, adjustedBase, adjustedBase)
        | Seed6ActionMode.Para3 -> Seed6ActionRates.create(adjustedBase, adjustedBase, adjustedBase, adjustedBase, biasedRate, adjustedBase, adjustedBase)
        | Seed6ActionMode.Para4 -> Seed6ActionRates.create(adjustedBase, adjustedBase, adjustedBase, adjustedBase, adjustedBase, biasedRate, adjustedBase)
        | Seed6ActionMode.SelfRefl -> Seed6ActionRates.create(adjustedBase, adjustedBase, adjustedBase, adjustedBase, adjustedBase, adjustedBase, biasedRate)
        | Seed6ActionMode.NoAction -> failwith "NoAction mode is not valid for Seed6ActionRates"



    member this.Ortho1Rate with get() = this.ortho1Thresh
    member this.Ortho2Rate with get() = this.ortho2Thresh - this.ortho1Thresh
    member this.Para1Rate with get() = this.para1Thresh - this.ortho2Thresh
    member this.Para2Rate with get() = this.para2Thresh - this.para1Thresh
    member this.Para3Rate with get() = this.para3Thresh - this.para2Thresh
    member this.Para4Rate with get() = this.para4Thresh - this.para3Thresh
    member this.SelfReflRate with get() = this.selfReflThresh - this.para4Thresh
    member this.NoActionRate with get() = 1.0 - this.selfReflThresh

    member this.toString() =
        sprintf "Seed6ActionRates(Ortho1: %.2f, Ortho2: %.2f, Para1: %.2f, Para2: %.2f, Para3: %.2f, Para4: %.2f, SelfRefl: %.2f, NoAction: %.2f)" 
                this.Ortho1Rate this.Ortho2Rate this.Para1Rate this.Para2Rate this.Para3Rate this.Para4Rate this.SelfReflRate this.NoActionRate

    /// Assumes that floatPicker returns a float in the range [0.0, 1.0).
    member this.PickMode (floatPicker: unit -> float) : Seed6ActionMode =
        let r = floatPicker()
        if r < this.ortho1Thresh then
            Seed6ActionMode.Ortho1
        elif r < this.ortho2Thresh then
            Seed6ActionMode.Ortho2
        elif r < this.para1Thresh then
            Seed6ActionMode.Para1
        elif r < this.para2Thresh then
            Seed6ActionMode.Para2
        elif r < this.para3Thresh then
            Seed6ActionMode.Para3
        elif r < this.para4Thresh then
            Seed6ActionMode.Para4
        elif r < this.selfReflThresh then
            Seed6ActionMode.SelfRefl
        else
            Seed6ActionMode.NoAction


    member this.PickModeWithDefault  (floatPicker: unit -> float)  (defaultSeed6GenMode:Seed6GenMode): Seed6GenMode =
        let r = floatPicker()
        if r < this.ortho1Thresh then
            Seed6GenMode.Ortho1
        elif r < this.ortho2Thresh then
            Seed6GenMode.Ortho2
        elif r < this.para1Thresh then
            Seed6GenMode.Para1
        elif r < this.para2Thresh then
            Seed6GenMode.Para2
        elif r < this.para3Thresh then
            Seed6GenMode.Para3
        elif r < this.para4Thresh then
            Seed6GenMode.Para4
        elif r < this.selfReflThresh then
            Seed6GenMode.SelfRefl
        else
            defaultSeed6GenMode


    override this.Equals(obj) = 
        match obj with
        | :? Seed6ActionRates as other -> 
            this.ortho1Thresh = other.ortho1Thresh &&
            this.ortho2Thresh = other.ortho2Thresh &&
            this.para1Thresh = other.para1Thresh &&
            this.para2Thresh = other.para2Thresh &&
            this.para3Thresh = other.para3Thresh &&
            this.para4Thresh = other.para4Thresh &&
            this.selfReflThresh = other.selfReflThresh
        | _ -> false

    override this.GetHashCode() = 
        hash (this.ortho1Thresh, this.ortho2Thresh, this.para1Thresh, this.para2Thresh, 
              this.para3Thresh, this.para4Thresh, this.selfReflThresh)

    interface IEquatable<Seed6ActionRates> with
        member this.Equals(other) = 
            this.ortho1Thresh = other.ortho1Thresh &&
            this.ortho2Thresh = other.ortho2Thresh &&
            this.para1Thresh = other.para1Thresh &&
            this.para2Thresh = other.para2Thresh &&
            this.para3Thresh = other.para3Thresh &&
            this.para4Thresh = other.para4Thresh &&
            this.selfReflThresh = other.selfReflThresh
namespace GeneSort.Core
open System

type Seed6GenMode =
    | Ortho1
    | Ortho2
    | Para1
    | Para2
    | Para3
    | Para4
    | SelfRefl


[<Struct; CustomEquality; NoComparison>]
type Seed6GenRates = 
    private 
        { 
            ortho1Thresh: float
            ortho2Thresh: float
            para1Thresh: float
            para2Thresh: float
            para3Thresh: float
            para4Thresh: float
            selfReflThresh: float
        }

    static member create (ortho1Rate: float, ortho2Rate: float, para1Rate: float, para2Rate: float, 
                         para3Rate: float, para4Rate: float, selfReflRate: float) : Seed6GenRates =
        let sum = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate + para4Rate + selfReflRate
        let epsilon = 1e-10
        if ortho1Rate < 0.0 || ortho1Rate > 1.0 then failwith "ortho1Rate must be between 0 and 1"
        else if ortho2Rate < 0.0 || ortho2Rate > 1.0 then failwith "ortho2Rate must be between 0 and 1"
        else if para1Rate < 0.0 || para1Rate > 1.0 then failwith "para1Rate must be between 0 and 1"
        else if para2Rate < 0.0 || para2Rate > 1.0 then failwith "para2Rate must be between 0 and 1"
        else if para3Rate < 0.0 || para3Rate > 1.0 then failwith "para3Rate must be between 0 and 1"
        else if para4Rate < 0.0 || para4Rate > 1.0 then failwith "para4Rate must be between 0 and 1"
        else if selfReflRate < 0.0 || selfReflRate > 1.0 then failwith "selfReflRate must be between 0 and 1"
        else if abs (sum - 1.0) > epsilon then failwith "Sum of Seed6GenRates rates must equal 1.0"
        {
            ortho1Thresh = ortho1Rate
            ortho2Thresh = ortho1Rate + ortho2Rate
            para1Thresh = ortho1Rate + ortho2Rate + para1Rate
            para2Thresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate
            para3Thresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate
            para4Thresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate + para4Rate
            selfReflThresh = ortho1Rate + ortho2Rate + para1Rate + para2Rate + para3Rate + para4Rate + selfReflRate
        }

    static member createUniform () : Seed6GenRates =
        let rate = 1.0 / 7.0
        Seed6GenRates.create(rate, rate, rate, rate, rate, rate, rate)

    static member createBiased(field: string, bias: float) : Seed6GenRates =
        if bias < 0.0 || bias > 1.0 then failwith "bias must be between 0 and 1"
        let remaining = (1.0 - bias) / 6.0
        match field.ToLower() with
        | "ortho1" -> Seed6GenRates.create(bias, remaining, remaining, remaining, remaining, remaining, remaining)
        | "ortho2" -> Seed6GenRates.create(remaining, bias, remaining, remaining, remaining, remaining, remaining)
        | "para1" -> Seed6GenRates.create(remaining, remaining, bias, remaining, remaining, remaining, remaining)
        | "para2" -> Seed6GenRates.create(remaining, remaining, remaining, bias, remaining, remaining, remaining)
        | "para3" -> Seed6GenRates.create(remaining, remaining, remaining, remaining, bias, remaining, remaining)
        | "para4" -> Seed6GenRates.create(remaining, remaining, remaining, remaining, remaining, bias, remaining)
        | "selfrefl" -> Seed6GenRates.create(remaining, remaining, remaining, remaining, remaining, remaining, bias)
        | _ -> failwith "Invalid field name for createBiased"

    member this.Ortho1Rate with get() = this.ortho1Thresh
    member this.Ortho2Rate with get() = this.ortho2Thresh - this.ortho1Thresh
    member this.Para1Rate with get() = this.para1Thresh - this.ortho2Thresh
    member this.Para2Rate with get() = this.para2Thresh - this.para1Thresh
    member this.Para3Rate with get() = this.para3Thresh - this.para2Thresh
    member this.Para4Rate with get() = this.para4Thresh - this.para3Thresh
    member this.SelfReflRate with get() = this.selfReflThresh - this.para4Thresh

    member this.toString() =
        sprintf "Seed6GenRates(Ortho1: %.2f, Ortho2: %.2f, Para1: %.2f, Para2: %.2f, Para3: %.2f, Para4: %.2f, SelfRefl: %.2f)" 
                this.Ortho1Rate this.Ortho2Rate this.Para1Rate this.Para2Rate this.Para3Rate this.Para4Rate this.SelfReflRate

    /// Assumes that floatPicker returns a float in the range [0.0, 1.0).
    member this.PickMode (floatPicker: unit -> float) : Seed6GenMode =
        let r = floatPicker()
        if r < this.ortho1Thresh then Ortho1
        elif r < this.ortho2Thresh then Ortho2
        elif r < this.para1Thresh then Para1
        elif r < this.para2Thresh then Para2
        elif r < this.para3Thresh then Para3
        elif r < this.para4Thresh then Para4
        else SelfRefl

    override this.Equals(obj) = 
        match obj with
        | :? Seed6GenRates as other -> 
            this.ortho1Thresh = other.ortho1Thresh &&
            this.ortho2Thresh = other.ortho2Thresh &&
            this.para1Thresh = other.para1Thresh &&
            this.para2Thresh = other.para2Thresh &&
            this.para3Thresh = other.para3Thresh &&
            this.para4Thresh = other.para4Thresh &&
            this.selfReflThresh = other.selfReflThresh
        | _ -> false

    override this.GetHashCode() = 
        hash (this.ortho1Thresh, this.ortho2Thresh, this.para1Thresh, this.para2Thresh, 
              this.para3Thresh, this.para4Thresh, this.selfReflThresh)

    interface IEquatable<Seed6GenRates> with
        member this.Equals(other) = 
            this.ortho1Thresh = other.ortho1Thresh &&
            this.ortho2Thresh = other.ortho2Thresh &&
            this.para1Thresh = other.para1Thresh &&
            this.para2Thresh = other.para2Thresh &&
            this.para3Thresh = other.para3Thresh &&
            this.para4Thresh = other.para4Thresh &&
            this.selfReflThresh = other.selfReflThresh


module Seed6GenMode =

    let fromSeed6TwoOrbitType (seed6TwoOrbitType:TwoOrbitTripleType) : Seed6GenMode =
            match seed6TwoOrbitType with 
            | TwoOrbitTripleType.Ortho1 -> Seed6GenMode.Ortho1
            | TwoOrbitTripleType.Ortho2 -> Seed6GenMode.Ortho2
            | TwoOrbitTripleType.Para1 -> Seed6GenMode.Para1
            | TwoOrbitTripleType.Para2 -> Seed6GenMode.Para2
            | TwoOrbitTripleType.Para3 -> Seed6GenMode.Para3
            | TwoOrbitTripleType.Para4 -> Seed6GenMode.Para4
            | TwoOrbitTripleType.SelfRefl -> Seed6GenMode.SelfRefl
            

    let toSeed6TwoOrbitType (seed6GenMode:Seed6GenMode) : TwoOrbitTripleType =
            match seed6GenMode with 
            | Seed6GenMode.Ortho1 -> TwoOrbitTripleType.Ortho1
            | Seed6GenMode.Ortho2 -> TwoOrbitTripleType.Ortho2
            | Seed6GenMode.Para1 -> TwoOrbitTripleType.Para1
            | Seed6GenMode.Para2 -> TwoOrbitTripleType.Para2
            | Seed6GenMode.Para3 -> TwoOrbitTripleType.Para3
            | Seed6GenMode.Para4 -> TwoOrbitTripleType.Para4
            | Seed6GenMode.SelfRefl -> TwoOrbitTripleType.SelfRefl
namespace GeneSort.Core
open System

[<Struct; CustomEquality; NoComparison>]
type Seed6TransitionRates = 
    private 
        { 
            ortho1Rates: Seed6ActionRates
            ortho2Rates: Seed6ActionRates
            para1Rates: Seed6ActionRates
            para2Rates: Seed6ActionRates
            para3Rates: Seed6ActionRates
            para4Rates: Seed6ActionRates
            selfReflRates: Seed6ActionRates
        }

    static member create (ortho1Rates: Seed6ActionRates, ortho2Rates: Seed6ActionRates, para1Rates: Seed6ActionRates, 
                         para2Rates: Seed6ActionRates, para3Rates: Seed6ActionRates, para4Rates: Seed6ActionRates, 
                         selfReflRates: Seed6ActionRates) : Seed6TransitionRates =
        { 
            ortho1Rates = ortho1Rates
            ortho2Rates = ortho2Rates
            para1Rates = para1Rates
            para2Rates = para2Rates
            para3Rates = para3Rates
            para4Rates = para4Rates
            selfReflRates = selfReflRates
        }

    static member createUniform (amt: float) : Seed6TransitionRates =
        let rates = Seed6ActionRates.createUniform amt
        Seed6TransitionRates.create(rates, rates, rates, rates, rates, rates, rates)


    static member createBiased (seed6GenMode: Seed6GenMode) (baseAmt:float) (biasAmt:float) : Seed6TransitionRates =
        match seed6GenMode with
        | Seed6GenMode.Ortho1 -> 
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho1, baseAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)
        | Seed6GenMode.Ortho2 ->
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.Ortho2, baseAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)
        | Seed6GenMode.Para1 -> 
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt + biasAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.Para1, baseAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)
        | Seed6GenMode.Para2 -> 
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt + biasAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.Para2, baseAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)
        | Seed6GenMode.Para3 -> 
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt + biasAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.Para3, baseAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)
        | Seed6GenMode.Para4 -> 
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt + biasAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.Para4, baseAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)
        | Seed6GenMode.SelfRefl -> 
            let ortho1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt, biasAmt)
            let ortho2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt, biasAmt)
            let para1Rates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt, biasAmt)
            let para2Rates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt, biasAmt)
            let para3Rates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt, biasAmt)
            let para4Rates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt, biasAmt)
            let selfReflRates = Seed6ActionRates.createBiased(Seed6ActionMode.SelfRefl, baseAmt + biasAmt, biasAmt)
            Seed6TransitionRates.create(ortho1Rates, ortho2Rates, para1Rates, para2Rates, para3Rates, para4Rates, selfReflRates)


    member this.PickMode (floatPicker: unit -> float) (orbitType: TwoOrbitTripleType) : Seed6ActionMode =
        match orbitType with
        | TwoOrbitTripleType.Ortho1 -> this.ortho1Rates.PickMode floatPicker
        | TwoOrbitTripleType.Ortho2 -> this.ortho2Rates.PickMode floatPicker
        | TwoOrbitTripleType.Para1 -> this.para1Rates.PickMode floatPicker
        | TwoOrbitTripleType.Para2 -> this.para2Rates.PickMode floatPicker
        | TwoOrbitTripleType.Para3 -> this.para3Rates.PickMode floatPicker
        | TwoOrbitTripleType.Para4 -> this.para4Rates.PickMode floatPicker
        | TwoOrbitTripleType.SelfRefl -> this.selfReflRates.PickMode floatPicker


    member this.TransitionMode (floatPicker: unit -> float) (seed6GenMode: Seed6GenMode) : Seed6GenMode =
        match seed6GenMode with
        | Seed6GenMode.Ortho1 -> this.ortho1Rates.PickModeWithDefault floatPicker seed6GenMode
        | Seed6GenMode.Ortho2 -> this.ortho2Rates.PickModeWithDefault floatPicker seed6GenMode
        | Seed6GenMode.Para1 -> this.para1Rates.PickModeWithDefault floatPicker seed6GenMode
        | Seed6GenMode.Para2 -> this.para2Rates.PickModeWithDefault floatPicker seed6GenMode
        | Seed6GenMode.Para3 -> this.para3Rates.PickModeWithDefault floatPicker seed6GenMode
        | Seed6GenMode.Para4 -> this.para4Rates.PickModeWithDefault floatPicker seed6GenMode
        | Seed6GenMode.SelfRefl -> this.selfReflRates.PickModeWithDefault floatPicker seed6GenMode


    member this.toString() =
        sprintf "Seed6TransitionRates(Ortho1: %s, Ortho2: %s, Para1: %s, Para2: %s, Para3: %s, Para4: %s, SelfRefl: %s)"
                (this.ortho1Rates.toString())
                (this.ortho2Rates.toString())
                (this.para1Rates.toString())
                (this.para2Rates.toString())
                (this.para3Rates.toString())
                (this.para4Rates.toString())
                (this.selfReflRates.toString())


    member this.Ortho1Rates with get() = this.ortho1Rates
    member this.Ortho2Rates with get() = this.ortho2Rates
    member this.Para1Rates with get() = this.para1Rates
    member this.Para2Rates with get() = this.para2Rates
    member this.Para3Rates with get() = this.para3Rates
    member this.Para4Rates with get() = this.para4Rates
    member this.SelfReflRates with get() = this.selfReflRates


    override this.Equals(obj) = 
        match obj with
        | :? Seed6TransitionRates as other -> 
            this.ortho1Rates.Equals(other.ortho1Rates) &&
            this.ortho2Rates.Equals(other.ortho2Rates) &&
            this.para1Rates.Equals(other.para1Rates) &&
            this.para2Rates.Equals(other.para2Rates) &&
            this.para3Rates.Equals(other.para3Rates) &&
            this.para4Rates.Equals(other.para4Rates) &&
            this.selfReflRates.Equals(other.selfReflRates)
        | _ -> false

    override this.GetHashCode() = 
        hash (this.ortho1Rates, this.ortho2Rates, this.para1Rates, this.para2Rates, 
              this.para3Rates, this.para4Rates, this.selfReflRates)

    interface IEquatable<Seed6TransitionRates> with
        member this.Equals(other) = 
            this.ortho1Rates.Equals(other.ortho1Rates) &&
            this.ortho2Rates.Equals(other.ortho2Rates) &&
            this.para1Rates.Equals(other.para1Rates) &&
            this.para2Rates.Equals(other.para2Rates) &&
            this.para3Rates.Equals(other.para3Rates) &&
            this.para4Rates.Equals(other.para4Rates) &&
            this.selfReflRates.Equals(other.selfReflRates)
namespace GeneSort.Core


type Uf4GenRates =
    {
        order:int;
        seedOpsGenRates: OpsGenRates;
        opsGenRatesList: OpsGenRates list
    }

module Uf4GenRates =

    let makeUniform (order:int) : Uf4GenRates =

        if order < 4 then
            failwith "TwoOrbitUfStep order must be at least 4"
        if order % 2 <> 0 then
            failwith "TwoOrbitUfStep order must be even"
        let genRatesListLength = MathUtils.exactLog2 (order / 4)
        let genRatesList = List.init genRatesListLength (fun _ -> OpsGenRates.createUniform())
        { 
            Uf4GenRates.order = order;
            seedOpsGenRates = OpsGenRates.createUniform();
            opsGenRatesList = genRatesList; 
        }


    let biasTowards (order:int) (opsGenMode:OpsGenMode) (biasAmt:float) 
                : Uf4GenRates =

        let genRatesBaseListLength = MathUtils.exactLog2 (order / 4)

        if (genRatesBaseListLength = 0)  then
            {
                Uf4GenRates.order = order;
                seedOpsGenRates = OpsGenRates.createUniform();
                opsGenRatesList = []
            }
        else
            let genRatesBaseList =
                if (genRatesBaseListLength = 1) 
                then []
                else List.init (genRatesBaseListLength - 1) (fun _ -> OpsGenRates.createUniform())

            let lastGenRates = OpsGenRates.createBiased(opsGenMode, biasAmt)

            let genRatesListWithLast = genRatesBaseList @ [lastGenRates]
            { 
                Uf4GenRates.order = order;
                seedOpsGenRates = OpsGenRates.createUniform();
                opsGenRatesList = genRatesListWithLast; 
            }
namespace GeneSort.Core
open System

[<Struct; CustomEquality; NoComparison>]
type Uf4GenRatesArray =
    private 
        { rates: Uf4GenRates array }

    static member create (rates: Uf4GenRates array) : Uf4GenRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        if Array.exists (fun r -> r.order < 4 || r.order % 2 <> 0) rates then
            failwith "All Uf4GenRates orders must be at least 4 and even"
        let listLengths = rates |> Array.map (fun r -> r.opsGenRatesList.Length)
        if Array.distinct listLengths |> Array.length > 1 then
            failwith "All Uf4GenRates must have the same opsGenRatesList length"
        { rates = rates }

    member this.Length = this.rates.Length
    member this.Item(index: int) = this.rates.[index]
    member this.RatesArray = this.rates

    member this.toString() =
        String.Join(", ", Array.map (
            fun r -> sprintf "Uf4GenRates(order=%d, seed=%s, listLength=%d)" 
                        r.order (r.seedOpsGenRates.toString()) r.opsGenRatesList.Length) this.rates)

    override this.Equals(obj) =
        match obj with
        | :? Uf4GenRatesArray as other ->
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seedOpsGenRates.Equals(b.seedOpsGenRates) && 
                    a.opsGenRatesList = b.opsGenRatesList) this.rates other.rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.rates do
            hash <- hash * 23 + rate.order.GetHashCode()
            hash <- hash * 23 + rate.seedOpsGenRates.GetHashCode()
            hash <- hash * 23 + rate.opsGenRatesList.GetHashCode()
        hash

    interface IEquatable<Uf4GenRatesArray> with
        member this.Equals(other) =
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seedOpsGenRates.Equals(b.seedOpsGenRates) && 
                    a.opsGenRatesList = b.opsGenRatesList) this.rates other.rates

module Uf4GenRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    let createLinearVariation (length: int) (order: int) (startRates: Uf4GenRates) (endRates: Uf4GenRates) : Uf4GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if startRates.order <> order || endRates.order <> order then failwith "Start and end rates must have the same order"
        if startRates.opsGenRatesList.Length <> endRates.opsGenRatesList.Length then
            failwith "Start and end rates must have the same opsGenRatesList length"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let seed = OpsGenRates.create(
                    startRates.seedOpsGenRates.OrthoRate + t * (endRates.seedOpsGenRates.OrthoRate - startRates.seedOpsGenRates.OrthoRate),
                    startRates.seedOpsGenRates.ParaRate + t * (endRates.seedOpsGenRates.ParaRate - startRates.seedOpsGenRates.ParaRate),
                    startRates.seedOpsGenRates.SelfReflRate + t * (endRates.seedOpsGenRates.SelfReflRate - startRates.seedOpsGenRates.SelfReflRate))
                let listLength = MathUtils.exactLog2 (order / 4)
                let opsGenRatesList =
                    List.init listLength (fun j ->
                        let startList = startRates.opsGenRatesList
                        let endList = endRates.opsGenRatesList
                        if j >= startList.Length || j >= endList.Length then OpsGenRates.createUniform()
                        else
                            OpsGenRates.create(
                                startList.[j].OrthoRate + t * (endList.[j].OrthoRate - startList.[j].OrthoRate),
                                startList.[j].ParaRate + t * (endList.[j].ParaRate - startList.[j].ParaRate),
                                startList.[j].SelfReflRate + t * (endList.[j].SelfReflRate - startList.[j].SelfReflRate)))
                { Uf4GenRates.order = order; seedOpsGenRates = seed; opsGenRatesList = opsGenRatesList })
        Uf4GenRatesArray.create rates

    let createSinusoidalVariation (length: int) (order: int) (baseRates: Uf4GenRates) (amplitudes: Uf4GenRates) (frequency: float) : Uf4GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if baseRates.order <> order || amplitudes.order <> order then failwith "Base and amplitudes must have the same order"
        if baseRates.opsGenRatesList.Length <> amplitudes.opsGenRatesList.Length then
            failwith "Base and amplitudes must have the same opsGenRatesList length"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let seed = OpsGenRates.create(
                    clamp (baseRates.seedOpsGenRates.OrthoRate + amplitudes.seedOpsGenRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                    clamp (baseRates.seedOpsGenRates.ParaRate + amplitudes.seedOpsGenRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                    clamp (baseRates.seedOpsGenRates.SelfReflRate + amplitudes.seedOpsGenRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0)
                let listLength = MathUtils.exactLog2 (order / 4)
                let opsGenRatesList =
                    List.init listLength (fun j ->
                        let baseList = baseRates.opsGenRatesList
                        let ampList = amplitudes.opsGenRatesList
                        if j >= baseList.Length || j >= ampList.Length then OpsGenRates.createUniform()
                        else
                            OpsGenRates.create(
                                clamp (baseList.[j].OrthoRate + ampList.[j].OrthoRate * Math.Sin(t)) 0.0 1.0,
                                clamp (baseList.[j].ParaRate + ampList.[j].ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                clamp (baseList.[j].SelfReflRate + ampList.[j].SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0))
                { Uf4GenRates.order = order; seedOpsGenRates = seed; opsGenRatesList = opsGenRatesList })
        Uf4GenRatesArray.create rates

    let createGaussianHotSpot (length: int) (order: int) (baseRates: Uf4GenRates) (hotSpotIndex: int) (hotSpotRates: Uf4GenRates) (sigma: float) : Uf4GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if baseRates.opsGenRatesList.Length <> hotSpotRates.opsGenRatesList.Length then
            failwith "Base and hotspot rates must have the same opsGenRatesList length"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let seed = OpsGenRates.create(
                    baseRates.seedOpsGenRates.OrthoRate + (hotSpotRates.seedOpsGenRates.OrthoRate - baseRates.seedOpsGenRates.OrthoRate) * weight,
                    baseRates.seedOpsGenRates.ParaRate + (hotSpotRates.seedOpsGenRates.ParaRate - baseRates.seedOpsGenRates.ParaRate) * weight,
                    baseRates.seedOpsGenRates.SelfReflRate + (hotSpotRates.seedOpsGenRates.SelfReflRate - baseRates.seedOpsGenRates.SelfReflRate) * weight)
                let listLength = MathUtils.exactLog2 (order / 4)
                let opsGenRatesList =
                    List.init listLength (fun j ->
                        let baseList = baseRates.opsGenRatesList
                        let hotSpotList = hotSpotRates.opsGenRatesList
                        if j >= baseList.Length || j >= hotSpotList.Length then OpsGenRates.createUniform()
                        else
                            OpsGenRates.create(
                                baseList.[j].OrthoRate + (hotSpotList.[j].OrthoRate - baseList.[j].OrthoRate) * weight,
                                baseList.[j].ParaRate + (hotSpotList.[j].ParaRate - baseList.[j].ParaRate) * weight,
                                baseList.[j].SelfReflRate + (hotSpotList.[j].SelfReflRate - baseList.[j].SelfReflRate) * weight))
                { Uf4GenRates.order = order; seedOpsGenRates = seed; opsGenRatesList = opsGenRatesList })
        Uf4GenRatesArray.create rates

    let createStepHotSpot (length: int) (order: int) (baseRates: Uf4GenRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: Uf4GenRates) : Uf4GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if baseRates.opsGenRatesList.Length <> hotSpotRates.opsGenRatesList.Length then
            failwith "Base and hotspot rates must have the same opsGenRatesList length"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                { Uf4GenRates.order = order; 
                  seedOpsGenRates = OpsGenRates.create(rates.seedOpsGenRates.OrthoRate, rates.seedOpsGenRates.ParaRate, rates.seedOpsGenRates.SelfReflRate);
                  opsGenRatesList = rates.opsGenRatesList })
        Uf4GenRatesArray.create rates

    let createNewItems<'a> 
        (uf4GenRatesArray: Uf4GenRatesArray)
        (itemChooser: Uf4GenRates -> 'a)
            : 'a[] =
        Array.init uf4GenRatesArray.Length (fun i ->
            itemChooser (uf4GenRatesArray.Item(i)))
namespace GeneSort.Core


type Uf4MutationRates =
    {
        order:int;
        seedOpsTransitionRates: OpsTransitionRates;
        twoOrbitPairOpsTransitionRates: OpsTransitionRates list
    }

module Uf4MutationRates =

    let makeUniform (order:int) (perm_RsMutationRate:float) (twoOrbitMutationRate:float) =
        let mutRatesListLength = MathUtils.exactLog2 (order / 4)
        let mutRatesList = List.init mutRatesListLength (fun _ -> OpsTransitionRates.createUniform(twoOrbitMutationRate))
        { Uf4MutationRates.order = order;
          seedOpsTransitionRates = OpsTransitionRates.createUniform(perm_RsMutationRate);
          twoOrbitPairOpsTransitionRates = mutRatesList; }

    let biasTowards (order:int) (perm_RsMutationRate:float) (twoOrbitType:TwoOrbitType)  (baseAmt:float) (biasAmt:float) =
        let mutRatesBaseListLength = MathUtils.exactLog2 (order / 4) - 1
        let mutRatesBaseList = List.init mutRatesBaseListLength (fun _ -> OpsTransitionRates.createUniform(baseAmt))
        let lastGenRates = OpsTransitionRates.createBiased twoOrbitType baseAmt biasAmt
        let genRatesListWithLast = mutRatesBaseList @ [lastGenRates]
        { Uf4MutationRates.order = order;
          seedOpsTransitionRates = OpsTransitionRates.createUniform(perm_RsMutationRate);
          twoOrbitPairOpsTransitionRates = genRatesListWithLast; }
namespace GeneSort.Core
open System

[<Struct; CustomEquality; NoComparison>]
type Uf4MutationRatesArray =
    private 
        { rates: Uf4MutationRates array }

    static member create (rates: Uf4MutationRates array) : Uf4MutationRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        if Array.exists (fun r -> r.order < 4 || r.order % 2 <> 0) rates then
            failwith "All Uf4MutationRates orders must be at least 4 and even"
        { rates = rates }

    member this.Length = this.rates.Length
    member this.Item(index: int) = this.rates.[index]
    member this.RatesArray = this.rates

    member this.toString() =
        String.Join(", ", Array.map (
            fun r -> sprintf "Uf4MutationRates(order=%d, seed=%s, listLength=%d)" 
                        r.order (r.seedOpsTransitionRates.toString()) r.twoOrbitPairOpsTransitionRates.Length) this.rates)

    override this.Equals(obj) =
        match obj with
        | :? Uf4MutationRatesArray as other ->
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seedOpsTransitionRates.Equals(b.seedOpsTransitionRates) && 
                    a.twoOrbitPairOpsTransitionRates = b.twoOrbitPairOpsTransitionRates) this.rates other.rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.rates do
            hash <- hash * 23 + rate.order.GetHashCode()
            hash <- hash * 23 + rate.seedOpsTransitionRates.GetHashCode()
            hash <- hash * 23 + rate.twoOrbitPairOpsTransitionRates.GetHashCode()
        hash

    interface IEquatable<Uf4MutationRatesArray> with
        member this.Equals(other) =
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seedOpsTransitionRates.Equals(b.seedOpsTransitionRates) && 
                    a.twoOrbitPairOpsTransitionRates = b.twoOrbitPairOpsTransitionRates) this.rates other.rates

module Uf4MutationRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    let createLinearVariation (length: int) (order: int) (startRates: Uf4MutationRates) (endRates: Uf4MutationRates) : Uf4MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if startRates.order <> order || endRates.order <> order then failwith "Start and end rates must have the same order"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let seed = OpsTransitionRates.create(
                    OpsActionRates.create(
                        startRates.seedOpsTransitionRates.OrthoRates.OrthoRate + t * (endRates.seedOpsTransitionRates.OrthoRates.OrthoRate - startRates.seedOpsTransitionRates.OrthoRates.OrthoRate),
                        startRates.seedOpsTransitionRates.OrthoRates.ParaRate + t * (endRates.seedOpsTransitionRates.OrthoRates.ParaRate - startRates.seedOpsTransitionRates.OrthoRates.ParaRate),
                        startRates.seedOpsTransitionRates.OrthoRates.SelfReflRate + t * (endRates.seedOpsTransitionRates.OrthoRates.SelfReflRate - startRates.seedOpsTransitionRates.OrthoRates.SelfReflRate)),
                    OpsActionRates.create(
                        startRates.seedOpsTransitionRates.ParaRates.OrthoRate + t * (endRates.seedOpsTransitionRates.ParaRates.OrthoRate - startRates.seedOpsTransitionRates.ParaRates.OrthoRate),
                        startRates.seedOpsTransitionRates.ParaRates.ParaRate + t * (endRates.seedOpsTransitionRates.ParaRates.ParaRate - startRates.seedOpsTransitionRates.ParaRates.ParaRate),
                        startRates.seedOpsTransitionRates.ParaRates.SelfReflRate + t * (endRates.seedOpsTransitionRates.ParaRates.SelfReflRate - startRates.seedOpsTransitionRates.ParaRates.SelfReflRate)),
                    OpsActionRates.create(
                        startRates.seedOpsTransitionRates.SelfReflRates.OrthoRate + t * (endRates.seedOpsTransitionRates.SelfReflRates.OrthoRate - startRates.seedOpsTransitionRates.SelfReflRates.OrthoRate),
                        startRates.seedOpsTransitionRates.SelfReflRates.ParaRate + t * (endRates.seedOpsTransitionRates.SelfReflRates.ParaRate - startRates.seedOpsTransitionRates.SelfReflRates.ParaRate),
                        startRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate + t * (endRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate - startRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate)))
                let listLength = MathUtils.exactLog2 (order / 4)
                let opsTransitionRatesList =
                    List.init listLength (fun j ->
                        let startList = startRates.twoOrbitPairOpsTransitionRates
                        let endList = endRates.twoOrbitPairOpsTransitionRates
                        if j >= startList.Length || j >= endList.Length then OpsTransitionRates.createUniform(0.0)
                        else
                            OpsTransitionRates.create(
                                OpsActionRates.create(
                                    startList.[j].OrthoRates.OrthoRate + t * (endList.[j].OrthoRates.OrthoRate - startList.[j].OrthoRates.OrthoRate),
                                    startList.[j].OrthoRates.ParaRate + t * (endList.[j].OrthoRates.ParaRate - startList.[j].OrthoRates.ParaRate),
                                    startList.[j].OrthoRates.SelfReflRate + t * (endList.[j].OrthoRates.SelfReflRate - startList.[j].OrthoRates.SelfReflRate)),
                                OpsActionRates.create(
                                    startList.[j].ParaRates.OrthoRate + t * (endList.[j].ParaRates.OrthoRate - startList.[j].ParaRates.OrthoRate),
                                    startList.[j].ParaRates.ParaRate + t * (endList.[j].ParaRates.ParaRate - startList.[j].ParaRates.ParaRate),
                                    startList.[j].ParaRates.SelfReflRate + t * (endList.[j].ParaRates.SelfReflRate - startList.[j].ParaRates.SelfReflRate)),
                                OpsActionRates.create(
                                    startList.[j].SelfReflRates.OrthoRate + t * (endList.[j].SelfReflRates.OrthoRate - startList.[j].SelfReflRates.OrthoRate),
                                    startList.[j].SelfReflRates.ParaRate + t * (endList.[j].SelfReflRates.ParaRate - startList.[j].SelfReflRates.ParaRate),
                                    startList.[j].SelfReflRates.SelfReflRate + t * (endList.[j].SelfReflRates.SelfReflRate - startList.[j].SelfReflRates.SelfReflRate))))
                { Uf4MutationRates.order = order; seedOpsTransitionRates = seed; twoOrbitPairOpsTransitionRates = opsTransitionRatesList })
        Uf4MutationRatesArray.create rates

    let createSinusoidalVariation (length: int) (order: int) (baseRates: Uf4MutationRates) (amplitudes: Uf4MutationRates) (frequency: float) : Uf4MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if baseRates.order <> order || amplitudes.order <> order then failwith "Base and amplitudes must have the same order"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let seed = OpsTransitionRates.create(
                    OpsActionRates.create(
                        clamp (baseRates.seedOpsTransitionRates.OrthoRates.OrthoRate + amplitudes.seedOpsTransitionRates.OrthoRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seedOpsTransitionRates.OrthoRates.ParaRate + amplitudes.seedOpsTransitionRates.OrthoRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                        clamp (baseRates.seedOpsTransitionRates.OrthoRates.SelfReflRate + amplitudes.seedOpsTransitionRates.OrthoRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0),
                    OpsActionRates.create(
                        clamp (baseRates.seedOpsTransitionRates.ParaRates.OrthoRate + amplitudes.seedOpsTransitionRates.ParaRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seedOpsTransitionRates.ParaRates.ParaRate + amplitudes.seedOpsTransitionRates.ParaRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                        clamp (baseRates.seedOpsTransitionRates.ParaRates.SelfReflRate + amplitudes.seedOpsTransitionRates.ParaRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0),
                    OpsActionRates.create(
                        clamp (baseRates.seedOpsTransitionRates.SelfReflRates.OrthoRate + amplitudes.seedOpsTransitionRates.SelfReflRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seedOpsTransitionRates.SelfReflRates.ParaRate + amplitudes.seedOpsTransitionRates.SelfReflRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                        clamp (baseRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate + amplitudes.seedOpsTransitionRates.SelfReflRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0))
                let listLength = MathUtils.exactLog2 (order / 4)
                let opsTransitionRatesList =
                    List.init listLength (fun j ->
                        let baseList = baseRates.twoOrbitPairOpsTransitionRates
                        let ampList = amplitudes.twoOrbitPairOpsTransitionRates
                        if j >= baseList.Length || j >= ampList.Length then OpsTransitionRates.createUniform(0.0)
                        else
                            OpsTransitionRates.create(
                                OpsActionRates.create(
                                    clamp (baseList.[j].OrthoRates.OrthoRate + ampList.[j].OrthoRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                                    clamp (baseList.[j].OrthoRates.ParaRate + ampList.[j].OrthoRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                    clamp (baseList.[j].OrthoRates.SelfReflRate + ampList.[j].OrthoRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0),
                                OpsActionRates.create(
                                    clamp (baseList.[j].ParaRates.OrthoRate + ampList.[j].ParaRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                                    clamp (baseList.[j].ParaRates.ParaRate + ampList.[j].ParaRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                    clamp (baseList.[j].ParaRates.SelfReflRate + ampList.[j].ParaRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0),
                                OpsActionRates.create(
                                    clamp (baseList.[j].SelfReflRates.OrthoRate + ampList.[j].SelfReflRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                                    clamp (baseList.[j].SelfReflRates.ParaRate + ampList.[j].SelfReflRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                    clamp (baseList.[j].SelfReflRates.SelfReflRate + ampList.[j].SelfReflRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0)))
                { Uf4MutationRates.order = order; seedOpsTransitionRates = seed; twoOrbitPairOpsTransitionRates = opsTransitionRatesList })
        Uf4MutationRatesArray.create rates

    let createGaussianHotSpot (length: int) (order: int) (baseRates: Uf4MutationRates) (hotSpotIndex: int) (hotSpotRates: Uf4MutationRates) (sigma: float) : Uf4MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let seed = OpsTransitionRates.create(
                    OpsActionRates.create(
                        baseRates.seedOpsTransitionRates.OrthoRates.OrthoRate + (hotSpotRates.seedOpsTransitionRates.OrthoRates.OrthoRate - baseRates.seedOpsTransitionRates.OrthoRates.OrthoRate) * weight,
                        baseRates.seedOpsTransitionRates.OrthoRates.ParaRate + (hotSpotRates.seedOpsTransitionRates.OrthoRates.ParaRate - baseRates.seedOpsTransitionRates.OrthoRates.ParaRate) * weight,
                        baseRates.seedOpsTransitionRates.OrthoRates.SelfReflRate + (hotSpotRates.seedOpsTransitionRates.OrthoRates.SelfReflRate - baseRates.seedOpsTransitionRates.OrthoRates.SelfReflRate) * weight),
                    OpsActionRates.create(
                        baseRates.seedOpsTransitionRates.ParaRates.OrthoRate + (hotSpotRates.seedOpsTransitionRates.ParaRates.OrthoRate - baseRates.seedOpsTransitionRates.ParaRates.OrthoRate) * weight,
                        baseRates.seedOpsTransitionRates.ParaRates.ParaRate + (hotSpotRates.seedOpsTransitionRates.ParaRates.ParaRate - baseRates.seedOpsTransitionRates.ParaRates.ParaRate) * weight,
                        baseRates.seedOpsTransitionRates.ParaRates.SelfReflRate + (hotSpotRates.seedOpsTransitionRates.ParaRates.SelfReflRate - baseRates.seedOpsTransitionRates.ParaRates.SelfReflRate) * weight),
                    OpsActionRates.create(
                        baseRates.seedOpsTransitionRates.SelfReflRates.OrthoRate + (hotSpotRates.seedOpsTransitionRates.SelfReflRates.OrthoRate - baseRates.seedOpsTransitionRates.SelfReflRates.OrthoRate) * weight,
                        baseRates.seedOpsTransitionRates.SelfReflRates.ParaRate + (hotSpotRates.seedOpsTransitionRates.SelfReflRates.ParaRate - baseRates.seedOpsTransitionRates.SelfReflRates.ParaRate) * weight,
                        baseRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate + (hotSpotRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate - baseRates.seedOpsTransitionRates.SelfReflRates.SelfReflRate) * weight))
                let listLength = MathUtils.exactLog2 (order / 4)
                let opsTransitionRatesList =
                    List.init listLength (fun j ->
                        let baseList = baseRates.twoOrbitPairOpsTransitionRates
                        let hotSpotList = hotSpotRates.twoOrbitPairOpsTransitionRates
                        if j >= baseList.Length || j >= hotSpotList.Length then OpsTransitionRates.createUniform(0.0)
                        else
                            OpsTransitionRates.create(
                                OpsActionRates.create(
                                    baseList.[j].OrthoRates.OrthoRate + (hotSpotList.[j].OrthoRates.OrthoRate - baseList.[j].OrthoRates.OrthoRate) * weight,
                                    baseList.[j].OrthoRates.ParaRate + (hotSpotList.[j].OrthoRates.ParaRate - baseList.[j].OrthoRates.ParaRate) * weight,
                                    baseList.[j].OrthoRates.SelfReflRate + (hotSpotList.[j].OrthoRates.SelfReflRate - baseList.[j].OrthoRates.SelfReflRate) * weight),
                                OpsActionRates.create(
                                    baseList.[j].ParaRates.OrthoRate + (hotSpotList.[j].ParaRates.OrthoRate - baseList.[j].ParaRates.OrthoRate) * weight,
                                    baseList.[j].ParaRates.ParaRate + (hotSpotList.[j].ParaRates.ParaRate - baseList.[j].ParaRates.ParaRate) * weight,
                                    baseList.[j].ParaRates.SelfReflRate + (hotSpotList.[j].ParaRates.SelfReflRate - baseList.[j].ParaRates.SelfReflRate) * weight),
                                OpsActionRates.create(
                                    baseList.[j].SelfReflRates.OrthoRate + (hotSpotList.[j].SelfReflRates.OrthoRate - baseList.[j].SelfReflRates.OrthoRate) * weight,
                                    baseList.[j].SelfReflRates.ParaRate + (hotSpotList.[j].SelfReflRates.ParaRate - baseList.[j].SelfReflRates.ParaRate) * weight,
                                    baseList.[j].SelfReflRates.SelfReflRate + (hotSpotList.[j].SelfReflRates.SelfReflRate - baseList.[j].SelfReflRates.SelfReflRate) * weight)))
                { Uf4MutationRates.order = order; seedOpsTransitionRates = seed; twoOrbitPairOpsTransitionRates = opsTransitionRatesList })
        Uf4MutationRatesArray.create rates

    let createStepHotSpot (length: int) (order: int) (baseRates: Uf4MutationRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: Uf4MutationRates) : Uf4MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 4 || order % 2 <> 0 then failwith "Order must be at least 4 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                { Uf4MutationRates.order = order; 
                  seedOpsTransitionRates = OpsTransitionRates.create(
                      OpsActionRates.create(rates.seedOpsTransitionRates.OrthoRates.OrthoRate, rates.seedOpsTransitionRates.OrthoRates.ParaRate, rates.seedOpsTransitionRates.OrthoRates.SelfReflRate),
                      OpsActionRates.create(rates.seedOpsTransitionRates.ParaRates.OrthoRate, rates.seedOpsTransitionRates.ParaRates.ParaRate, rates.seedOpsTransitionRates.ParaRates.SelfReflRate),
                      OpsActionRates.create(rates.seedOpsTransitionRates.SelfReflRates.OrthoRate, rates.seedOpsTransitionRates.SelfReflRates.ParaRate, rates.seedOpsTransitionRates.SelfReflRates.SelfReflRate));
                  twoOrbitPairOpsTransitionRates = rates.twoOrbitPairOpsTransitionRates })
        Uf4MutationRatesArray.create rates

    let mutate<'a> 
        (uf4MutationRatesArray: Uf4MutationRatesArray) 
        (orthoMutator: 'a -> 'a) 
        (paraMutator: 'a -> 'a) 
        (selfSymMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (twoOrbitType: TwoOrbitType) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if uf4MutationRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
    
        Array.init arrayToMutate.Length (fun i ->
            let rate = uf4MutationRatesArray.Item(i)
            match rate.seedOpsTransitionRates.PickMode floatPicker twoOrbitType with
            | OpsActionMode.Ortho -> orthoMutator arrayToMutate.[i]
            | OpsActionMode.Para -> paraMutator arrayToMutate.[i]
            | OpsActionMode.SelfRefl -> selfSymMutator arrayToMutate.[i]
            | OpsActionMode.NoAction -> arrayToMutate.[i])

    let createNewItems<'a> 
        (uf4MutationRatesArray: Uf4MutationRatesArray)
        (itemChooser: Uf4MutationRates -> 'a)
            : 'a[] =
        Array.init uf4MutationRatesArray.Length (fun i ->
            itemChooser (uf4MutationRatesArray.Item(i)))
namespace GeneSort.Core


type Uf6GenRates =
    {
        order:int;
        seedGenRatesUf6: Seed6GenRates;
        opsGenRatesList: OpsGenRates list
    }

module Uf6GenRates =

    let makeUniform (order:int) =
        let genRatesListLength = MathUtils.exactLog2 (order / 6)
        let genRatesList = List.init genRatesListLength (fun _  -> OpsGenRates.createUniform())
        { Uf6GenRates.order = order;
          seedGenRatesUf6 = Seed6GenRates.createUniform();
          opsGenRatesList = genRatesList; }
           
namespace GeneSort.Core
open System
open MathUtils

[<Struct; CustomEquality; NoComparison>]
type Uf6GenRatesArray =
    private 
        { rates: Uf6GenRates array }

    static member create (rates: Uf6GenRates array) : Uf6GenRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        if Array.exists (fun r -> r.order < 6 || r.order % 2 <> 0) rates then
            failwith "All Uf6GenRates orders must be at least 6 and even"
        { rates = rates }

    member this.Length = this.rates.Length
    member this.Item(index: int) = this.rates.[index]
    member this.RatesArray = this.rates

    member this.toString() =
        String.Join(", ", Array.map (
            fun r -> sprintf "Uf6GenRates(order=%d, seed=%s, listLength=%d)" 
                        r.order (r.seedGenRatesUf6.toString()) r.opsGenRatesList.Length) this.rates)

    override this.Equals(obj) =
        match obj with
        | :? Uf6GenRatesArray as other ->
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seedGenRatesUf6.Equals(b.seedGenRatesUf6) && 
                    a.opsGenRatesList = b.opsGenRatesList) this.rates other.rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.rates do
            hash <- hash * 23 + rate.order.GetHashCode()
            hash <- hash * 23 + rate.seedGenRatesUf6.GetHashCode()
            hash <- hash * 23 + rate.opsGenRatesList.GetHashCode()
        hash

    interface IEquatable<Uf6GenRatesArray> with
        member this.Equals(other) =
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seedGenRatesUf6.Equals(b.seedGenRatesUf6) && 
                    a.opsGenRatesList = b.opsGenRatesList) this.rates other.rates

module Uf6GenRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    let createLinearVariation (length: int) (order: int) (startRates: Uf6GenRates) (endRates: Uf6GenRates) : Uf6GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if startRates.order <> order || endRates.order <> order then failwith "Start and end rates must have the same order"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let seed = Seed6GenRates.create(
                    startRates.seedGenRatesUf6.Ortho1Rate + t * (endRates.seedGenRatesUf6.Ortho1Rate - startRates.seedGenRatesUf6.Ortho1Rate),
                    startRates.seedGenRatesUf6.Ortho2Rate + t * (endRates.seedGenRatesUf6.Ortho2Rate - startRates.seedGenRatesUf6.Ortho2Rate),
                    startRates.seedGenRatesUf6.Para1Rate + t * (endRates.seedGenRatesUf6.Para1Rate - startRates.seedGenRatesUf6.Para1Rate),
                    startRates.seedGenRatesUf6.Para2Rate + t * (endRates.seedGenRatesUf6.Para2Rate - startRates.seedGenRatesUf6.Para2Rate),
                    startRates.seedGenRatesUf6.Para3Rate + t * (endRates.seedGenRatesUf6.Para3Rate - startRates.seedGenRatesUf6.Para3Rate),
                    startRates.seedGenRatesUf6.Para4Rate + t * (endRates.seedGenRatesUf6.Para4Rate - startRates.seedGenRatesUf6.Para4Rate),
                    startRates.seedGenRatesUf6.SelfReflRate + t * (endRates.seedGenRatesUf6.SelfReflRate - startRates.seedGenRatesUf6.SelfReflRate))
                let listLength = exactLog2 (order / 6)
                let opsGenRatesList =
                    List.init listLength (fun j ->
                        let startList = startRates.opsGenRatesList
                        let endList = endRates.opsGenRatesList
                        if j >= startList.Length || j >= endList.Length then OpsGenRates.createUniform()
                        else
                            OpsGenRates.create(
                                startList.[j].OrthoRate + t * (endList.[j].OrthoRate - startList.[j].OrthoRate),
                                startList.[j].ParaRate + t * (endList.[j].ParaRate - startList.[j].ParaRate),
                                startList.[j].SelfReflRate + t * (endList.[j].SelfReflRate - startList.[j].SelfReflRate)))
                { Uf6GenRates.order = order; seedGenRatesUf6 = seed; opsGenRatesList = opsGenRatesList })
        Uf6GenRatesArray.create rates


    let createSinusoidalVariation (length: int) (order: int) (baseRates: Uf6GenRates) (amplitudes: Uf6GenRates) (frequency: float) : Uf6GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if baseRates.order <> order || amplitudes.order <> order then failwith "Base and amplitudes must have the same order"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let phaseShift = 2.0 * Math.PI / 7.0
                let seed = Seed6GenRates.create(
                    clamp (baseRates.seedGenRatesUf6.Ortho1Rate + amplitudes.seedGenRatesUf6.Ortho1Rate * Math.Sin(t)) 0.0 1.0,
                    clamp (baseRates.seedGenRatesUf6.Ortho2Rate + amplitudes.seedGenRatesUf6.Ortho2Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                    clamp (baseRates.seedGenRatesUf6.Para1Rate + amplitudes.seedGenRatesUf6.Para1Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                    clamp (baseRates.seedGenRatesUf6.Para2Rate + amplitudes.seedGenRatesUf6.Para2Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                    clamp (baseRates.seedGenRatesUf6.Para3Rate + amplitudes.seedGenRatesUf6.Para3Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                    clamp (baseRates.seedGenRatesUf6.Para4Rate + amplitudes.seedGenRatesUf6.Para4Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                    clamp (baseRates.seedGenRatesUf6.SelfReflRate + amplitudes.seedGenRatesUf6.SelfReflRate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0)
                let listLength = exactLog2 (order / 6)
                let opsGenRatesList =
                    List.init listLength (fun j ->
                        let baseList = baseRates.opsGenRatesList
                        let ampList = amplitudes.opsGenRatesList
                        if j >= baseList.Length || j >= ampList.Length then OpsGenRates.createUniform()
                        else
                            OpsGenRates.create(
                                clamp (baseList.[j].OrthoRate + ampList.[j].OrthoRate * Math.Sin(t)) 0.0 1.0,
                                clamp (baseList.[j].ParaRate + ampList.[j].ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                clamp (baseList.[j].SelfReflRate + ampList.[j].SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0))
                { Uf6GenRates.order = order; seedGenRatesUf6 = seed; opsGenRatesList = opsGenRatesList })
        Uf6GenRatesArray.create rates


    let createGaussianHotSpot (length: int) (order: int) (baseRates: Uf6GenRates) (hotSpotIndex: int) (hotSpotRates: Uf6GenRates) (sigma: float) : Uf6GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let seed = Seed6GenRates.create(
                    baseRates.seedGenRatesUf6.Ortho1Rate + (hotSpotRates.seedGenRatesUf6.Ortho1Rate - baseRates.seedGenRatesUf6.Ortho1Rate) * weight,
                    baseRates.seedGenRatesUf6.Ortho2Rate + (hotSpotRates.seedGenRatesUf6.Ortho2Rate - baseRates.seedGenRatesUf6.Ortho2Rate) * weight,
                    baseRates.seedGenRatesUf6.Para1Rate + (hotSpotRates.seedGenRatesUf6.Para1Rate - baseRates.seedGenRatesUf6.Para1Rate) * weight,
                    baseRates.seedGenRatesUf6.Para2Rate + (hotSpotRates.seedGenRatesUf6.Para2Rate - baseRates.seedGenRatesUf6.Para2Rate) * weight,
                    baseRates.seedGenRatesUf6.Para3Rate + (hotSpotRates.seedGenRatesUf6.Para3Rate - baseRates.seedGenRatesUf6.Para3Rate) * weight,
                    baseRates.seedGenRatesUf6.Para4Rate + (hotSpotRates.seedGenRatesUf6.Para4Rate - baseRates.seedGenRatesUf6.Para4Rate) * weight,
                    baseRates.seedGenRatesUf6.SelfReflRate + (hotSpotRates.seedGenRatesUf6.SelfReflRate - baseRates.seedGenRatesUf6.SelfReflRate) * weight)
                let listLength = exactLog2 (order / 6)
                let opsGenRatesList =
                    List.init listLength (fun j ->
                        let baseList = baseRates.opsGenRatesList
                        let hotSpotList = hotSpotRates.opsGenRatesList
                        if j >= baseList.Length || j >= hotSpotList.Length then OpsGenRates.createUniform()
                        else
                            OpsGenRates.create(
                                baseList.[j].OrthoRate + (hotSpotList.[j].OrthoRate - baseList.[j].OrthoRate) * weight,
                                baseList.[j].ParaRate + (hotSpotList.[j].ParaRate - baseList.[j].ParaRate) * weight,
                                baseList.[j].SelfReflRate + (hotSpotList.[j].SelfReflRate - baseList.[j].SelfReflRate) * weight))
                { Uf6GenRates.order = order; seedGenRatesUf6 = seed; opsGenRatesList = opsGenRatesList })
        Uf6GenRatesArray.create rates



    let createStepHotSpot (length: int) (order: int) (baseRates: Uf6GenRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: Uf6GenRates) : Uf6GenRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                { Uf6GenRates.order = order; 
                  seedGenRatesUf6 = Seed6GenRates.create(
                      rates.seedGenRatesUf6.Ortho1Rate,
                      rates.seedGenRatesUf6.Ortho2Rate,
                      rates.seedGenRatesUf6.Para1Rate,
                      rates.seedGenRatesUf6.Para2Rate,
                      rates.seedGenRatesUf6.Para3Rate,
                      rates.seedGenRatesUf6.Para4Rate,
                      rates.seedGenRatesUf6.SelfReflRate);
                  opsGenRatesList = rates.opsGenRatesList })
        Uf6GenRatesArray.create rates

    let mutate<'a> 
        (uf6GenRatesArray: Uf6GenRatesArray) 
        (ortho1Mutator: 'a -> 'a) 
        (ortho2Mutator: 'a -> 'a) 
        (para1Mutator: 'a -> 'a) 
        (para2Mutator: 'a -> 'a) 
        (para3Mutator: 'a -> 'a) 
        (para4Mutator: 'a -> 'a) 
        (selfReflMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (seed6TwoOrbitType: TwoOrbitTripleType) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if uf6GenRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
        Array.init arrayToMutate.Length (fun i ->
            let rate = uf6GenRatesArray.Item(i)
            match rate.seedGenRatesUf6.PickMode floatPicker with
            | Seed6GenMode.Ortho1 -> ortho1Mutator arrayToMutate.[i]
            | Seed6GenMode.Ortho2 -> ortho2Mutator arrayToMutate.[i]
            | Seed6GenMode.Para1 -> para1Mutator arrayToMutate.[i]
            | Seed6GenMode.Para2 -> para2Mutator arrayToMutate.[i]
            | Seed6GenMode.Para3 -> para3Mutator arrayToMutate.[i]
            | Seed6GenMode.Para4 -> para4Mutator arrayToMutate.[i]
            | Seed6GenMode.SelfRefl -> selfReflMutator arrayToMutate.[i])



    let createNewItems<'a> 
        (uf6GenRatesArray: Uf6GenRatesArray)
        (itemChooser: Uf6GenRates -> 'a)
            : 'a[] =
        Array.init uf6GenRatesArray.Length (fun i ->
            itemChooser (uf6GenRatesArray.Item(i)))
namespace GeneSort.Core

type Uf6MutationRates =
    {
        order:int;
        seed6TransitionRates: Seed6TransitionRates;
        opsTransitionRates: OpsTransitionRates list
    }


module Uf6MutationRates =

    let makeUniform (order:int) (seed6MutationRates:float) (twoOrbitMutationRate:float) 
         : Uf6MutationRates   =
        let mutRatesListLength = MathUtils.exactLog2 (order / 6)
        let mutRatesList = List.init mutRatesListLength (fun _ -> OpsTransitionRates.createUniform(twoOrbitMutationRate))
        { Uf6MutationRates.order = order;
          seed6TransitionRates = Seed6TransitionRates.createUniform(seed6MutationRates);
          opsTransitionRates = mutRatesList; }


    let biasTowards (order:int) (seed6MutationRates:float) (twoOrbitType:TwoOrbitType) (baseAmt:float) (biasAmt:float) 
         : Uf6MutationRates =
        let mutRatesBaseListLength = MathUtils.exactLog2 (order / 6) - 1
        let mutRatesBaseList = List.init mutRatesBaseListLength (fun _ -> OpsTransitionRates.createUniform(baseAmt))
        let lastGenRates = OpsTransitionRates.createBiased twoOrbitType baseAmt biasAmt
        let genRatesListWithLast = mutRatesBaseList @ [lastGenRates]
        { Uf6MutationRates.order = order;
          seed6TransitionRates = Seed6TransitionRates.createUniform(seed6MutationRates);
          opsTransitionRates = genRatesListWithLast; }
namespace GeneSort.Core
open System
open MathUtils

[<Struct; CustomEquality; NoComparison>]
type Uf6MutationRatesArray =
    private 
        { rates: Uf6MutationRates array }

    static member create (rates: Uf6MutationRates array) : Uf6MutationRatesArray =
        if Array.isEmpty rates then failwith "Rates array cannot be empty"
        if Array.exists (fun r -> r.order < 6 || r.order % 2 <> 0) rates then
            failwith "All Uf6MutationRates orders must be at least 6 and even"
        { rates = rates }

    member this.Length = this.rates.Length
    member this.Item(index: int) = this.rates.[index]
    member this.RatesArray = this.rates

    member this.toString() =
        String.Join(", ", Array.map (
            fun r -> sprintf "Uf6MutationRates(order=%d, seed=%s, listLength=%d)" 
                        r.order (r.seed6TransitionRates.toString()) r.opsTransitionRates.Length) this.rates)

    override this.Equals(obj) =
        match obj with
        | :? Uf6MutationRatesArray as other ->
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seed6TransitionRates.Equals(b.seed6TransitionRates) && 
                    a.opsTransitionRates = b.opsTransitionRates) this.rates other.rates
        | _ -> false

    override this.GetHashCode() =
        let mutable hash = 17
        for rate in this.rates do
            hash <- hash * 23 + rate.order.GetHashCode()
            hash <- hash * 23 + rate.seed6TransitionRates.GetHashCode()
            hash <- hash * 23 + rate.opsTransitionRates.GetHashCode()
        hash

    interface IEquatable<Uf6MutationRatesArray> with
        member this.Equals(other) =
            if this.rates.Length <> other.rates.Length then false
            else
                Array.forall2 (fun a b -> 
                    a.order = b.order && 
                    a.seed6TransitionRates.Equals(b.seed6TransitionRates) && 
                    a.opsTransitionRates = b.opsTransitionRates) this.rates other.rates


module Uf6MutationRatesArray =

    let private clamp (value: float) (min: float) (max: float) =
        Math.Max(min, Math.Min(max, value))

    let private interpolateSeed6ActionRates (startRates: Seed6ActionRates) (endRates: Seed6ActionRates) (t: float) : Seed6ActionRates =
        Seed6ActionRates.create(
            startRates.Ortho1Rate + t * (endRates.Ortho1Rate - startRates.Ortho1Rate),
            startRates.Ortho2Rate + t * (endRates.Ortho2Rate - startRates.Ortho2Rate),
            startRates.Para1Rate + t * (endRates.Para1Rate - startRates.Para1Rate),
            startRates.Para2Rate + t * (endRates.Para2Rate - startRates.Para2Rate),
            startRates.Para3Rate + t * (endRates.Para3Rate - startRates.Para3Rate),
            startRates.Para4Rate + t * (endRates.Para4Rate - startRates.Para4Rate),
            startRates.SelfReflRate + t * (endRates.SelfReflRate - startRates.SelfReflRate))

    let private interpolateOpsTransitionRates (startRates: OpsTransitionRates) (endRates: OpsTransitionRates) (t: float) : OpsTransitionRates =
        OpsTransitionRates.create(
            OpsActionRates.create(
                startRates.OrthoRates.OrthoRate + t * (endRates.OrthoRates.OrthoRate - startRates.OrthoRates.OrthoRate),
                startRates.OrthoRates.ParaRate + t * (endRates.OrthoRates.ParaRate - startRates.OrthoRates.ParaRate),
                startRates.OrthoRates.SelfReflRate + t * (endRates.OrthoRates.SelfReflRate - startRates.OrthoRates.SelfReflRate)),
            OpsActionRates.create(
                startRates.ParaRates.OrthoRate + t * (endRates.ParaRates.OrthoRate - startRates.ParaRates.OrthoRate),
                startRates.ParaRates.ParaRate + t * (endRates.ParaRates.ParaRate - startRates.ParaRates.ParaRate),
                startRates.ParaRates.SelfReflRate + t * (endRates.ParaRates.SelfReflRate - startRates.ParaRates.SelfReflRate)),
            OpsActionRates.create(
                startRates.SelfReflRates.OrthoRate + t * (endRates.SelfReflRates.OrthoRate - startRates.SelfReflRates.OrthoRate),
                startRates.SelfReflRates.ParaRate + t * (endRates.SelfReflRates.ParaRate - startRates.SelfReflRates.ParaRate),
                startRates.SelfReflRates.SelfReflRate + t * (endRates.SelfReflRates.SelfReflRate - startRates.SelfReflRates.SelfReflRate)))

    let createLinearVariation (length: int) (order: int) (startRates: Uf6MutationRates) (endRates: Uf6MutationRates) : Uf6MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if startRates.order <> order || endRates.order <> order then failwith "Start and end rates must have the same order"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1)
                let seed = Seed6TransitionRates.create(
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.Ortho1Rates endRates.seed6TransitionRates.Ortho1Rates t,
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.Ortho2Rates endRates.seed6TransitionRates.Ortho2Rates t,
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.Para1Rates endRates.seed6TransitionRates.Para1Rates t,
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.Para2Rates endRates.seed6TransitionRates.Para2Rates t,
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.Para3Rates endRates.seed6TransitionRates.Para3Rates t,
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.Para4Rates endRates.seed6TransitionRates.Para4Rates t,
                    interpolateSeed6ActionRates startRates.seed6TransitionRates.SelfReflRates endRates.seed6TransitionRates.SelfReflRates t)
                let listLength = exactLog2 (order / 6)
                let opsTransitionRates =
                    List.init listLength (fun j ->
                        let startList = startRates.opsTransitionRates
                        let endList = endRates.opsTransitionRates
                        if j >= startList.Length || j >= endList.Length then OpsTransitionRates.createUniform(0.1)
                        else interpolateOpsTransitionRates startList.[j] endList.[j] t)
                { Uf6MutationRates.order = order; seed6TransitionRates = seed; opsTransitionRates = opsTransitionRates })
        Uf6MutationRatesArray.create rates

    let createSinusoidalVariation (length: int) (order: int) (baseRates: Uf6MutationRates) (amplitudes: Uf6MutationRates) (frequency: float) : Uf6MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if baseRates.order <> order || amplitudes.order <> order then failwith "Base and amplitudes must have the same order"
        let rates =
            Array.init length (fun i ->
                let t = float i / float (length - 1) * 2.0 * Math.PI * frequency
                let phaseShift = 2.0 * Math.PI / 7.0
                let seed = Seed6TransitionRates.create(
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.Ortho1Rate + amplitudes.seed6TransitionRates.Ortho1Rates.Ortho1Rate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.Ortho2Rate + amplitudes.seed6TransitionRates.Ortho1Rates.Ortho2Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.Para1Rate + amplitudes.seed6TransitionRates.Ortho1Rates.Para1Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.Para2Rate + amplitudes.seed6TransitionRates.Ortho1Rates.Para2Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.Para3Rate + amplitudes.seed6TransitionRates.Ortho1Rates.Para3Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.Para4Rate + amplitudes.seed6TransitionRates.Ortho1Rates.Para4Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho1Rates.SelfReflRate + amplitudes.seed6TransitionRates.Ortho1Rates.SelfReflRate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0),
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.Ortho1Rate + amplitudes.seed6TransitionRates.Ortho2Rates.Ortho1Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.Ortho2Rate + amplitudes.seed6TransitionRates.Ortho2Rates.Ortho2Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.Para1Rate + amplitudes.seed6TransitionRates.Ortho2Rates.Para1Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.Para2Rate + amplitudes.seed6TransitionRates.Ortho2Rates.Para2Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.Para3Rate + amplitudes.seed6TransitionRates.Ortho2Rates.Para3Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.Para4Rate + amplitudes.seed6TransitionRates.Ortho2Rates.Para4Rate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Ortho2Rates.SelfReflRate + amplitudes.seed6TransitionRates.Ortho2Rates.SelfReflRate * Math.Sin(t)) 0.0 1.0),
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.Para1Rates.Ortho1Rate + amplitudes.seed6TransitionRates.Para1Rates.Ortho1Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para1Rates.Ortho2Rate + amplitudes.seed6TransitionRates.Para1Rates.Ortho2Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para1Rates.Para1Rate + amplitudes.seed6TransitionRates.Para1Rates.Para1Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para1Rates.Para2Rate + amplitudes.seed6TransitionRates.Para1Rates.Para2Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para1Rates.Para3Rate + amplitudes.seed6TransitionRates.Para1Rates.Para3Rate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para1Rates.Para4Rate + amplitudes.seed6TransitionRates.Para1Rates.Para4Rate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para1Rates.SelfReflRate + amplitudes.seed6TransitionRates.Para1Rates.SelfReflRate * Math.Sin(t + phaseShift)) 0.0 1.0),
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.Para2Rates.Ortho1Rate + amplitudes.seed6TransitionRates.Para2Rates.Ortho1Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para2Rates.Ortho2Rate + amplitudes.seed6TransitionRates.Para2Rates.Ortho2Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para2Rates.Para1Rate + amplitudes.seed6TransitionRates.Para2Rates.Para1Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para2Rates.Para2Rate + amplitudes.seed6TransitionRates.Para2Rates.Para2Rate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para2Rates.Para3Rate + amplitudes.seed6TransitionRates.Para2Rates.Para3Rate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para2Rates.Para4Rate + amplitudes.seed6TransitionRates.Para2Rates.Para4Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para2Rates.SelfReflRate + amplitudes.seed6TransitionRates.Para2Rates.SelfReflRate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0),
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.Para3Rates.Ortho1Rate + amplitudes.seed6TransitionRates.Para3Rates.Ortho1Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para3Rates.Ortho2Rate + amplitudes.seed6TransitionRates.Para3Rates.Ortho2Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para3Rates.Para1Rate + amplitudes.seed6TransitionRates.Para3Rates.Para1Rate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para3Rates.Para2Rate + amplitudes.seed6TransitionRates.Para3Rates.Para2Rate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para3Rates.Para3Rate + amplitudes.seed6TransitionRates.Para3Rates.Para3Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para3Rates.Para4Rate + amplitudes.seed6TransitionRates.Para3Rates.Para4Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para3Rates.SelfReflRate + amplitudes.seed6TransitionRates.Para3Rates.SelfReflRate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0),
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.Para4Rates.Ortho1Rate + amplitudes.seed6TransitionRates.Para4Rates.Ortho1Rate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para4Rates.Ortho2Rate + amplitudes.seed6TransitionRates.Para4Rates.Ortho2Rate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para4Rates.Para1Rate + amplitudes.seed6TransitionRates.Para4Rates.Para1Rate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para4Rates.Para2Rate + amplitudes.seed6TransitionRates.Para4Rates.Para2Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para4Rates.Para3Rate + amplitudes.seed6TransitionRates.Para4Rates.Para3Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para4Rates.Para4Rate + amplitudes.seed6TransitionRates.Para4Rates.Para4Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.Para4Rates.SelfReflRate + amplitudes.seed6TransitionRates.Para4Rates.SelfReflRate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0),
                    Seed6ActionRates.create(
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.Ortho1Rate + amplitudes.seed6TransitionRates.SelfReflRates.Ortho1Rate * Math.Sin(t + 6.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.Ortho2Rate + amplitudes.seed6TransitionRates.SelfReflRates.Ortho2Rate * Math.Sin(t)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.Para1Rate + amplitudes.seed6TransitionRates.SelfReflRates.Para1Rate * Math.Sin(t + phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.Para2Rate + amplitudes.seed6TransitionRates.SelfReflRates.Para2Rate * Math.Sin(t + 2.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.Para3Rate + amplitudes.seed6TransitionRates.SelfReflRates.Para3Rate * Math.Sin(t + 3.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.Para4Rate + amplitudes.seed6TransitionRates.SelfReflRates.Para4Rate * Math.Sin(t + 4.0 * phaseShift)) 0.0 1.0,
                        clamp (baseRates.seed6TransitionRates.SelfReflRates.SelfReflRate + amplitudes.seed6TransitionRates.SelfReflRates.SelfReflRate * Math.Sin(t + 5.0 * phaseShift)) 0.0 1.0))
                let listLength = exactLog2 (order / 6)
                let opsTransitionRates =
                    List.init listLength (fun j ->
                        let baseList = baseRates.opsTransitionRates
                        let ampList = amplitudes.opsTransitionRates
                        if j >= baseList.Length || j >= ampList.Length then OpsTransitionRates.createUniform(0.1)
                        else
                            OpsTransitionRates.create(
                                OpsActionRates.create(
                                    clamp (baseList.[j].OrthoRates.OrthoRate + ampList.[j].OrthoRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                                    clamp (baseList.[j].OrthoRates.ParaRate + ampList.[j].OrthoRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                    clamp (baseList.[j].OrthoRates.SelfReflRate + ampList.[j].OrthoRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0),
                                OpsActionRates.create(
                                    clamp (baseList.[j].ParaRates.OrthoRate + ampList.[j].ParaRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                                    clamp (baseList.[j].ParaRates.ParaRate + ampList.[j].ParaRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                    clamp (baseList.[j].ParaRates.SelfReflRate + ampList.[j].ParaRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0),
                                OpsActionRates.create(
                                    clamp (baseList.[j].SelfReflRates.OrthoRate + ampList.[j].SelfReflRates.OrthoRate * Math.Sin(t)) 0.0 1.0,
                                    clamp (baseList.[j].SelfReflRates.ParaRate + ampList.[j].SelfReflRates.ParaRate * Math.Sin(t + 2.0 * Math.PI / 3.0)) 0.0 1.0,
                                    clamp (baseList.[j].SelfReflRates.SelfReflRate + ampList.[j].SelfReflRates.SelfReflRate * Math.Sin(t + 4.0 * Math.PI / 3.0)) 0.0 1.0)))
                { Uf6MutationRates.order = order; seed6TransitionRates = seed; opsTransitionRates = opsTransitionRates })
        Uf6MutationRatesArray.create rates

    let createGaussianHotSpot (length: int) (order: int) (baseRates: Uf6MutationRates) (hotSpotIndex: int) (hotSpotRates: Uf6MutationRates) (sigma: float) : Uf6MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if hotSpotIndex < 0 || hotSpotIndex >= length then failwith "HotSpotIndex out of range"
        if sigma <= 0.0 then failwith "Sigma must be positive"
        let rates =
            Array.init length (fun i ->
                let x = float (i - hotSpotIndex)
                let weight = Math.Exp(-x * x / (2.0 * sigma * sigma))
                let seed = Seed6TransitionRates.create(
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.Ortho1Rates (hotSpotRates.seed6TransitionRates.Ortho1Rates) weight,
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.Ortho2Rates (hotSpotRates.seed6TransitionRates.Ortho2Rates) weight,
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.Para1Rates (hotSpotRates.seed6TransitionRates.Para1Rates) weight,
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.Para2Rates (hotSpotRates.seed6TransitionRates.Para2Rates) weight,
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.Para3Rates (hotSpotRates.seed6TransitionRates.Para3Rates) weight,
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.Para4Rates (hotSpotRates.seed6TransitionRates.Para4Rates) weight,
                    interpolateSeed6ActionRates baseRates.seed6TransitionRates.SelfReflRates (hotSpotRates.seed6TransitionRates.SelfReflRates) weight)
                let listLength = exactLog2 (order / 6)
                let opsTransitionRates =
                    List.init listLength (fun j ->
                        let baseList = baseRates.opsTransitionRates
                        let hotSpotList = hotSpotRates.opsTransitionRates
                        if j >= baseList.Length || j >= hotSpotList.Length then OpsTransitionRates.createUniform(0.1)
                        else interpolateOpsTransitionRates baseList.[j] hotSpotList.[j] weight)
                { Uf6MutationRates.order = order; seed6TransitionRates = seed; opsTransitionRates = opsTransitionRates })
        Uf6MutationRatesArray.create rates

    let createStepHotSpot (length: int) (order: int) (baseRates: Uf6MutationRates) (hotSpotStart: int) (hotSpotEnd: int) (hotSpotRates: Uf6MutationRates) : Uf6MutationRatesArray =
        if length <= 0 then failwith "Length must be positive"
        if order < 6 || order % 2 <> 0 then failwith "Order must be at least 6 and even"
        if baseRates.order <> order || hotSpotRates.order <> order then failwith "Base and hotspot rates must have the same order"
        if hotSpotStart < 0 || hotSpotStart >= length || hotSpotEnd < hotSpotStart || hotSpotEnd >= length then failwith "Invalid hot spot range"
        let rates =
            Array.init length (fun i ->
                let rates = if i >= hotSpotStart && i <= hotSpotEnd then hotSpotRates else baseRates
                { Uf6MutationRates.order = order; 
                  seed6TransitionRates = Seed6TransitionRates.create(
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.Ortho1Rates.Ortho1Rate,
                          rates.seed6TransitionRates.Ortho1Rates.Ortho2Rate,
                          rates.seed6TransitionRates.Ortho1Rates.Para1Rate,
                          rates.seed6TransitionRates.Ortho1Rates.Para2Rate,
                          rates.seed6TransitionRates.Ortho1Rates.Para3Rate,
                          rates.seed6TransitionRates.Ortho1Rates.Para4Rate,
                          rates.seed6TransitionRates.Ortho1Rates.SelfReflRate),
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.Ortho2Rates.Ortho1Rate,
                          rates.seed6TransitionRates.Ortho2Rates.Ortho2Rate,
                          rates.seed6TransitionRates.Ortho2Rates.Para1Rate,
                          rates.seed6TransitionRates.Ortho2Rates.Para2Rate,
                          rates.seed6TransitionRates.Ortho2Rates.Para3Rate,
                          rates.seed6TransitionRates.Ortho2Rates.Para4Rate,
                          rates.seed6TransitionRates.Ortho2Rates.SelfReflRate),
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.Para1Rates.Ortho1Rate,
                          rates.seed6TransitionRates.Para1Rates.Ortho2Rate,
                          rates.seed6TransitionRates.Para1Rates.Para1Rate,
                          rates.seed6TransitionRates.Para1Rates.Para2Rate,
                          rates.seed6TransitionRates.Para1Rates.Para3Rate,
                          rates.seed6TransitionRates.Para1Rates.Para4Rate,
                          rates.seed6TransitionRates.Para1Rates.SelfReflRate),
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.Para2Rates.Ortho1Rate,
                          rates.seed6TransitionRates.Para2Rates.Ortho2Rate,
                          rates.seed6TransitionRates.Para2Rates.Para1Rate,
                          rates.seed6TransitionRates.Para2Rates.Para2Rate,
                          rates.seed6TransitionRates.Para2Rates.Para3Rate,
                          rates.seed6TransitionRates.Para2Rates.Para4Rate,
                          rates.seed6TransitionRates.Para2Rates.SelfReflRate),
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.Para3Rates.Ortho1Rate,
                          rates.seed6TransitionRates.Para3Rates.Ortho2Rate,
                          rates.seed6TransitionRates.Para3Rates.Para1Rate,
                          rates.seed6TransitionRates.Para3Rates.Para2Rate,
                          rates.seed6TransitionRates.Para3Rates.Para3Rate,
                          rates.seed6TransitionRates.Para3Rates.Para4Rate,
                          rates.seed6TransitionRates.Para3Rates.SelfReflRate),
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.Para4Rates.Ortho1Rate,
                          rates.seed6TransitionRates.Para4Rates.Ortho2Rate,
                          rates.seed6TransitionRates.Para4Rates.Para1Rate,
                          rates.seed6TransitionRates.Para4Rates.Para2Rate,
                          rates.seed6TransitionRates.Para4Rates.Para3Rate,
                          rates.seed6TransitionRates.Para4Rates.Para4Rate,
                          rates.seed6TransitionRates.Para4Rates.SelfReflRate),
                      Seed6ActionRates.create(
                          rates.seed6TransitionRates.SelfReflRates.Ortho1Rate,
                          rates.seed6TransitionRates.SelfReflRates.Ortho2Rate,
                          rates.seed6TransitionRates.SelfReflRates.Para1Rate,
                          rates.seed6TransitionRates.SelfReflRates.Para2Rate,
                          rates.seed6TransitionRates.SelfReflRates.Para3Rate,
                          rates.seed6TransitionRates.SelfReflRates.Para4Rate,
                          rates.seed6TransitionRates.SelfReflRates.SelfReflRate));
                  opsTransitionRates = rates.opsTransitionRates })
        Uf6MutationRatesArray.create rates

    let mutate<'a> 
        (uf6MutationRatesArray: Uf6MutationRatesArray) 
        (ortho1Mutator: 'a -> 'a) 
        (ortho2Mutator: 'a -> 'a) 
        (para1Mutator: 'a -> 'a) 
        (para2Mutator: 'a -> 'a) 
        (para3Mutator: 'a -> 'a) 
        (para4Mutator: 'a -> 'a) 
        (selfReflMutator: 'a -> 'a) 
        (noActionMutator: 'a -> 'a) 
        (floatPicker: unit -> float) 
        (seed6TwoOrbitType: TwoOrbitTripleType) 
        (arrayToMutate: 'a[]) : 'a[] = 
        if uf6MutationRatesArray.Length <> arrayToMutate.Length then
            failwith "Array length does not match rates length"
        Array.init arrayToMutate.Length (fun i ->
            let rate = uf6MutationRatesArray.Item(i)
            match rate.seed6TransitionRates.PickMode floatPicker seed6TwoOrbitType with
            | Seed6ActionMode.Ortho1 -> ortho1Mutator arrayToMutate.[i]
            | Seed6ActionMode.Ortho2 -> ortho2Mutator arrayToMutate.[i]
            | Seed6ActionMode.Para1 -> para1Mutator arrayToMutate.[i]
            | Seed6ActionMode.Para2 -> para2Mutator arrayToMutate.[i]
            | Seed6ActionMode.Para3 -> para3Mutator arrayToMutate.[i]
            | Seed6ActionMode.Para4 -> para4Mutator arrayToMutate.[i]
            | Seed6ActionMode.SelfRefl -> selfReflMutator arrayToMutate.[i]
            | Seed6ActionMode.NoAction -> noActionMutator arrayToMutate.[i])

    let createNewItems<'a> 
        (uf6MutationRatesArray: Uf6MutationRatesArray)
        (itemChooser: Uf6MutationRates -> 'a)
            : 'a[] =
        Array.init uf6MutationRatesArray.Length (fun i ->
            itemChooser (uf6MutationRatesArray.Item(i)))
namespace GeneSort.Core

type TwoOrbitType =
    | Ortho
    | Para
    | SelfRefl


/// Represents a pair of distinct, non-negative indices in canonical order (smaller index first).
[<CustomEquality; NoComparison>]
type TwoOrbit = private TwoOrbit of (int * int) with
    /// Creates a TwoOrbit from a list of exactly two distinct, non-negative indices.
    /// <param name="indices">A list of exactly two distinct, non-negative integers.</param>
    /// <exception cref="System.ArgumentException">Thrown when the list doesn't contain exactly two indices, indices are negative, or indices are equal.</exception>
    static member create (indices: int list) : TwoOrbit =
        if indices.Length <> 2 then
            failwith "TwoOrbit must contain exactly 2 indices"
        if indices |> List.exists (fun i -> i < 0) then
            failwith "TwoOrbit indices must be non-negative"
        match indices with
        | [a; b] when a = b -> failwith "TwoOrbit indices must be distinct"
        | [a; b] -> TwoOrbit (min a b, max a b)
        | _ -> failwith "Invalid TwoOrbit indices"

    member this.First with get() =
        match this with
        | TwoOrbit (a, b) -> a

    member this.Second with get() =
        match this with
        | TwoOrbit (a, b) -> b

    /// Gets the indices as a list.
    member this.Indices =
        match this with
        | TwoOrbit (a, b) -> [a; b]

    /// Gets the indices as a tuple.
    member this.IndicesTuple =
        match this with
        | TwoOrbit tuple -> tuple

    /// Converts the TwoOrbit to an Orbit.
    member this.ToOrbit =
        match this with
        | TwoOrbit (a, b) -> Orbit.create [a; b]

    /// Checks if this TwoOrbit is disjoint from another.
    member this.IsDisjoint (other: TwoOrbit) =
        Set.ofList this.Indices |> Set.intersect (Set.ofList other.Indices) |> Set.isEmpty

    /// Determines whether this instance equals another TwoOrbit.
    override this.Equals (obj: obj) =
        match obj with
        | :? TwoOrbit as other -> this.IndicesTuple = other.IndicesTuple
        | _ -> false

    /// Computes the hash code for this instance.
    override this.GetHashCode () =
        match this with
        | TwoOrbit tuple -> hash tuple

    /// Returns a string representation of the TwoOrbit.
    override this.ToString () =
        match this with
        | TwoOrbit (a, b) -> sprintf "TwoOrbit(%d, %d)" a b


/// Operations on TwoOrbit types.
module TwoOrbit =
    /// Returns the reflection of the TwoOrbit about (order - 1) / 2.
    /// <param name="order">The order (must be non-negative and even).</param>
    /// <param name="orbit">The TwoOrbit to reflect.</param>
    /// <exception cref="System.ArgumentException">Thrown when order is negative or odd.</exception>
    let getReflection (order: int) (orbit: TwoOrbit) : TwoOrbit =
        if order < 0 then
            failwith "Order must be non-negative"
        if order % 2 <> 0 then
            failwith "Order must be even"
        let reflectedIndices = orbit.Indices |> List.map (fun i -> order - 1 - i)
        TwoOrbit.create reflectedIndices

    /// Checks if the TwoOrbit is equal to its reflection.
    /// <param name="order">The order (must be non-negative and even).</param>
    /// <param name="orbit">The TwoOrbit to check.</param>
    let isReflectionSymmetric (order: int) (orbit: TwoOrbit) : bool =
        let reflected = getReflection order orbit
        orbit.Equals(reflected)

        
    /// Gets the TwoOrbitType.
    /// <param name="order">The order (must be non-negative and even).</param>
    /// <param name="orbit">The TwoOrbit to check.</param>
    let getTwoOrbitType (order: int) (orbit: TwoOrbit) : TwoOrbitType =
        if (isReflectionSymmetric order orbit) then
            TwoOrbitType.SelfRefl
        else if snd orbit.IndicesTuple > order / 2 then
            if (fst orbit.IndicesTuple >= order / 2) then
                TwoOrbitType.Ortho
            else
                TwoOrbitType.Para
        else
            TwoOrbitType.Ortho

    let getTwoOrbits (twoOrbitType:TwoOrbitType) : TwoOrbit list =
        match twoOrbitType with
        | TwoOrbitType.Ortho -> [TwoOrbit.create [0; 1]; TwoOrbit.create [2; 3]]
        | TwoOrbitType.Para -> [TwoOrbit.create [0; 2]; TwoOrbit.create [1; 3]]
        | TwoOrbitType.SelfRefl -> [TwoOrbit.create [0; 3]; TwoOrbit.create [1; 2]]
namespace GeneSort.Core

type TwoOrbitPairType =
    | Ortho
    | Para
    | SelfRefl

/// Represents a pair of TwoOrbit instances (second optional) with an associated order.
/// The order must be non-negative and even, and the TwoOrbits must be disjoint if both are present.
/// The Second of the pair has a higher first index than the First if both are present.
[<CustomEquality; NoComparison>]
type TwoOrbitPair = private { First: TwoOrbit; Second: TwoOrbit option; order: int } with
    /// Creates a TwoOrbitPair with a required first TwoOrbit, an optional second TwoOrbit, and an order.
    /// <param name="first">The first TwoOrbit (required).</param>
    /// <param name="second">The second TwoOrbit (optional).</param>
    /// <param name="order">The order (must be non-negative and even).</param>
    /// <exception cref="System.ArgumentException">Thrown when order is negative, odd, or the TwoOrbits share indices.</exception>
    static member create (order: int) (first: TwoOrbit) (second: TwoOrbit option) : TwoOrbitPair =
        if order < 0 then
            failwith "TwoOrbitPair order must be non-negative"
        if order % 2 <> 0 then
            failwith "TwoOrbitPair order must be even"
        // Validate indices are within bounds (0 to order-1)
        let firstIndices = first.Indices
        if firstIndices |> List.exists (fun i -> i >= order) then
            failwith "First TwoOrbit indices must be within order bounds"
        match second with
        | Some s ->
            let secondIndices = s.Indices
            if secondIndices |> List.exists (fun i -> i >= order) then
                failwith "Second TwoOrbit indices must be within order bounds"
            if not (first.IsDisjoint s) then
                failwith "TwoOrbitPair TwoOrbits must be disjoint"

            if (first.First < s.First) then
                { First = first; Second = Some s; order = order }
            else
                { First = s; Second = Some first; order = order }

        | None -> { First = first; Second = None; order = order }

    /// Gets the first TwoOrbit.
    member this.FirstOrbit with get () = this.First

    /// Gets the second TwoOrbit (if present).
    member this.SecondOrbit with get () = this.Second

    /// Gets the order.
    member this.Order with get () = this.order

    /// Checks if the TwoOrbits are disjoint (returns true if second is None).
    member this.IsDisjoint =
        match this.Second with
        | Some second -> this.First.IsDisjoint second
        | None -> true

    /// Determines whether this instance equals another TwoOrbitPair.
    override this.Equals(obj: obj) =
        match obj with
        | :? TwoOrbitPair as other ->
            this.First = other.First &&
            this.Second = other.Second &&
            this.Order = other.Order
        | _ -> false

    /// Computes the hash code for this instance.
    override this.GetHashCode() =
        hash (this.GetType(), this.First, this.Second, this.Order)

    /// Returns a string representation of the TwoOrbitPair.
    override this.ToString() =
        sprintf "TwoOrbitPair(First=%A, Second=%A, Order=%d)" this.First this.Second this.Order
namespace GeneSort.Core


module TwoOrbitPairOps =
    /// Gets the TwoOrbitType of the TwoOrbitPair
    /// returns the TwoOrbitType of the first TwoOrbit if the second is None,
    /// or checks the TwoOrbitType of both if the second is present.
    /// returns None if the TwoOrbits are not of the same type.
    /// <param name="twoOrbitPair">The TwoOrbitPair to check.</param>
    let getTwoOrbitPairTypeOption (twoOrbitPair: TwoOrbitPair) : TwoOrbitPairType option =

        match twoOrbitPair.Second with
        | None -> 
               match (TwoOrbit.getTwoOrbitType twoOrbitPair.Order twoOrbitPair.FirstOrbit) with
               | TwoOrbitType.Ortho -> Some TwoOrbitPairType.Ortho
               | TwoOrbitType.Para -> Some TwoOrbitPairType.Para
               | TwoOrbitType.SelfRefl -> Some TwoOrbitPairType.SelfRefl
        | Some second ->
          match (TwoOrbit.getTwoOrbitType twoOrbitPair.Order twoOrbitPair.FirstOrbit) with
            | TwoOrbitType.Ortho ->
                match (TwoOrbit.getTwoOrbitType twoOrbitPair.Order second) with
                | TwoOrbitType.Ortho -> Some TwoOrbitPairType.Ortho 
                | _ -> None
            | TwoOrbitType.Para ->
                match (TwoOrbit.getTwoOrbitType twoOrbitPair.Order second) with
                | TwoOrbitType.Para -> Some TwoOrbitPairType.Para 
                | _ -> None
            | TwoOrbitType.SelfRefl ->
                match (TwoOrbit.getTwoOrbitType twoOrbitPair.Order second) with
                | TwoOrbitType.SelfRefl -> Some TwoOrbitPairType.SelfRefl 
                | _ -> None


    let getTwoOrbitPairType (twoOrbitPair:TwoOrbitPair) : TwoOrbitPairType =
        if twoOrbitPair.Second.IsNone then
            TwoOrbitPairType.SelfRefl
        else
            let orbit1 = twoOrbitPair.First
            if TwoOrbit.isReflectionSymmetric twoOrbitPair.Order orbit1  then
                TwoOrbitPairType.SelfRefl
            else
                if ((snd orbit1.IndicesTuple) < twoOrbitPair.Order / 2) then
                    TwoOrbitPairType.Ortho
                else
                    TwoOrbitPairType.Para


    let fromTwoOrbits (order:int) (twoOrbits:seq<TwoOrbit>) : seq<TwoOrbitPair> =
        twoOrbits |> CollectionUtils.pairWithNext 
                  |> Seq.map(fun (to1, to2) -> TwoOrbitPair.create order to1 to2)

    
    let makeTwoOrbits (twoOrbitPairs:seq<TwoOrbitPair>) : seq<TwoOrbit> =
        seq {
            for top in twoOrbitPairs do
                yield top.FirstOrbit
                if (top.SecondOrbit.IsSome) then
                    yield top.SecondOrbit.Value
        }


    // creates a TwoOrbitPair from a TwoOrbit by reflection
    let unfoldTwoOrbitIntoTwoOrbitPair
            (twoOrbit:TwoOrbit) 
            (order:int) 
            (twoOrbitType:TwoOrbitType) : TwoOrbitPair =

        let (low, high) = twoOrbit.IndicesTuple
        let (highR, lowR) = (TwoOrbit.getReflection (order*2) twoOrbit).IndicesTuple
        let (twoOrbitA, twoOrbitB) = 
            match twoOrbitType with
            | TwoOrbitType.Ortho -> (TwoOrbit.create [low; high], TwoOrbit.create [lowR; highR])
            | TwoOrbitType.Para -> (TwoOrbit.create [low; highR], TwoOrbit.create [high; lowR])
            | TwoOrbitType.SelfRefl -> (TwoOrbit.create [low; lowR], TwoOrbit.create [high; highR])

        TwoOrbitPair.create (order*2) twoOrbitA (Some twoOrbitB)
namespace GeneSort.Core

open Combinatorics

/// The seven reflection symmetric order 6 TwoCycles.
type TwoOrbitTripleType =
    | Ortho1
    | Ortho2
    | Para1
    | Para2
    | Para3
    | Para4
    | SelfRefl


module TwoOrbitTripleType =

    /// 
    let getTwoOrbits (seedType:TwoOrbitTripleType) : TwoOrbit list =
        match seedType with
        | Ortho1 -> [TwoOrbit.create [0; 1]; TwoOrbit.create [4; 5]; TwoOrbit.create [2; 3]]
        | Ortho2 -> [TwoOrbit.create [0; 2]; TwoOrbit.create [3; 5]; TwoOrbit.create [1; 4]]
        | Para1 -> [TwoOrbit.create [0; 3]; TwoOrbit.create [2; 5]; TwoOrbit.create [1; 4]]
        | Para2 -> [TwoOrbit.create [0; 4]; TwoOrbit.create [1; 5]; TwoOrbit.create [2; 3]]
        | Para3 -> [TwoOrbit.create [1; 3]; TwoOrbit.create [2; 4]; TwoOrbit.create [0; 5]]
        | Para4 -> [TwoOrbit.create [0; 3]; TwoOrbit.create [1; 4]; TwoOrbit.create [2; 5]]
        | TwoOrbitTripleType.SelfRefl -> [TwoOrbit.create [0; 5]; TwoOrbit.create [1; 4]; TwoOrbit.create [2; 3]]
namespace GeneSort.Core

///For creating a Perm_Rs, which is generated by the unfolding process, based on an Order4.SeedType
[<CustomEquality; NoComparison>]
type TwoOrbitUf4 = private { seedType: TwoOrbitType; twoOrbitUnfolderSteps: TwoOrbitUfStep list; } with
    /// The TwoOrbitUnfolder4 specifies the creation of a Perm_Si of
    /// order 4 * 2^n, where n is the length of twoOrbitUnfolderSteps.
    /// <param name="seedType">The Order4.SeedType </param>
    /// <param name="twoOrbitUnfolderSteps">The list of TwoOrbitUfStep (must be non-empty).</param>
    static member create 
            (seedType: TwoOrbitType) 
            (twoOrbitUnfolderSteps: TwoOrbitUfStep list) 
            : TwoOrbitUf4 =
        { seedType = seedType; twoOrbitUnfolderSteps = twoOrbitUnfolderSteps; }

    member this.Order with get() : int  =
            4 * (MathUtils.integerPower 2 (List.length this.twoOrbitUnfolderSteps))

    member this.TwoOrbitType with get() : TwoOrbitType  =
            this.seedType

    member this.TwoOrbitUnfolderSteps with get() : TwoOrbitUfStep list  =
            this.twoOrbitUnfolderSteps

    /// Determines whether this instance equals another TwoOrbitUnfolder.
    override this.Equals (obj: obj) =
        match obj with
        | :? TwoOrbitUf4 as other -> this.seedType = other.seedType
        | _ -> false

    /// Computes the hash code for this instance.
    override this.GetHashCode () =
        hash (this.GetType(), this.seedType, this.twoOrbitUnfolderSteps)

    /// Returns a string representation of the TwoOrbitUnfolder.
    override this.ToString () =
        sprintf "TwoOrbitUnfolder4(seedTypes=%A, twoOrbitUnfolderSteps=%A)" this.seedType this.twoOrbitUnfolderSteps 

    member this.MakePerm_Si : Perm_Si =
            let seedTwoOrbitPairs = 
                this.seedType 
                    |> TwoOrbit.getTwoOrbits 
                    |> TwoOrbitPairOps.fromTwoOrbits 4 |> Seq.toList

            let twoOrbitPairs = 
                    this.twoOrbitUnfolderSteps 
                    |> List.fold (fun pair step -> 
                        let result = TwoOrbitUfStep.unfoldTwoOrbitPairs step pair
                        result
                    ) seedTwoOrbitPairs

            Perm_Si.fromTwoOrbitPair twoOrbitPairs


module TwoOrbitUnfolder4 =

    let getOrder (twoOrbitUnfolder: TwoOrbitUf4) : int =
            4 * (MathUtils.integerPower 2 (List.length twoOrbitUnfolder.twoOrbitUnfolderSteps))
namespace GeneSort.Core

///For creating a Perm_Rs, which is generated by the unfolding process, based on an Order6.SeedType
[<CustomEquality; NoComparison>]
type TwoOrbitUf6 = private { seed6TwoOrbitType: TwoOrbitTripleType; twoOrbitUnfolderSteps: TwoOrbitUfStep list; } with
    /// The TwoOrbitUnfolder6 specifies the creation of a Perm_Si of
    /// order 6 * 2^n, where n is the length of perm_RsUnfolderSteps.
    /// <param name="seedType">The Order6.SeedType </param>
    /// <param name="twoOrbitUnfolderSteps">The list of TwoOrbitUfStep (must be non-empty).</param>
    static member create 
            (seed6TwoOrbitType: TwoOrbitTripleType) 
            (twoOrbitUnfolderSteps: TwoOrbitUfStep list) 
            : TwoOrbitUf6 =
        if List.length twoOrbitUnfolderSteps  < 1 then
            failwith "twoOrbitUnfolderSteps must not be empty"
        { seed6TwoOrbitType = seed6TwoOrbitType; twoOrbitUnfolderSteps = twoOrbitUnfolderSteps; }

    member this.Order with get() : int  =
            6 * (MathUtils.integerPower 2 (List.length this.twoOrbitUnfolderSteps))

    member this.Seed6TwoOrbitType with get() : TwoOrbitTripleType  =
            this.seed6TwoOrbitType

    member this.TwoOrbitUnfolderSteps with get() : TwoOrbitUfStep list  =
            this.twoOrbitUnfolderSteps

    /// Determines whether this instance equals another TwoOrbitUnfolder.
    override this.Equals (obj: obj) =
        match obj with
        | :? TwoOrbitUf6 as other -> this.seed6TwoOrbitType = other.seed6TwoOrbitType
        | _ -> false

    /// Computes the hash code for this instance.
    override this.GetHashCode () =
        hash (this.seed6TwoOrbitType, this.twoOrbitUnfolderSteps)

    /// Returns a string representation of the TwoOrbitUnfolder.
    override this.ToString () =
        sprintf "TwoOrbitUnfolder6(Seed6TwoOrbitType=%A, twoOrbitUnfolderSteps=%A)" this.seed6TwoOrbitType this.twoOrbitUnfolderSteps


    member this.MakePerm_Si : Perm_Si =

        let seedTwoOrbitPairs = 
                this.seed6TwoOrbitType 
                    |> TwoOrbitTripleType.getTwoOrbits
                    |> TwoOrbitPairOps.fromTwoOrbits 6 |> Seq.toList

        let twoOrbitPairs = 
                this.twoOrbitUnfolderSteps 
                |> List.fold (fun pair step -> 
                    let result = TwoOrbitUfStep.unfoldTwoOrbitPairs step pair
                    result
                ) seedTwoOrbitPairs

        Perm_Si.fromTwoOrbitPair twoOrbitPairs
namespace GeneSort.Core

open TwoOrbitPairOps

/// Specifies the transformation of sequences of TwoOrbitPairs to sequences of TwoOrbitPairs.
[<CustomEquality; NoComparison>]
type TwoOrbitUfStep = private { twoOrbitTypes: TwoOrbitType list; order: int } with
    /// The TwoOrbitUfStep specifies the transformation of a group of TwoOrbits into another
    /// group of TwoOrbits (of twice the size and twice the order), via reflection and further
    /// modification according to the list of TwoOrbitTypes
    /// <param name="twoOrbitTypes">The list of TwoOrbitType values (must be non-empty).</param>
    /// <param name="order">The order TwoOrbits the Perm_RsUnfolderStep acts upon.</param>
    /// <exception cref="System.ArgumentException">Thrown when order is negative or the type types is empty.</exception>
    static member create (twoOrbitTypes: TwoOrbitType list) (order: int) : TwoOrbitUfStep =
        if order < 4 then
            failwith "TwoOrbitUfStep order must be at least 4"
        if order % 2 <> 0 then
            failwith "TwoOrbitUfStep order must be even"
        if List.length twoOrbitTypes <> order / 2 then
            failwith $"TwoOrbitUfStep twoOrbitTypes length must be order / 2 ({order / 2})"
        { twoOrbitTypes = twoOrbitTypes; order = order }

    /// Determines whether this instance equals another Perm_RsUnfolderStep.
    override this.Equals (obj: obj) =
        match obj with
        | :? TwoOrbitUfStep as other -> this.twoOrbitTypes = other.twoOrbitTypes && this.Order = other.Order
        | _ -> false

    member this.Order
        with get () = this.order

    member this.TwoOrbitTypes
        with get () = this.twoOrbitTypes

    /// Computes the hash code for this instance.
    override this.GetHashCode () =
        hash (this.GetType(), this.twoOrbitTypes, this.Order)

    /// Returns a string representation of the TwoOrbitUnfol der.
    override this.ToString () =
        sprintf "TwoOrbitUfStep(TwoOrbitTypes=%A, Order=%d)" this.twoOrbitTypes this.Order


module TwoOrbitUfStep =

    /// creates an ordered list of TwoOrbitPairs, the same length as the TwoOrbit list
    /// provided, and twice the order of the given Perm_RsUnfolderStep.
    let unfoldTwoOrbits
        (twoOrbitUfStep:TwoOrbitUfStep) 
        (twoOrbits:TwoOrbit list) : TwoOrbitPair list =

        let zippy = twoOrbitUfStep.twoOrbitTypes |> List.zip twoOrbits
        [  
            for zip in zippy do
                    unfoldTwoOrbitIntoTwoOrbitPair
                        (fst zip)
                        twoOrbitUfStep.Order
                        (snd zip)
        ]

    /// creates an ordered list of TwoOrbitPairs, equal in length to 
    /// twoOrbitUnfolder.TwoOrbitTypes, and twice the order of the given Perm_RsUnfolderStep.
    let unfoldTwoOrbitPairs
        (twoOrbitUfStep:TwoOrbitUfStep) 
        (twoOrbitPairs:TwoOrbitPair list) : TwoOrbitPair list =

        let twoOrbits = twoOrbitPairs |> TwoOrbitPairOps.makeTwoOrbits |> Seq.toList
        let zippy = twoOrbitUfStep.twoOrbitTypes |> List.zip twoOrbits
        [  
            for zip in zippy do
                    unfoldTwoOrbitIntoTwoOrbitPair
                        (fst zip)
                        twoOrbitUfStep.Order
                        (snd zip)
        ]



    
namespace GeneSort.Core

module ArrayOps = ()
namespace GeneSort.Core
open LanguagePrimitives

module ArrayProperties =

    let inline distanceSquared< ^a when ^a: (static member Zero: ^a)
                                        and ^a: (static member (+): ^a * ^a -> ^a)
                                        and ^a: (static member (-): ^a * ^a -> ^a)
                                        and ^a: (static member (*): ^a * ^a -> ^a)>
                    (a: ^a[]) (b: ^a[]) : ^a =
        let mutable acc = GenericZero<^a>
        let mutable i = 0
        while i < a.Length do
            acc <- acc + (a.[i] - b.[i]) * (a.[i] - b.[i])
            i <- i + 1
        acc


    let inline distanceSquaredOffset< ^a when ^a: (static member Zero: ^a)
                                                    and ^a: (static member (+): ^a * ^a -> ^a)
                                                    and ^a: (static member (-): ^a * ^a -> ^a)
                                                    and ^a: (static member (*): ^a * ^a -> ^a)>
            (longArray: ^a[]) (shortArray: ^a[]) : ^a[] =
        let n = shortArray.Length
        let m = longArray.Length / n
        let result = Array.zeroCreate m
        for i = 0 to m - 1 do
            let mutable acc = GenericZero<^a>
            for j = 0 to n - 1 do
                let diff = longArray.[i * n + j] - shortArray.[j]
                acc <- acc + diff * diff
            result.[i] <- acc
        result


    let inline isSorted< ^a when ^a: comparison> (values: ^a[]) : bool =
        if isNull values then 
            failwith "Array cannot be null"
        elif values.Length <= 1 then true
        else
            let mutable i = 1
            let mutable isSorted = true
            while (i < values.Length && isSorted) do
                isSorted <- (values.[i - 1] <= values.[i])
                i <- i + 1
            isSorted


    let inline isSortedOffset< ^a when ^a: comparison> 
                    (values: ^a[]) 
                    (offset:int) 
                    (length:int) : bool =
        if isNull values then failwith "Array cannot be null"
        elif offset < 0 then failwithf "Invalid offset: %d" offset
        elif length < 0 then failwithf "Invalid length: %d" length
        elif offset + length > values.Length then 
            failwithf "Offset plus length exceeds array size: offset=%d, length=%d, array size=%d" offset length values.Length
        elif length <= 1 then true
        else
            let mutable i = 1
            let mutable isSorted = true
            while (i < length && isSorted) do
                isSorted <- (values.[i + offset - 1] <= values.[i + offset])
                i <- i + 1
            isSorted
namespace GeneSort.Core

open System
open SysExt


type BytePack = {
    bitsPerSymbol: int
    symbolCount: int
    data: byte[]
}


module BytePack =

    let toBitSequence (bytePack: BytePack) : seq<bool> =
        bytePack.data
        |> Seq.collect (fun b -> b.toBoolArrayMSB 8)

    let toSequenceOfInt (bytePack: BytePack) : seq<int> =
        let bits = toBitSequence bytePack |> Seq.toArray
        let chunkSize = bytePack.bitsPerSymbol
        let expectedBits = bytePack.symbolCount * chunkSize
        
        if bits.Length < expectedBits then
            failwithf "Not enough bits in data: expected %d bits for %d symbols of %d bits each, but got %d bits"
                expectedBits bytePack.symbolCount chunkSize bits.Length

        seq {
            for i = 0 to bytePack.symbolCount - 1 do
                let start = i * chunkSize
                let mutable value = 0
                for j = 0 to chunkSize - 1 do
                    if bits.[start + j] then
                        value <- value ||| (1 <<< (chunkSize - 1 - j))
                yield value
        }

    let fromSequenceOfInt (ints: seq<int>) (bitsPerSymbol: int) : BytePack =
        let symbols = Seq.toArray ints
        let symbolCount = symbols.Length
        let totalBits = symbolCount * bitsPerSymbol
        
        if bitsPerSymbol <= 0 then
            failwith "bitsPerSymbol must be positive"
        if symbolCount = 0 then
            { bitsPerSymbol = bitsPerSymbol; symbolCount = 0; data = [||] }
        else
            let bits =
                symbols
                |> Seq.collect (fun n ->
                    seq { for i = bitsPerSymbol - 1 downto 0 do
                            yield (n &&& (1 <<< i)) <> 0 })
            let byteCount = (totalBits + 7) / 8
            let data = Array.zeroCreate<byte> byteCount
            let mutable bitIndex = 0
            
            for b in bits do
                let byteIdx = bitIndex / 8
                let bitPos = 7 - (bitIndex % 8)
                if b then
                    data.[byteIdx] <- data.[byteIdx] ||| (1uy <<< bitPos)
                bitIndex <- bitIndex + 1
                
            { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = data }



    let toSequenceOfUInt64 (bp: BytePack) : seq<uint64> =
        let bits = toBitSequence bp |> Seq.toArray
        let chunkSize = bp.bitsPerSymbol
        let expectedBits = bp.symbolCount * chunkSize
    
        if chunkSize <= 0 then
            failwith "bitsPerSymbol must be positive"
        if chunkSize > 64 then
            failwithf "bitsPerSymbol (%d) exceeds uint64 capacity (64 bits)" chunkSize
        if bits.Length < expectedBits then
            failwithf "Not enough bits in data: expected %d bits for %d symbols of %d bits each, but got %d bits"
                expectedBits bp.symbolCount chunkSize bits.Length

        seq {
            for i = 0 to bp.symbolCount - 1 do
                let start = i * chunkSize
                let mutable value = 0uL
                for j = 0 to chunkSize - 1 do
                    if bits.[start + j] then
                        value <- value ||| (1uL <<< (chunkSize - 1 - j))
                yield value
        }

    let fromSequenceOfUInt64 (uint64s: seq<uint64>) (bitsPerSymbol: int) : BytePack =
        let symbols = Seq.toArray uint64s
        let symbolCount = symbols.Length
        let totalBits = symbolCount * bitsPerSymbol
    
        if bitsPerSymbol <= 0 then
            failwith "bitsPerSymbol must be positive"
        if bitsPerSymbol > 64 then
            failwithf "bitsPerSymbol (%d) exceeds uint64 capacity (64 bits)" bitsPerSymbol
        if symbolCount = 0 then
            { bitsPerSymbol = bitsPerSymbol; symbolCount = 0; data = [||] }
        else
            let bits = ByteUtils.bitsChunkFromUint64 bitsPerSymbol symbols
                       |> Seq.toArray

            let data = ByteUtils.boolsToBytes bits |> Seq.toArray
            
            { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = data }



    let toSequenceOfUInt8 (bp: BytePack) : seq<uint8> =
        if bp.bitsPerSymbol > 8 then
            failwithf "bitsPerSymbol (%d) exceeds uint8 capacity (8 bits)" bp.bitsPerSymbol
        toSequenceOfUInt64 bp |> Seq.map uint8

    let fromSequenceOfUInt8 (uint8s: seq<uint8>) (bitsPerSymbol: int) : BytePack =
        if bitsPerSymbol > 8 then
            failwithf "bitsPerSymbol (%d) exceeds uint8 capacity (8 bits)" bitsPerSymbol
        fromSequenceOfUInt64 (uint8s |> Seq.map uint64) bitsPerSymbol

    let toSequenceOfUInt16 (bp: BytePack) : seq<uint16> =
        if bp.bitsPerSymbol > 16 then
            failwithf "bitsPerSymbol (%d) exceeds uint16 capacity (16 bits)" bp.bitsPerSymbol
        toSequenceOfUInt64 bp |> Seq.map uint16

    let fromSequenceOfUInt16 (uint16s: seq<uint16>) (bitsPerSymbol: int) : BytePack =
        if bitsPerSymbol > 16 then
            failwithf "bitsPerSymbol (%d) exceeds uint16 capacity (16 bits)" bitsPerSymbol
        fromSequenceOfUInt64 (uint16s |> Seq.map uint64) bitsPerSymbol

    let toSequenceOfUInt32 (bp: BytePack) : seq<uint32> =
        if bp.bitsPerSymbol > 32 then
            failwithf "bitsPerSymbol (%d) exceeds uint32 capacity (32 bits)" bp.bitsPerSymbol
        toSequenceOfUInt64 bp |> Seq.map uint32

    let fromSequenceOfUInt32 (uint32s: seq<uint32>) (bitsPerSymbol: int) : BytePack =
        if bitsPerSymbol > 32 then
            failwithf "bitsPerSymbol (%d) exceeds uint32 capacity (32 bits)" bitsPerSymbol
        fromSequenceOfUInt64 (uint32s |> Seq.map uint64) bitsPerSymbol
namespace GeneSort.Core

open System
open SysExt

module ByteUtils = 

    // Convert uint8 to binary string (8 bits)
    let uint8ToBinaryString (value: uint8) : string =
        let sb = System.Text.StringBuilder(8)
        for i = 7 downto 0 do
            sb.Append(if value.isset i then "1" else "0") |> ignore
        sb.ToString()

    // Convert uint16 to binary string (16 bits)
    let uint16ToBinaryString (value: uint16) : string =
        let sb = System.Text.StringBuilder(16)
        for i = 15 downto 0 do
            sb.Append(if value.isset i then "1" else "0") |> ignore
        sb.ToString()

    // Convert uint32 to binary string (32 bits)
    let uint32ToBinaryString (value: uint32) : string =
        let sb = System.Text.StringBuilder(32)
        for i = 31 downto 0 do
            sb.Append(if value.isset i then "1" else "0") |> ignore
        sb.ToString()

    // Convert uint64 to binary string (64 bits)
    let uint64ToBinaryString (value: uint64) : string =
        let sb = System.Text.StringBuilder(64)
        for i = 63 downto 0 do
            sb.Append(if value.isset i then "1" else "0") |> ignore
        sb.ToString()

    // creates a bit stream from a byte stream by selecting the first bitsPerSymbol bits,
    // but in MSB order
    let bitsFromBytes (bitsPerSymbol: int) (byteSeq: seq<byte>) =
        let _byteToBits (v: byte) =
            seq { for i = (bitsPerSymbol - 1) downto 0 do v.isset i }

        seq {
            for bite in byteSeq do
                yield! _byteToBits bite
        }

    // creates a bit stream from a uint64 stream by selecting the first bitsPerSymbol bits,
    // but in MSB order
    let bitsChunkFromUint64 (bitsPerSymbol: int) (int64Seq: seq<uint64>) =
        let _byteToBits (v: UInt64) =
            seq { for i = (bitsPerSymbol - 1) downto 0 do v.isset i }

        seq {
            for bite in int64Seq do
                yield! _byteToBits bite
        }

    let boolsToBytes (bools: seq<bool>) : seq<byte> =
        let boolList = bools |> Seq.toList
        let paddingNeeded = (8 - (boolList.Length % 8)) % 8
        let paddedBools = boolList @ List.replicate paddingNeeded false
        paddedBools
        |> Seq.chunkBySize 8
        |> Seq.map (fun chunk ->
            let mutable result = 0uy
            for i in 0 .. min 7 (chunk.Length - 1) do
                if chunk.[i] then
                    result <- result ||| (1uy <<< (7 - i))
            result)
namespace GeneSort.Core
open LanguagePrimitives
open System
open System.Collections
open System.Runtime.CompilerServices
open System.Collections.Generic

module CollectionUtils =

    /// Stores a sequence of values in a dictionary using a key generator function.
    /// If a dictionary is provided, updates it; otherwise, creates a new one.
    /// Throws an exception if a generated key already exists and allowOverwrite is false.
    let toDictionary 
            (allowOverwrite: bool) 
            (dict: Dictionary<'K, 'T> option) 
            (keyGen: 'T -> 'K) 
            (source: seq<'T>) : Dictionary<'K, 'T> =
        let resultDict = match dict with
                         | Some d -> d
                         | None -> Dictionary<'K, 'T>()
        for item in source do
            let key = keyGen item
            if not allowOverwrite && resultDict.ContainsKey key then
                failwithf "Duplicate key '%O' generated for item '%O'" key item
            resultDict.[key] <- item
        resultDict

    let rec compareAny 
                (o1: obj) 
                (o2: obj) 
        =
        match (o1, o2) with
        | (:? IComparable as o1), (:? IComparable as o2) -> Some(compare o1 o2)
        | (:? IEnumerable as arr1), (:? IEnumerable as arr2) ->
            Seq.zip (arr1 |> Seq.cast) (arr2 |> Seq.cast)
            |> Seq.choose (fun (a, b) -> compareAny a b)
            |> Seq.skipWhile ((=) 0)
            |> Seq.tryHead
            |> Option.defaultValue 0
            |> Some
        | (:? ITuple as tup1), (:? ITuple as tup2) ->
            let tupleToSeq (tuple: ITuple) =
                seq {
                    for i in 0 .. tuple.Length do
                        yield tuple.[i]
                }

            compareAny (tupleToSeq tup1) (tupleToSeq tup2)
        | _ -> None

    let areEqual (o1: obj) (o2: obj) =
        match compareAny o1 o2 with
        | Some v -> v = 0
        | None -> false


    // orderItems orders two items of a type that supports comparison.
    let inline orderItems< ^T when ^T : comparison> (x: ^T) (y: ^T) : ^T * ^T =
        if x <= y then (x, y) else (y, x)

    // Generic array equality check
    let inline arrayEquals< ^a when ^a: equality> (xs: ^a[]) (ys: ^a[]) : bool =
        if xs.Length <> ys.Length then false
        else
            let mutable i = 0
            let mutable equal = true
            while i < xs.Length && equal do
                equal <- xs.[i] = ys.[i]
                i <- i + 1
            equal


    //returns the last n items of the list in the original order
    let rec last n xs =
        if List.length xs <= n then xs else last n xs.Tail

    //returns the first n items of the list in the original order,
    //or all the items if it's shorter than n
    let first n (xs: 'a list) =
        let mn = min n xs.Length
        xs |> List.take mn

    let takeUpToOrWhile (n: int) (predicate: 'a -> bool) (source: seq<'a>) : seq<'a> =
        if n < 0 then
            invalidArg "n" "Number of items must be non-negative"
        Seq.takeWhile (fun x -> predicate x) (Seq.truncate n source)


    let flattenTupleSeq (tuples: seq<'T * 'T>) : seq<'T> =
        tuples |> Seq.collect (fun (x, y) -> [x; y])

    // filterByIndices filters a sequence by the specified indices.
    let filterByIndices (indices: int[]) (source: seq<'T>) : seq<'T> =
        source 
        |> Seq.indexed 
        |> Seq.filter (fun (i, _) -> Array.contains i indices)
        |> Seq.map snd

    // pairsWithNext can zip two sequences of unequal length
    let pairWithNext (source: seq<'a>) : seq<'a * ('a option)> =
        seq {
            let enumerator = source.GetEnumerator()
            while enumerator.MoveNext() do
                let current = enumerator.Current
                if enumerator.MoveNext() then
                    yield (current, Some enumerator.Current)
                else
                    yield (current, None)
        }

    // returns a sequence of items that occur more than once
    let itemsOccuringMoreThanOnce items =
        seq {
            let d = System.Collections.Generic.Dictionary()
            for i in items do
                match d.TryGetValue(i) with
                | false, _ -> d.[i] <- false // first observance
                | true, false ->
                    d.[i] <- true
                    yield i // second observance
                | true, true -> () // already seen at least twice
        }

    // filters the sequence, blocking the emission of a given value more than max times.
    let getItemsUpToMaxTimes<'k,'v when 'k:equality> 
            (lookup: 'v->'k)
            (max:int) 
            (items:'v seq)  =
        seq {
            let d = System.Collections.Generic.Dictionary()
            for i in items do
                let key = lookup i
                match d.TryGetValue(key) with
                | false, _ ->
                    d.[key] <- 1
                    yield i
                | true, ct ->
                    d.[key] <- ct + 1
                    if (ct < max) then
                        yield i
        }

    // chunks a sequence by powers of two, starting with a given multiple.
    let chunkByPowersOfTwo (startingMultiple:int) 
                           (source: seq<'T>) : seq<seq<'T>> =
        let rec chunk (src: 'T list) power : seq<seq<'T>> =
            if src.IsEmpty then
                Seq.empty
            else
                let chunkSize = (1 <<< power) * startingMultiple
                let fp, sp =
                    if src.Length <= chunkSize then
                        src, []
                    else
                        List.splitAt chunkSize src
                seq {
                    yield fp |> Seq.ofList
                    yield! (chunk sp (power + 1))
                }
    
        chunk (source |> Seq.toList) 0


    // converts a density distr to a cumulative distr.
    let asCumulative (startVal: float) (weights: float[]) =
        weights |> Array.scan (fun cum cur -> cum + cur) startVal


    // a sequence of int*int where snd - fst = offset, and snd < order
    let steppedOffsetPairs start order offset =
        // Validate inputs: n must be positive, k must be positive and less than n
        if order <= 0 || offset <= 0 || offset >= order then
            Seq.empty
        else
            seq {
                let mutable kk = 0
                let mutable i = start
                while i < order - offset do
                    yield (i, i + offset)
                    kk <- kk + 1
                    i <- i + 1
                    if (kk = offset) then
                        kk <- 0
                        i <- i + offset
            }
    // circularzes and rotates a list so that the minimum element comes first.
    let rotateToMin (xs: int list) : int list =
        match xs with
        | [] -> []
        | _ ->
            let minIndex = xs |> List.indexed |> List.minBy snd |> fst
            let beforeMin, afterMin = xs |> List.splitAt minIndex
            afterMin @ beforeMin
namespace GeneSort.Core
open FSharp.UMX
open System

module Combinatorics =

    // For deterministic testing
    let indexPicker (indices: int[]) : int -> int =
        let mutable counter = 0
        fun _ ->
            let result = indices.[counter % indices.Length]
            counter <- counter + 1
            result

    // For deterministic testing
    let floatPicker (values: float[]) : unit -> float =
        let mutable counter = 0
        fun () ->
            let result = values.[counter % values.Length]
            counter <- counter + 1
            result


    /// Reflects a value across a modulus, computing modulus - value - 1.
    /// <param name="modulus">The modulus for reflection (must be positive).</param>
    /// <param name="value">The value to reflect (must be non-negative and less than modulus).</param>
    /// <returns>The reflected value.</returns>
    /// <exception cref="System.ArgumentException">Thrown when modulus is non-positive or value is invalid.</exception>
    let reflect (modulus: int) (value: int) : int =
        if modulus <= 0 then invalidArg "modulus" "Modulus must be positive"
        if value < 0 || value >= modulus then invalidArg "value" "Value must be non-negative and less than modulus"
        modulus - value - 1


    /// Computes the 2D Cartesian product of two sequences, yielding all possible pairs.
    /// <param name="seq_a">The first sequence.</param>
    /// <param name="seq_b">The second sequence.</param>
    /// <returns>A sequence of tuples representing all pairs (a, b).</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when either sequence is null.</exception>
    let cartesianProduct2d (seq_a: seq<'a>) (seq_b: seq<'b>) =
        if isNull seq_a then invalidArg "seq_a" "Sequence cannot be null"
        if isNull seq_b then invalidArg "seq_b" "Sequence cannot be null"
        seq {  
            for ae in seq_a do
                for be in seq_b do
                    yield (ae, be)
        }


    /// Computes the Cartesian product of a list of lists, yielding all possible combinations.
    /// <param name="lists">A list of sequences to combine.</param>
    /// <returns>A sequence of lists representing all combinations.</returns>
    let rec cartesianProduct (lists: list<list<'a>>) : 'a list seq =
        match lists with
        | [] -> Seq.empty<'a list>
        | [single] ->
            seq { for x in single do yield [x] }
        | hd::tl ->
            seq { for x in hd do
                    for rest in cartesianProduct tl do
                        yield x :: rest }


    //[<Measure>] type key
    //[<Measure>] type description
    ///// Computes the Cartesian product of a list of key-value pairs, yielding all possible maps.
    //let rec cartesianProductMaps<'a when 'a : comparison> (lists: list<string<key> * list<string<description> * 'a>>) 
    //                : Map<string<key>, string<description> * 'a> seq =
    //    match lists with
    //    | [] -> Seq.empty<Map<string<key>, string<description> * 'a>>
    //    | [(key, values)] ->
    //        seq { for value in values do yield Map.ofList [(key, value)] }
    //    | (key, values)::tl ->
    //        seq {
    //            for value in values do
    //                for restMap in cartesianProductMaps tl do
    //                    yield Map.add key value restMap
    //        }

    ///// Finds the index of a map in a list of maps generated by cartesianProductMaps.
    //let findMapIndex<'a when 'a : comparison> (map: Map<string<key>, string<description> * 'a>) (lists: list<string<key> * list<string<description> * 'a>>) 
    //                    : int option =
    //    let targetSeq = Map.toSeq map |> Set.ofSeq
    //    cartesianProductMaps lists
    //    |> Seq.tryFindIndex (fun m -> Map.toSeq m |> Set.ofSeq = targetSeq)



    /// Computes the Cartesian product of a list of key-value pairs, yielding all possible maps.
    let rec cartesianProductMaps (lists: list<string * list<string>>) : Map<string, string> seq =
        match lists with
        | [] -> Seq.empty<Map<string, string>>
        | [(key, values)] ->
            seq { for value in values do yield Map.ofList [(key, value)] }
        | (key, values)::tl ->
            seq {
                for value in values do
                    for restMap in cartesianProductMaps tl do
                        yield Map.add key value restMap
            }

    /// Finds the index of a map in a list of maps generated by cartesianProductMaps.
    let findMapIndex (map: Map<string, string>) (lists: list<string * list<string>>) 
                        : int option =
        let targetSeq = Map.toSeq map |> Set.ofSeq
        cartesianProductMaps lists
        |> Seq.tryFindIndex (fun m -> Map.toSeq m |> Set.ofSeq = targetSeq)


    /// Generates a binomial random variable by simulating trials.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="trials">The number of trials (must be non-negative).</param>
    /// <param name="probability">The success probability (must be in [0,1]).</param>
    /// <returns>The number of successes.</returns>
    /// <exception cref="System.ArgumentException">Thrown when trials or probability is invalid.</exception>
    let binomialSample (floatPicker: unit -> float) (trials: int) (probability: float) : int =
        if trials < 0 then invalidArg "trials" "Number of trials must be non-negative"
        if probability < 0.0 || probability > 1.0 then invalidArg "probability" "Probability must be between 0 and 1"
        let mutable successes = 0
        for _ in 1 .. trials do
            if floatPicker() < probability then
                successes <- successes + 1
        successes


    /// Generates a binomial random variable using normal approximation for large trials.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="trials">The number of trials (must be non-negative).</param>
    /// <param name="probability">The success probability (must be in [0,1]).</param>
    /// <returns>The number of successes.</returns>
    /// <exception cref="System.ArgumentException">Thrown when trials or probability is invalid.</exception>
    let binomialSampleWithApprox (floatPicker: unit -> float) (trials: int) (probability: float) : int =
        if trials < 0 then invalidArg "trials" "Number of trials must be non-negative"
        if probability < 0.0 || probability > 1.0 then invalidArg "probability" "Probability must be between 0 and 1"
        let np = float trials * probability
        let npq = np * (1.0 - probability)
        if trials > 500 && np > 5.0 && npq > 5.0 then
            let stdDev = sqrt npq
            // Improved normal random variable using Box-Muller (simplified)
            let u1 = floatPicker()
            let u2 = floatPicker()
            let normal = sqrt (-2.0 * log u1) * cos (2.0 * System.Math.PI * u2)
            let normalSample = np + stdDev * normal
            max 0 (min trials (int (round normalSample)))
        else
            let mutable successes = 0
            for _ in 1 .. trials do
                if floatPicker() < probability then
                    successes <- successes + 1
            successes


    /// Performs a Fisher-Yates shuffle, yielding a sequence of shuffled items.
    /// <param name="indexShuffler">A function generating random indices in [0, nLeft).</param>
    /// <param name="initialList">The input array to shuffle.</param>
    /// <returns>A sequence of shuffled items.</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when initialList is null.</exception>
    /// <exception cref="System.ArgumentException">Thrown when indexShuffler returns an invalid index.</exception>
    let fisherYatesShuffle (indexShuffler: int -> int) 
                           (initialList: 'a array) : 'a seq =
        let availableFlags = Array.init initialList.Length (fun i -> (i, true))
    
        let nextItem nLeft =
            let nItem = indexShuffler nLeft // Random index from remaining items
            let index =
                availableFlags
                |> Array.filter (fun (_, flag) -> flag)
                |> Array.item nItem
                |> fst
            availableFlags.[index] <- (index, false) // Mark as used
            initialList.[index]
    
        seq { for n in initialList.Length .. -1 .. 1 -> nextItem n }


    /// Picks two distinct numbers from 0 to n-1 and returns them in ascending order.
    /// <param name="indexPicker">A function generating random indices in [0, n).</param>
    /// <param name="n">The range of indices (must be at least 2).</param>
    /// <returns>A tuple of two distinct indices in ascending order.</returns>
    /// <exception cref="System.ArgumentException">Thrown when n is less than 2 or indexPicker returns invalid indices.</exception>
    let pickAndOrderTwoDistinct (indexPicker: int -> int) (n: int) : int * int =
        if n < 2 then invalidArg "n" "n must be at least 2 to pick two distinct numbers"
        let first = indexPicker n
        if first < 0 || first >= n then invalidArg "indexPicker" $"First index {first} out of range [0, {n})"
        let second = 
            let rec pickDistinct () =
                let candidate = indexPicker n
                if candidate < 0 || candidate >= n then invalidArg "indexPicker" $"Second index {candidate} out of range [0, {n})"
                if candidate <> first then candidate
                else pickDistinct ()
            pickDistinct ()
        if first < second then (first, second) else (second, first)


    /// Picks three distinct numbers from 0 to n-1 and returns them in ascending order.
    /// <param name="indexPicker">A function generating random indices in [0, n).</param>
    /// <param name="n">The range of indices (must be at least 3).</param>
    /// <returns>A tuple of three distinct indices in ascending order.</returns>
    /// <exception cref="System.ArgumentException">Thrown when n is less than 3 or indexPicker returns invalid indices.</exception>
    let pickAndOrderThreeDistinct (indexPicker: int -> int) (n: int) : int * int * int =
        // Validate input
        if n < 3 then
            failwith "n must be at least 3 to pick three distinct numbers"
        
        // Pick the first number
        let first = indexPicker n
        
        // Pick a second number, ensuring it's distinct from the first
        let second =
            let rec pickDistinctFromFirst () =
                let candidate = indexPicker n
                if candidate <> first then candidate
                else pickDistinctFromFirst ()
            pickDistinctFromFirst ()
        
        // Pick a third number, ensuring it's distinct from both first and second
        let third =
            let rec pickDistinctFromFirstAndSecond () =
                let candidate = indexPicker n
                if candidate <> first && candidate <> second then candidate
                else pickDistinctFromFirstAndSecond ()
            pickDistinctFromFirstAndSecond ()
        
        // Sort the three numbers in ascending order
        let numbers = [first; second; third] |> List.sort
        (numbers.[0], numbers.[1], numbers.[2])


    /// Picks items without replacement from an array, filtering based on a chooser function.
    /// <param name="indexShuffler">A function generating random indices for shuffling.</param>
    /// <param name="chooser">A function determining whether to include an item.</param>
    /// <param name="initialList">The input array.</param>
    /// <returns>A sequence of selected items.</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when initialList is null.</exception>
    let pickWithoutReplacement (indexShuffler: int -> int) (chooser: unit -> bool) (initialList: 'a array) : 'a seq =
        if isNull initialList then invalidArg "initialList" "Array cannot be null"
        let shuffled = initialList |> fisherYatesShuffle indexShuffler
        seq {
            for sh in shuffled do
                if chooser() then
                    yield sh
        }


    /// Generates a sequence of items sampled with replacement based on weights, optimized for long lists.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="items">A list of (item, weight) pairs, where weights are non-negative.</param>
    /// <returns>An infinite sequence of sampled items.</returns>
    /// <exception cref="System.ArgumentException">Thrown when items is empty or weights are invalid.</exception>
    let pickWithReplacementLong (floatPicker: unit -> float) (items: ('a * float) list) : seq<'a> =
        if items.IsEmpty then invalidArg "items" "Item list cannot be empty"
        let weights = items |> List.map snd
        if weights |> List.exists (fun w -> w < 0.0) then invalidArg "items" "Weights must be non-negative"
        let totalWeight = weights |> List.sum
        if totalWeight <= 0.0 then invalidArg "items" "Total weight must be positive"
        let cumulativeWeights = 
            weights 
            |> List.scan (+) 0.0 
            |> List.tail 
            |> Array.ofList
        let itemArray = items |> List.map fst |> Array.ofList
        let findIndex r =
            let rec binarySearch low high =
                if low >= high then low
                else
                    let mid = (low + high) / 2
                    if cumulativeWeights.[mid] >= r then binarySearch low mid
                    else binarySearch (mid + 1) high
            binarySearch 0 (Array.length cumulativeWeights)
        seq {
            while true do
                let r = floatPicker() * totalWeight
                yield itemArray.[findIndex r]
        }


    /// Generates a sequence of items sampled with replacement based on weights, optimized for short lists.
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <param name="items">A list of (item, weight) pairs, where weights are non-negative.</param>
    /// <returns>An infinite sequence of sampled items.</returns>
    /// <exception cref="System.ArgumentException">Thrown when items is empty or weights are invalid.</exception>
    let pickWithReplacementShort (floatPicker: unit -> float) (items: ('a * float) list) : seq<'a> =
        if items.IsEmpty then failwith "Empty list"
        if (items |> List.forall (fun tup -> (snd tup ) < 0)) then
            failwith "weights must all be positive"
        let totalWeight = items |> List.sumBy snd
        if totalWeight = 0 then
            failwith "all weights cannot be zero"

        seq {
            while true do
                let r = floatPicker() * totalWeight
                let rec select acc weightSum =
                    match acc with
                    | [] -> failwith "Unexpected empty list"
                    | (item, weight) :: rest ->
                        if weightSum + weight >= r then item
                        else select rest (weightSum + weight)
                yield select items 0.0
        }

    /// Picks a single item from a weighted array.
    /// <param name="items">An array of (item, weight) pairs, where weights are non-negative.</param>
    /// <param name="floatPicker">A function generating random floats in [0,1).</param>
    /// <returns>A randomly selected item based on weights.</returns>
    /// <exception cref="System.ArgumentException">Thrown when items is empty or weights are invalid.</exception>
    let pick (items: ('a * float)[]) (floatPicker: unit -> float) : 'a =
        if items.Length = 0 then invalidArg "items" "Item list cannot be empty"
        if items |> Array.exists (fun (_, w) -> w < 0.0) then invalidArg "items" "Weights must be non-negative"
        let totalWeight = items |> Array.sumBy snd
        if totalWeight <= 0.0 then invalidArg "items" "Total weight must be positive"
        let r = floatPicker() * totalWeight
        let mutable weightSum = 0.0
        let mutable selectedItem = fst items.[items.Length - 1] // Fallback to last item
        let mutable i = 0
        while i < items.Length && weightSum <= r do
            let (item, weight) = items.[i]
            weightSum <- weightSum + weight
            if weightSum >= r then
                selectedItem <- item
            i <- i + 1
        selectedItem




namespace GeneSort.Core
open Permutation

module CoreGen =


    let randomPermutations (order:int) (randy:IRando) : seq<Permutation> =
        seq {
                while true do
                    yield randomPermutation (fun n -> randy.NextIndex n) order
            }


    let randomSaturatedPerm_Si (order:int) (randy:IRando) : seq<Perm_Si> =
        let baseTwoCycle = Perm_Si.saturatedWithTwoCycles order
        seq {
                while true do
                    let conj = randomPermutation (fun n -> randy.NextIndex n) order
                    yield Perm_Si.conjugate baseTwoCycle conj
            }

            
    let randomUnSaturatedPerm_Si (order:int) (cycleCount:int) (randy:IRando) : seq<Perm_Si> =
        let baseTwoCycle = Perm_Si.unSaturatedWithTwoCycles order cycleCount
        seq {
                while true do
                    let conj = randomPermutation (fun n -> randy.NextIndex n) order
                    yield Perm_Si.conjugate baseTwoCycle conj
            }


    let randomUnSaturatedPerm_Rs (order:int) (randy:IRando) : seq<Perm_Si> =
        randomPermutations order randy 
                |> Seq.map (fun p -> p |> PermRsGen_old.decodePermutation)


    let randomSaturatedPerm_Rs (order:int) (randy:IRando) : seq<Perm_Si> =
        seq {
                while true do
                    yield PermRsGen_old.rndSymmetric order randy
            }
namespace GeneSort.Core

open System.IO
open System.Security.Cryptography

module GuidUtils = 

    // structural equality
    let hashObjs (oes: obj seq) =
        use stream = new MemoryStream()
        use writer = new BinaryWriter(stream)
        oes |> Seq.iter (fun o -> writer.Write(sprintf "%A" o))
        let md5 = MD5.Create()
        md5.ComputeHash(stream.ToArray())

    // structural equality
    let guidFromObjs (objs: seq<obj>) = 
        System.Guid(hashObjs objs)
namespace GeneSort.Core

open SysExt

module MathUtils = 

    /// Computes  (toM)^power, where toM is an integer and power is a non-negative integer.
    let integerPower (toM:int) (power:int) =
        pown toM power

    /// Verifies if an integer is an exact power of two and returns its base-2 logarithm.
    /// Throws ArgumentException if n <= 0, or if n is not an exact power of 2.
    let exactLog2 (n: int) : int =
        if n <= 0 then
            invalidArg "n" "Input must be positive"
        // Check if n is a power of two: n & (n - 1) = 0
        if n &&& (n - 1) = 0 then
            // Compute log2 by counting trailing zeros (position of the set bit)
            let rec countTrailingZeros num count =
                if num = 0 then count
                else countTrailingZeros (num >>> 1) (count + 1)

            countTrailingZeros (n >>> 1) 0
        else
            invalidArg "n" "Input must be an exact power of 2"


    /// Determines if a number is a power of two.
    /// <param name="order">The number to check (must be positive).</param>
    /// <returns>True if the number is a power of two, false otherwise.</returns>
    /// <exception cref="System.ArgumentException">Thrown when order is non-positive.</exception>
    let isAPowerOfTwo (order: int) : bool =
        if order <= 0 then invalidArg "order" "Order must be positive"
        order > 0 && (order &&& (order - 1)) = 0
namespace GeneSort.Core

open System
open Combinatorics

[<CustomEquality; NoComparison>]
type Orbit = private Orbit of indices: int list with
    // Static method to create an Orbit, validating input
    static member create (indices: int list) : Orbit =
        // Validate non-negative indices
        if indices |> List.exists (fun i -> i < 0) then
            failwith "Orbit indices must be non-negative"
        // Validate unique indices
        let distinctIndices = indices |> List.distinct
        if List.length distinctIndices <> List.length indices then
            failwith "Orbit indices must be unique"
        // Find the smallest index and its position
        if indices.IsEmpty then
            Orbit []
        else
            let minIndex = indices |> List.min
            let minPos = indices |> List.findIndex (fun i -> i = minIndex)
            // Rotate the list so the smallest index is at position 0
            let rotated =
                indices.[minPos .. List.length indices - 1] @ indices.[0 .. minPos - 1]
            Orbit rotated

    // Property to access the orbit's indices
    member this.Indices =
        match this with
        | Orbit indices -> indices

    // Check if two orbits are equal (based on normalized indices)
    member this.Equals (other: Orbit) =
        this.Indices = other.Indices

    // Override for object equality
    override this.Equals (obj: obj) =
        match obj with
        | :? Orbit as other -> this.Equals other
        | _ -> false

    // Override GetHashCode for consistency with Equals
    override this.GetHashCode () =
        // Use a simple hash based on sorted indices for consistency
        this.Indices
        |> List.fold (fun acc i -> (acc * 397) ^^^ i) 0

    // Implement IEquatable<Orbit> for structural equality
    interface IEquatable<Orbit> with
        member this.Equals (other: Orbit) = this.Equals other

module Orbit =

    // returns a reflection of the orbit about (order - 1) / 2
    let getReflection (order: int) (orbit: Orbit) : Orbit =
        // Reflect each index in the orbit
        let reflectedIndices = orbit.Indices |> List.map (fun i -> order - 1 - i)
        // Create a new Orbit from the reflected indices
        Orbit.create reflectedIndices

    let isReflectionSymmetric (order: int) (orbit: Orbit) =
        (orbit.Indices.[0] |> reflect order) = (orbit.Indices.[1])
namespace GeneSort.Core

open System
open GeneSort.Core.Orbit
open CollectionUtils

[<CustomEquality; NoComparison>]
type OrbitSet = private OrbitSet of orbits: Orbit list * order: int with
    // Static method to create an OrbitSet, validating input
    static member create (orbits: Orbit list) (order: int) : OrbitSet =
        if orbits.Length < 1 then
            failwith "orbits cannot be empty"
        if order < 0 then
            failwith "OrbitSet order must be non-negative"
        // Validate disjointness and coverage
        let allIndices = 
            orbits 
            |> List.collect (fun orbit -> orbit.Indices)
        let allUniqueIndices = 
            allIndices 
            |> Set.ofList
        if Set.count allUniqueIndices <> allIndices.Length then
            failwith "Orbits must be disjoint"
        if Set.count allUniqueIndices <> order || not (List.forall (fun i -> Set.contains i allUniqueIndices) [0 .. order-1]) then
            failwith "Orbits must cover indices 0 to order-1"
        let sortedOrbits = orbits |> List.sortBy (fun orbit -> orbit.Indices.[0])
        OrbitSet (sortedOrbits, order)

        // Property to access the orbits
        member this.Orbits =
            match this with
            | OrbitSet (orbits, _) -> orbits

        // Property to access the order
        member this.Order =
            match this with
            | OrbitSet (_, order) -> order

        // Check if two OrbitSets are equal
        member this.Equals (other: OrbitSet) =
            this.Orbits = other.Orbits && this.Order = other.Order

        // Override for object equality
        override this.Equals (obj: obj) =
            match obj with
            | :? OrbitSet as other -> this.Equals other
            | _ -> false

        // Override GetHashCode for consistency with Equals
        override this.GetHashCode () =
            let orbitHash = 
                this.Orbits
                |> List.map (fun orbit -> orbit.GetHashCode())
                |> List.fold (fun acc h -> (acc * 397) ^^^ h) 0
            (orbitHash * 397) ^^^ this.Order

        // Implement IEquatable<OrbitSet> for structural equality
        interface IEquatable<OrbitSet> with
            member this.Equals (other: OrbitSet) = this.Equals other



module OrbitSet =

    // Helper to print permutation in orbit notation, including fixed points
    let toOrbitNotation (orbitSet: OrbitSet) : string =
        let orbits = orbitSet.Orbits
        let orbitString = 
            orbits 
            |> List.map (fun orbit -> "(" + (orbit.Indices |> List.map string |> String.concat " ") + ")")
            |> String.concat ""
        if orbitString = "" then "()" else orbitString


    /// Finds all orbits (for all lengths including fixed points) that are either 
    /// their own reflection or have a reflection partner orbit. 
    let getReflectionPartnerOrbits (orbitSet: OrbitSet) =
        let reflected = orbitSet.Orbits
                        |> List.map(getReflection orbitSet.Order)
        let combo = orbitSet.Orbits |> List.append reflected
        let dupes = combo 
                    |> List.groupBy(id) 
                    |> List.filter(fun (k, g) -> g.Length = 2)
                    |> List.sortBy(fun (k, _) -> k.Indices.[0])
                    |> List.map fst
        dupes




namespace GeneSort.Core

open System.Security.Cryptography
open System
open CollectionUtils
open Combinatorics
open FSharp.UMX

[<Measure>] type Order

// Permutation type as a single-case discriminated union with Guid Id
type Permutation = private Permutation of arr: int array * id: Guid ref with
    // Compute Guid from int array
    static member private ComputeGuid (arr: int array) : Guid =
        use sha256 = SHA256.Create()
        // Convert int array to byte array (4 bytes per int, little-endian)
        let bytes = Array.zeroCreate (arr.Length * 4)
        Buffer.BlockCopy(arr, 0, bytes, 0, arr.Length * 4)
        // Compute SHA256 hash and take first 16 bytes for Guid
        let hash = sha256.ComputeHash(bytes)
        Guid(hash.[0..15])

    // Static method to create a permutation, validating input
    static member create (arr: int array) : Permutation =
        let n = Array.length arr
        if n = 0 then
            failwith "array cannot be empty"
        let sorted = Array.sort arr
        let isValid = Array.forall2 (fun i v -> i = v) [|0 .. n-1|] sorted
        if not isValid then
            failwith "Invalid permutation: must contain each integer from 0 to n-1 exactly once"
        Permutation (arr, ref Guid.Empty)

    static member createUnsafe (arr: int array) : Permutation =
        Permutation (arr, ref Guid.Empty)

    // Property to access the underlying array
    member this.Array =
        match this with
        | Permutation (arr, _) -> arr

    // Property to access or compute the Id
    member this.Id
        with get () =
            match this with
            | Permutation (arr, idRef) ->
                if !idRef = Guid.Empty then
                    idRef := Permutation.ComputeGuid arr
                !idRef

    member this.Order =
        UMX.tag<Order> this.Array.Length

    member this.equals (other: Permutation) : bool =
            this.Array.Length = other.Array.Length &&
            arrayEquals this.Array other.Array


module Permutation =
    // Create identity permutation of order n
    let identity (order: int) : Permutation =
        if order <= 0 then
            failwith "Permutation order must be positive"
        Permutation.create [|0 .. order-1|]


    let isIdentity (permutation: Permutation) : bool =
        let arr = permutation.Array
        let mutable isIdentity = true
        let mutable i = 0
        while i < arr.Length && isIdentity do
            if arr.[i] <> i then
                isIdentity <- false
            i <- i + 1
        isIdentity


    // returns a random Permutation by shuffling the identity Permutation
    let randomPermutation (indexShuffler: int -> int) (order: int) : Permutation =
        let initialPerm = identity order
        let shuffled = fisherYatesShuffle indexShuffler initialPerm.Array
                       |> Seq.toArray
        Permutation.createUnsafe shuffled

    // Returns a "rotated" identity permutation of given by k positions (positive k for left, negative for right)
    let rotated (k: int) (order:int) : Permutation =
        let arr = (identity order).Array
        if order <= 0 then
            failwith "Permutation order must be positive"
        let k = k % order // Normalize k to avoid unnecessary cycles
        let k = if k < 0 then k + order else k // Handle negative k
        Permutation.createUnsafe (Array.init order (fun i -> arr.[(i + k + order) % order]))

    // Compose two permutations: applies p1 then p2 (p2 ∘ p1)
    let compose (p1: Permutation) (p2: Permutation) : Permutation =
        let arr1 = p1.Array
        let arr2 = p2.Array
        if Array.length arr1 <> Array.length arr2 then
            failwith "Permutations must have the same order"
        Permutation.createUnsafe (Array.init (Array.length arr1) (fun i -> arr2.[arr1.[i]]))
        
    let isSelfInverse (perm: Permutation) : bool =
        let arr = perm.Array
        let n = Array.length arr
        let composed = compose perm perm
        composed.Array = (identity n).Array

    // Inverse of a permutation
    let inverse (perm: Permutation) : Permutation =
        let arr = perm.Array
        let n = Array.length arr
        let inv = Array.zeroCreate n
        for i in 0 .. n-1 do
            inv.[arr.[i]] <- i
        Permutation.createUnsafe inv

    // Conjugate a permutation: q^-1 ∘ p ∘ q
    let conjugate (p: Permutation) (q: Permutation) : Permutation =
        let arr1 = p.Array
        let arr2 = q.Array
        if Array.length arr1 <> Array.length arr2 then
            failwith "Permutations must have the same order"
        compose (compose (inverse q) p) q


    // Returns an array of indices where the permutation fixes the element (perm[i] = i)
    let getFixedPoints (perm: Permutation) : int array =
        perm.Array
        |> Array.indexed
        |> Array.filter (fun (i, x) -> i = x)
        |> Array.map fst

    // Helper to print permutation in array notation
    let toArrayNotation (perm: Permutation) : string =
        sprintf "[%s]" (perm.Array |> Array.map string |> String.concat "; ")


    /// Converts an OrbitSet to a Permutation.
    /// The orbits must cover indices from 0 to order-1.
    let fromOrbitSet (orbitSet:OrbitSet) : Permutation =
        let indices = 
            orbitSet.Orbits 
            |> List.collect (fun orbit -> orbit.Indices)
            |> List.distinct
            |> List.sort
            |> Array.ofList
        let order = indices.Length
        if (not (arrayEquals indices (Array.init order id))) then
            failwith "Orbits must cover indices 0 to order-1"
        let permArray = Array.zeroCreate order
        for orbit in orbitSet.Orbits do
            let indices = orbit.Indices
            if indices.Length > 0 then
                for i in 0 .. indices.Length - 2 do
                    permArray.[indices.[i]] <- indices.[i + 1]
                permArray.[indices.[indices.Length - 1]] <- indices.[0]
        Permutation.create permArray


        
    // Find orbits of the elements of a permutation, including fixed points
    let toOrbitSet (perm: Permutation) : OrbitSet =
        let arr = perm.Array
        let n = Array.length arr
        let visited = Array.create n false
        let rec buildOrbit current orbit =
            if visited.[current] then orbit
            else
                visited.[current] <- true
                if orbit |> List.head = current then
                    buildOrbit arr.[current] orbit
                else
                    buildOrbit arr.[current] (current :: orbit)
        let rec findOrbits i acc =
            if i >= n then acc
            elif visited.[i] then findOrbits (i + 1) acc
            else
                let orbitIndices = buildOrbit i [i] |> List.rev
                let orbit = Orbit.create orbitIndices
                findOrbits (i + 1) (orbit :: acc)
        OrbitSet.create (List.rev (findOrbits 0 [])) n
namespace GeneSort.Core

open Permutation
module PermutationSets =

    // Get the sequence of powers p, p^2, ..., e (identity)
    let makeCyclicGroup (perm: Permutation) : Permutation seq =
        let arr = perm.Array
        let n = Array.length arr
        let id = identity n
        let rec generatePowers (current: Permutation) acc =
            if current.Array = id.Array then
                seq { yield! acc; yield current }
            else
                let next = compose current perm
                generatePowers next (seq { yield! acc; yield current })
        generatePowers perm Seq.empty
namespace GeneSort.Core
open FSharp.UMX
open Combinatorics

// Perm_Rs type: a permutation that is its own inverse (p ∘ p = identity)
// Is reflection symmetric, and has an order that is divisible by 4.
type Perm_Rs = private Perm_Rs of Perm_Si with
    // Static method to create a Perm_Rs, validating self-inverse property
    static member create (arr: int array) : Perm_Rs =
        if arr.Length < 4 then
            failwith "Perm_Rs order must be at least 4"
        if arr.Length % 2 <> 0 then
            failwith "Perm_Rs order must be divisible by 2"
        let perm_Si = Perm_Si.create arr
        if not (Perm_Si.isReflectionSymmetric perm_Si) then
            failwith "Invalid Perm_Rs: permutation must be self-inverse"
        Perm_Rs perm_Si

    // Static method to create a Perm_Rs, validating self-inverse property
    static member createUnsafe (arr: int array) : Perm_Rs =
        let perm = Perm_Si.createUnsafe arr
        Perm_Rs perm

    // Property to access the underlying permutation
    member this.Permutation
        with get () =
            match this with
            | Perm_Rs perm -> perm.Permutation

    // Property to access the underlying Perm_Si
    member this.Perm_Si
        with get () =
        match this with
        | Perm_Rs perm_rs -> perm_rs

    member this.Id
        with get () =
            match this with
            | Perm_Rs perm -> perm.Id

    member this.Order
        with get () =
            match this with
            | Perm_Rs perm -> perm.Order
             
    member this.Array
        with get () =
            match this with
            | Perm_Rs perm -> perm.Array

    member this.equals (other: Perm_Rs) : bool =
            this.Permutation.equals(other.Permutation)
namespace GeneSort.Core
open Combinatorics


type orbitRS_old =
    | Single of int * int
    | Unreflectable of int * int
    | Pair of (int * int) * (int * int)
    | LeftOver of int * int


module OrbitRS_old =

    let getIndexes (rfls: orbitRS_old) =
        match rfls with
        | Single (i, j)         ->  seq {i; j }
        | Unreflectable (i, j)  ->  seq { i; j }
        | Pair ((h, i), (j, k)) ->  seq { h; i; j; k }
        | LeftOver (i, j)       ->  seq { i; j }

    let writeToArray (aRet:int array) (rfls: orbitRS_old) =
        match rfls with
        | Single (i, j) ->
            aRet.[i] <- j
            aRet.[j] <- i

        | Unreflectable (i, j) ->
            aRet.[i] <- j
            aRet.[j] <- i

        | Pair ((h, i), (j, k)) ->
            aRet.[i] <- h
            aRet.[h] <- i
            aRet.[j] <- k
            aRet.[k] <- j

        | LeftOver (i, j) ->
            aRet.[i] <- j
            aRet.[j] <- i


    //makes reflective pairs to fill up order slots.
    let rndReflectivePairs (order: int) (rnd: IRando) =

        let flagedArray = Array.init order (fun i -> (i, true))

        let _availableFlags () = flagedArray |> Seq.filter (fun (_, f) -> f)

        let _canContinue () = _availableFlags () |> Seq.length > 1

        let _nextItem () =
            let nItem =  rnd.NextIndex (_availableFlags () |> Seq.length)
            let index = _availableFlags () |> Seq.item (int nItem) |> fst
            flagedArray.[index] <- (index, false)
            index

        let _getReflection (a: int) (b: int) =
            let aR = reflect order a
            let bR = reflect order b

            if (snd flagedArray.[aR]) && (snd flagedArray.[bR]) then
                flagedArray.[aR] <- (aR, false)
                flagedArray.[bR] <- (bR, false)
                Some(bR, aR)
            else
                None

        let _nextItems () =
            let nItemA = _nextItem ()
            let nItemB = _nextItem ()

            if nItemA = (reflect order nItemB) then
                (nItemA, nItemB) |> orbitRS_old.Single
            // if one of the nodes is on the center line, then make a (non-reflective)
            // pair out of them
            else if (nItemA = (reflect order nItemA)) || (nItemB = (reflect order nItemB)) then
                (nItemA, nItemB) |> orbitRS_old.Unreflectable
            else
                let res = _getReflection nItemA nItemB

                match res with
                | Some (reflA, reflB) -> ((nItemA, nItemB), (reflA, reflB)) |> orbitRS_old.Pair
                // if a reflective pair cannot be made from these two, then
                // make them into a (non-reflective) pair
                | None -> (nItemA, nItemB) |> orbitRS_old.LeftOver

        seq {
            while _canContinue () do
                yield _nextItems ()
        }

// This models reflection symmetric sorter steps
module PermRsGen_old =

    // Contains no fixed points, for even order
    let rndSymmetric (order: int) (rnd: IRando) =
        let aRet = Array.init order (id)

        OrbitRS_old.rndReflectivePairs order rnd |> Seq.iter (OrbitRS_old.writeToArray aRet)
        Perm_Si.create aRet


    // Creates a TwoCycleRS, often containing lots of fixed points
    let decodePermutation (permutation: Permutation) : Perm_Si =
        let permLength = permutation.Array.Length
        let availableFlags = Array.init permLength (fun i -> true)
        let arrayRS = Array.init<int> permLength (fun i -> i)

        let _getReflections (a:int) (b:int) : seq<int*int> =
            if (availableFlags.[a] && availableFlags.[b]) then
                if b = reflect permLength a then
                  availableFlags.[a] <- false
                  availableFlags.[b] <- false
                  seq {(a, b)}
                else
                  let ar = reflect permLength a
                  let br = reflect permLength b
                  if (availableFlags.[ar] && availableFlags.[br]) then
                      availableFlags.[a] <- false
                      availableFlags.[b] <- false
                      availableFlags.[ar] <- false
                      availableFlags.[br] <- false
                      seq {(a, b); (ar, br)}
                  else
                      Seq.empty
            else
                Seq.empty

        for dex = 0 to permLength - 1 do
            let pairs = _getReflections dex permutation.Array.[dex]
            for (a, b) in pairs do
                arrayRS.[a] <- b
                arrayRS.[b] <- a

        let perm_Rs = Perm_Si.createUnsafe arrayRS
        if not (Permutation.isSelfInverse perm_Rs.Permutation) then
            failwith "Invalid TwoCycleRS: permutation must be self-inverse"
        if not (Perm_Si.isReflectionSymmetric perm_Rs) then
            failwith "Invalid TwoCycleRS: permutation must be reflection-symmetric"
        Perm_Si.createUnsafe perm_Rs.Array


namespace GeneSort.Core
open GeneSort.Core.Permutation
open CollectionUtils
open FSharp.UMX
open Combinatorics

// Perm_Si: a permutation that is its own inverse (p ∘ p = identity)
type Perm_Si = private Perm_Si of Permutation with

    // Static method to create a Perm_Rs, validating self-inverse property
    static member create (arr: int array) : Perm_Si =
        if arr.Length < 1 then
            failwith "array must contain items"
        let perm = Permutation.create arr
        if not (Permutation.isSelfInverse perm) then
            failwith "Invalid: permutation must be self-inverse"
        Perm_Si perm

    // Static method to create a Perm_Rs, validating self-inverse property
    static member createUnsafe (arr: int array) : Perm_Si =
        let perm = Permutation.createUnsafe arr
        Perm_Si perm

    // Property to access the underlying permutation
    member this.Permutation =
        match this with
        | Perm_Si perm -> perm

    member this.Id
        with get () =
            match this with
            | Perm_Si perm -> perm.Id

    member this.Order
        with get () =
            match this with
            | Perm_Si perm -> perm.Order

    member this.Array
        with get () =
            match this with
            | Perm_Si perm -> perm.Array

    member this.equals (other: Perm_Si) : bool =
            this.Permutation.equals(other.Permutation)


module Perm_Si =

    type MutationMode =
        | Ortho
        | Para
        | NoAction

    /// The returned TwoOrbits are ordered ascending by their first index.
    /// <param name="perm_Si">The Perm_Si to convert.</param>
    /// <exception cref="System.ArgumentException">Thrown when the Perm_Si order is odd, or the array is invalid.</exception>
    let getTwoOrbits (perm_Si: Perm_Si) : TwoOrbit array =
        let order = perm_Si.Order |> UMX.untag
        if order < 0 || order % 2 <> 0 then
            failwith "Perm_Si order must be non-negative and even"
        if perm_Si.Array.Length <> order then
            failwith "Perm_Si array length must match order"
        let visited = Array.create order false
        let rec findOrbits i acc =
            if i >= order then acc
            elif visited.[i] then findOrbits (i + 1) acc
            else
                visited.[i] <- true
                let j = perm_Si.Array.[i]
                if j < 0 || j >= order then
                    failwith "Perm_Si array contains invalid indices"
                visited.[j] <- true
                let twoOrbit = TwoOrbit.create [i; j]
                findOrbits (i + 1) (twoOrbit :: acc)
        findOrbits 0 [] |> List.rev |> Array.ofList


    // Create a Perm_Si from a list of disjoint transpositions
    let fromTranspositions 
                (n: int) 
                (transpositions: List<int * int>) : Perm_Si =
        if n < 0 then
            failwith "Perm_Si order must not be negative"
        let arr = Array.init n id
        let mutable seen = Set.empty
        for (i, j) in transpositions do
            if i < 0 || i >= n || j < 0 || j >= n || i = j then
                failwith "Invalid transposition: must be distinct indices in [0, n-1]"
            if Set.contains i seen || Set.contains j seen then
                failwith "Transpositions must be disjoint"
            seen <- seen |> Set.add i |> Set.add j
            arr.[i] <- j
            arr.[j] <- i
        Perm_Si.create arr


    // Creates a Perm_Si of order n with a maximum number of orbits
    let saturatedWithTwoCycles (order: int) : Perm_Si =
        let cycleCount = order / 2
        let transpositions =
            [ for i in 0 .. (cycleCount - 1) -> (2 * i, 2 * i + 1) ]
        fromTranspositions order transpositions 


    // Creates a Perm_Si of order n with a maximum number of orbits
    let unSaturatedWithTwoCycles (order:int) (cycleCount:int) : Perm_Si =
        if(cycleCount > order / 2) then
            failwithf "cycleCount must be at most %d" (order/2)
        let cycleCount = order / 2
        let transpositions =
            [ for i in 0 .. (cycleCount - 1) -> (2 * i, 2 * i + 1) ]
        fromTranspositions order transpositions


    // makeReflection returns a reflection of the given Perm_Si
    let makeReflection (perm_Rs: Perm_Si) : Perm_Si =
        let origArray = perm_Rs.Permutation.Array
        let arrayLength = origArray.Length
        let _refl pos = 
            arrayLength - pos - 1
        Perm_Si.createUnsafe
            (Array.init arrayLength (fun dex -> origArray.[_refl dex] |> _refl))


    // isReflectionSymmetric checks if a Perm_Si is reflection symmetric
    let isReflectionSymmetric (perm_Rs: Perm_Si) :bool =
        let arr = perm_Rs.Permutation.Array
        let reflArray = (makeReflection perm_Rs).Permutation.Array
        arrayEquals arr reflArray


    // Creates a Perm_Si of given order packed with non-overlapping transpositions (i, i+k)
    let steppedOffsetTwoCycle 
            (order: int) (start:int) 
            (offset: int) (count: int) : Perm_Si =
        let transpositions =
            steppedOffsetPairs start order offset |> Seq.truncate count |> Seq.toList
        fromTranspositions order transpositions


    // Creates a Perm_Si of given even with count sequential 
    // transpositions (i, i+1) starting at i = startIndex
    let adjacentTwoCycles (order: int) (startIndex:int) (count: int): Perm_Si =
        if (order - startIndex) < 2 * count then
            failwith (sprintf "%d cycles is too many for Permutation of order %d and sda %d" 
                        count order startIndex)
        let transpositions =
            steppedOffsetPairs startIndex order 1 |> Seq.truncate count |> Seq.toList
        fromTranspositions order transpositions


    // Conjugate a Perm_Si (t) with a permutation (p) : p^-1 ∘ t ∘ p
    // This always makes a Perm_Si
    let conjugate (t: Perm_Si) (p: Permutation) : Perm_Si =
        let arrT = t.Permutation.Array
        let arrP = p.Array
        if Array.length arrT <> Array.length arrP then
            failwith "Permutations must have the same order"
        let res = compose (compose (inverse p) t.Permutation) p
        Perm_Si.createUnsafe res.Array


    // given a Perm_Si of Order n, this returns a Perm_Si of order 2n
    // that is reflection symmetric
    let unfoldReflection (perm_Rs:Perm_Si) : Perm_Si =
        let sa = perm_Rs.Array
        let o = %perm_Rs.Order
        let newArray = Array.create (o * 2) 0
        for i in 0 .. (o - 1) do
            newArray.[i] <- sa.[i]
            newArray.[o + i] <- 2 * o - sa.[o - i - 1] - 1
        Perm_Si.createUnsafe newArray


    // Generates a random Perm_Rs by conjugating a saturated Perm_Si with a random permutation
    let makeRandoms (indexShuffler: int -> int) (order: int) : Perm_Si seq =
        seq {
            while true do
                let initialPerm = Permutation.randomPermutation indexShuffler order
                yield conjugate (saturatedWithTwoCycles order) initialPerm
        }

    // Mutates a Perm_Si in a minimal way based on siMutationMode
    let mutate 
            (indexPicker: int -> int) 
            (siMutationMode:MutationMode) 
            (permSi: Perm_Si) : Perm_Si =

        // for None mode, return the permutation as is
        if (siMutationMode = MutationMode.NoAction) then
            permSi
        else
            let first, second = pickAndOrderTwoDistinct indexPicker %permSi.Order
            // if the two items are in the same orbit, do nothing
            if (permSi.Array.[first] = second) then
                permSi
            else
                let fpLow, fpHi = orderItems first permSi.Array.[first]
                let spLow, spHi = orderItems second permSi.Array.[second]
                let newArray = Array.copy permSi.Array
                match siMutationMode with
                | MutationMode.Ortho -> 
                   newArray.[fpLow] <- spLow
                   newArray.[spLow] <- fpLow
                   newArray.[spHi] <- fpHi
                   newArray.[fpHi] <- spHi
                   Perm_Si.createUnsafe newArray
                | MutationMode.Para ->
                   newArray.[fpLow] <- spHi
                   newArray.[spHi] <- fpLow
                   newArray.[fpHi] <- spLow
                   newArray.[spLow] <- fpHi
                   Perm_Si.createUnsafe newArray
                | MutationMode.NoAction -> permSi


    /// Computes the TwoOrbitType breakdown for a given Perm_Rs
    /// <param name="order">The order (must be non-negative and even).</param>
    /// <param name="perm_Rs">The Perm_Rs to analyze.</param>
    /// <returns>A TwoOrbitBreakdown containing the count of each TwoOrbitType.</returns>
    /// <exception cref="System.ArgumentException">Thrown when the Perm_Rs order is negative, odd, or the array is invalid.</exception>
    let getTwoOrbitTypeCounts (order: int) (perm_Si: Perm_Si) :(int*int*int) =
        // Helper function to extract components from a triple
        let fst3 (a, _, _) = a
        let snd3 (_, b, _) = b
        let trd3 (_, _, c) = c
        let twoOrbits = getTwoOrbits perm_Si
        let counts = 
            twoOrbits 
            |> Array.fold (fun (ortho, para, self) orbit ->
                match TwoOrbit.getTwoOrbitType order orbit with
                | TwoOrbitType.Ortho -> (ortho + 1, para, self)
                | TwoOrbitType.Para -> (ortho, para + 1, self)
                | TwoOrbitType.SelfRefl -> (ortho, para, self + 1)
            ) (0, 0, 0)
        (fst3 counts, snd3 counts, trd3 counts)


    /// Creates a Perm_Rs from a list of TwoOrbit pairs by mutating the identity Perm
    let fromTwoOrbitPair (twoOrbitPairs : TwoOrbitPair list) : Perm_Si =
        if twoOrbitPairs.Length < 1 then
            failwith "RsOrbitPair list must have an element"

        let arr = Array.init twoOrbitPairs.Head.Order id
        for orbitPair in twoOrbitPairs do
            let a, b = orbitPair.First.IndicesTuple
            arr.[a] <- b
            arr.[b] <- a
            if (orbitPair.Second.IsSome) then
                let c, d = orbitPair.Second.Value.IndicesTuple
                arr.[c] <- d
                arr.[d] <- c

        Perm_Si.create arr


// For more information see https://aka.ms/fsharp-console-apps

open GeneSort.Core.Permutation
open GeneSort.Core.PermutationSets
open GeneSort.Core
open FSharp.UMX
open System

module Example =
    let _notation p = p |> Permutation.toOrbitSet |> OrbitSet.toOrbitNotation

    let one () =
        let conjT = GeneSort.Core.Permutation.conjugate

        let p = Permutation.create [|1; 2; 0; 3|] // Permutation (0 1 2)(3)
        let q = Permutation.create [|1; 0; 3; 2|] // Permutation (0 1)(2 3)

        let r = rotated 1 4 // Rotate p by 1 position
        printfn "Permutation p: %s; %s" (p |> compose r |> _notation) (p |> compose r |>  toArrayNotation)
        printfn "Permutation q: %s; %s" (_notation q) (toArrayNotation q)
        printfn "Rotation of p by 1: %s; %s" (_notation r) (toArrayNotation r)
        printfn "Composition p ∘ q: %s; %s" (_notation (compose p q)) (toArrayNotation (compose p q))
        printfn "Conjugate q^-1 ∘ p ∘ q: %s; %s" (_notation (conjugate p q)) (toArrayNotation (conjugate p q))
        printfn "Orbits of p: %A" (_notation p)
        printfn "Powers of p: %A" (makeCyclicGroup p |> Seq.map _notation)

    // Example usage
    let two () =
        let conjT = GeneSort.Core.Permutation.conjugate

        let tc1 = Perm_Si.fromTranspositions 4 [(0, 1); (2, 3)] // Perm_Rs (0 1)(2 3)
        let tc2 = Perm_Si.adjacentTwoCycles 16 0 7
        let tc3 = Perm_Si.adjacentTwoCycles 16 1 7
        let tc4 = Perm_Si.steppedOffsetTwoCycle 16 0 2 5

        let perm = conjT tc2.Permutation tc3.Permutation
        let perm2 = conjT tc3.Permutation tc2.Permutation

        printfn "Perm_Rs (0 1)(2 3): %s" (_notation tc1.Permutation)
        printfn "evenIndexAdjacentTwoCycles 16: %s" (_notation tc2.Permutation)
        printfn "oddIndexAdjacentTwoCycles 16: %s" (_notation tc3.Permutation)
        printfn "steppedOffsetTwoCycle: %s" (_notation tc4.Permutation)

        printfn "conjugate: %s" (_notation perm)
        printfn "conjugate2: %s" (_notation perm2)


    let getBinomials() =

        let trials = 512 //25.09
        let probability = 0.01 // 50% chance of success
        
        let seed = 6290UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(seed) :> IRando

        for i in 1 .. 99 do

           Console.WriteLine($"{i}: {Combinatorics.binomialSample (fun () -> randy.NextFloat()) trials probability}")

        Console.WriteLine("hi")



    let binomialHistogram (randy: IRando) (trials: int) (probability: float) (m: int) : Map<int, int> =
        if m < 1 then invalidArg "m" "Number of repetitions must be positive"
    
        let counts = 
            Seq.init m (fun _ -> Combinatorics.binomialSample (fun () -> randy.NextFloat()) trials probability)
            |> Seq.fold (fun acc successes -> 
                Map.change successes (fun count -> Some (defaultArg count 0 + 1)) acc
            ) Map.empty
    
        counts



    let printBinomialHistogramReport () : unit =

        let trials = 512 //25.09
        let probability = 0.01
        let sampleSize = 2000000
        let seed = 12902UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(seed) :> IRando
        let histogram = binomialHistogram randy trials probability sampleSize

        // Calculate mean and standard deviation
        let totalSuccesses = 
            histogram 
            |> Map.fold (fun acc successes count -> acc + float successes * float count) 0.0
        let mean = totalSuccesses / float sampleSize
    
        // Print report header
        printfn "Binomial Distribution Histogram Report"
        printfn "====================================="
        printfn "Parameters:"
        printfn "  Number of trials (n): %d" trials
        printfn "  Success probability (p): %.3f" probability
        printfn "  Number of samples (m): %d" sampleSize
        printfn "  Expected mean (n*p): %.2f" (float trials * probability)
        printfn "  Expected standard deviation (sqrt(n*p*(1-p))): %.2f" (sqrt (float trials * probability * (1.0 - probability)))
        printfn ""
    
        // Print histogram
        printfn "Histogram of Successes:"
        printfn "----------------------"
        histogram
        |> Map.toSeq
        |> Seq.sortBy fst
        |> Seq.iter (fun (successes, count) ->
            let percentage = (float count / float sampleSize) * 100.0
            printfn "  %3d successes: %4d times (%.2f%%)" successes count percentage)

Example.printBinomialHistogramReport()
Console.ReadLine()
namespace GeneSort.Core

open Combinatorics
open CollectionUtils
open TwoOrbitPairOps
open MathUtils


module PrototypeUnfolder =


    // randomRsOrbitPairTypeList
    let randomTwoOrbitTypeList (randy:IRando) (n: int) : TwoOrbitType list =
        if n < 0 then failwith "Length must be non-negative"
        let values = [| TwoOrbitType.Ortho; TwoOrbitType.Para; TwoOrbitType.SelfRefl |]
        List.init n (fun _ -> values.[randy.NextIndex(values.Length)])


    /// returns allTwoOrbitType lists of length n
    let allTwoOrbitTypeLists n =
        let allValues = [TwoOrbitType.Ortho; TwoOrbitType.Para; TwoOrbitType.SelfRefl]
        let inputLists = List.replicate n allValues
        cartesianProduct inputLists


    // creates TwoOrbitPairs from TwoOrbits by reflection
    let unfoldTwoOrbitPairsIntoTwoOrbitPairs 
            (types: TwoOrbitType list) 
            (twoOrbitPairs: TwoOrbitPair list) : TwoOrbitPair list =

        if types.Length <> (twoOrbitPairs.Length * 2) then
            invalidArg "types" "Length of types must be twice the length of pairs"
        if types.Length = 0 then
            []
        else
            let m = twoOrbitPairs.Length
            let order = twoOrbitPairs.[0].Order
            // Validate all pairs have the same order
            if twoOrbitPairs |> List.exists (fun p -> p.Order <> order) then
                invalidArg "pairs" "All TwoOrbitPairs must have the same order"
        
            // Generate two TwoOrbitPairs for each input pair
            let results =
                seq {
                    for i in 0 .. (m - 1) do
                        yield unfoldTwoOrbitIntoTwoOrbitPair twoOrbitPairs[i].First order types[2 * i]
                        if (twoOrbitPairs[i].Second.IsSome) then
                            yield unfoldTwoOrbitIntoTwoOrbitPair twoOrbitPairs[i].Second.Value order types[2 * i + 1]
                } |> Seq.toList

            if results.Length <> 2 * m then
                failwith "Unexpected number of TwoOrbitPairs generated"
            results




    // twoOrbitPairsForOrder4
    let twoOrbitPairsForOrder4 (twoOrbitType:TwoOrbitType) : TwoOrbitPair =
        match twoOrbitType with
        | TwoOrbitType.Ortho -> TwoOrbitPair.create 4 (TwoOrbit.create [0; 2]) (TwoOrbit.create [1; 3] |> Some)
        | TwoOrbitType.Para -> TwoOrbitPair.create 4 (TwoOrbit.create [0; 1]) (TwoOrbit.create [2; 3] |> Some)
        | TwoOrbitType.SelfRefl ->  TwoOrbitPair.create 4 (TwoOrbit.create [0; 3]) (TwoOrbit.create [1; 2] |> Some)


    // makeTwoCycleFromTwoOrbitTypes
    let makePerm_SiFromTwoOrbitTypes
            (seedTwoOrbitPairs : TwoOrbitPair list option)
            (twoOrbitTypes: TwoOrbitType list) : Perm_Si =
        if twoOrbitTypes.Length < 1 then
            failwith "twoOrbitTypes list must have an element"

        let _makeTwoCycleFromTwoOrbitTypes
                (seedTwoOrbitPairs : TwoOrbitPair list)
                (twoOrbitTypes: TwoOrbitType list)  : Perm_Si =
            if seedTwoOrbitPairs.Length < 1 then
                failwith "seedRsOrbitPair list must have an element"
            if twoOrbitTypes.Length < 1 then
                failwith "twoOrbitTypes list must have an element"

            let rsOrbitPairTypeChunks = 
                    chunkByPowersOfTwo 
                        (seedTwoOrbitPairs.Length * 2)
                        twoOrbitTypes 
                        |> Seq.map Seq.toList |> Seq.toList
            let mutable workingList = seedTwoOrbitPairs
            for chunk in rsOrbitPairTypeChunks do
                workingList <- unfoldTwoOrbitPairsIntoTwoOrbitPairs chunk workingList 

            Perm_Si.fromTwoOrbitPair workingList

        match seedTwoOrbitPairs with
        | Some orbitPairs -> 
                _makeTwoCycleFromTwoOrbitTypes orbitPairs twoOrbitTypes
        | None -> 
                let h::t = twoOrbitTypes
                let seedPrs = [twoOrbitPairsForOrder4 h]
                _makeTwoCycleFromTwoOrbitTypes seedPrs t



    // makeAllPerm_SisOfOrder
    let makeAllPerm_SisOfOrder (order:int) 
            : Perm_Si seq =
        if (not (isAPowerOfTwo order)) then
            failwith "order must be a power of two"
        if(order < 4) then
            failwith "order must be at least 4"

        let rec _seqLen v c =
            if v = 4 then c + 1
            else _seqLen (v/2) (c + v/4)

        let seqLength = _seqLen order 0
        (allTwoOrbitTypeLists seqLength) 
        |> Seq.map(makePerm_SiFromTwoOrbitTypes None)


    // makeRandomPerm_Sis
    let makeRandomPerm_Sis (randy:IRando) (order:int) 
            : Perm_Si seq =
    
        // getTwoOrbitTypeLengthForOrder
        let getTwoOrbitTypeLengthForOrder (order:int) =
            if (not (isAPowerOfTwo order)) then
                failwith "order must be a power of two"
            if(order < 4) then
                failwith "order must be at least 4"
            let rec _seqLen v c =
                if v = 4 then c + 1
                else _seqLen (v/2) (c + v/4)
        
            _seqLen order 0

        let seqLength = getTwoOrbitTypeLengthForOrder order
        seq {
                while true do
                    let rsTypes = randomTwoOrbitTypeList randy seqLength
                    yield makePerm_SiFromTwoOrbitTypes None rsTypes
            }

                    




namespace GeneSort.Core
open System
open FSharp.UMX


[<Measure>] type randomSeed

module RandomSeed =

    let fromGuid(guid: Guid) : uint64<randomSeed> =
        let bytes = guid.ToByteArray()
        let mutable seed = 0UL
        for i in 0 .. 7 do
            seed <- seed ^^^ (uint64 bytes.[i] <<< (i * 8))
        for i in 8 .. 15 do
            seed <- seed ^^^ (uint64 bytes.[i] <<< ((i - 8) * 8))
        UMX.tag<randomSeed> seed

type rngType =
    | Lcg
    | Net


type IRando =
    abstract member NextIndex: int -> int
    abstract member NextUInt: unit -> uint32
    abstract member NextPositiveInt: unit -> int32
    abstract member NextULong: unit -> uint64
    abstract member NextFloat: unit -> float
    abstract member NextGuid: unit -> Guid
    abstract member ByteCount: int
    abstract member rngType: rngType


/// <summary>
/// A Linear Congruential Generator (LCG) for random number generation.
/// Uses parameters a = 6364136223846793005, c = 1442695040888963407, m = 2^64.
/// </summary>
type randomLcg(seed: uint64<randomSeed>) =
    let _a = 6364136223846793005UL
    let _c = 1442695040888963407UL
    let mutable _last = (_a * (uint64 (seed |> UMX.untag)) + _c)
    let mutable _byteCount = 0
    
    /// <summary>
    /// Gets the initial seed.
    /// </summary>
    member this.Seed = seed
    
    /// <summary>
    /// Gets the number of random bytes generated.
    /// </summary>
    member this.ByteCount = _byteCount
    
    /// <summary>
    /// Generates a random uint32 using the upper 32 bits of the LCG state.
    /// </summary>
    member this.NextUInt =
        _byteCount <- _byteCount + 4
        _last <- (_a * _last + _c)
        uint32 (_last >>> 32)
    
    /// <summary>
    /// Generates a random uint64 by combining two uint32 values.
    /// </summary>
    member this.NextULong =
        let high = uint64 this.NextUInt <<< 32
        let low = uint64 this.NextUInt
        high ||| low
    
    /// <summary>
    /// Generates a random float in [0, 1).
    /// </summary>
    member this.NextFloat =
        (float this.NextUInt) / 4294967295.0
    
    /// <summary>
    /// Returns a function that generates random uint32 values.
    /// </summary>
    member this.AsNextUInt() = fun () -> this.NextUInt
    
    interface IRando with
        member this.NextUInt () = this.NextUInt
        member this.NextPositiveInt () =
            int (this.NextUInt % uint32 Int32.MaxValue)
        member this.NextIndex (modulus: int) =
            if modulus <= 0 then
                int this.NextUInt
            else
                let threshold = UInt32.MaxValue - (UInt32.MaxValue % uint32 modulus)
                let mutable result = None
                while result.IsNone do
                    let r = this.NextUInt
                    if r < threshold then
                        result <- Some (int (r % uint32 modulus))
                result.Value
        member this.NextULong () = this.NextULong
        member this.NextGuid () =
            let b1 = this.NextUInt
            let b2 = this.NextUInt
            let b3 = this.NextUInt
            let b4 = this.NextUInt
            Guid(int b1, int16 b2, int16 (b2 >>> 16), [|
                byte b3; byte (b3 >>> 8); byte (b3 >>> 16); byte (b3 >>> 24);
                byte b4; byte (b4 >>> 8); byte (b4 >>> 16); byte (b4 >>> 24)
            |])
        member this.NextFloat () = this.NextFloat
        member this.ByteCount = this.ByteCount
        member this.rngType = Lcg

/// <summary>
/// A random number generator using System.Random.
/// </summary>
type randomNet(seed: int32<randomSeed>) =
    let _random = Random(int (UMX.untag seed))
    let mutable _byteCount = 0
    
    /// <summary>
    /// Gets the initial seed.
    /// </summary>
    member this.Seed = seed
    
    /// <summary>
    /// Gets the number of random bytes generated.
    /// </summary>
    member this.ByteCount = _byteCount
    
    /// <summary>
    /// Generates a random uint32 using System.Random.
    /// </summary>
    member this.NextUInt =
        _byteCount <- _byteCount + 4
        let bytes = Array.zeroCreate<byte> 4
        _random.NextBytes(bytes)
        BitConverter.ToUInt32(bytes, 0)
    
    /// <summary>
    /// Generates a random uint64 using System.Random.
    /// </summary>
    member this.NextULong =
        _byteCount <- _byteCount + 8
        let bytes = Array.zeroCreate<byte> 8
        _random.NextBytes(bytes)
        BitConverter.ToUInt64(bytes, 0)
    
    /// <summary>
    /// Generates a random float in [0, 1) using System.Random.
    /// </summary>
    member this.NextFloat =
        _byteCount <- _byteCount + 8
        let bytes = Array.zeroCreate<byte> 8
        _random.NextBytes(bytes)
        let value = BitConverter.ToDouble(bytes, 0)
        // Scale to [0, 1)
        value / Double.MaxValue
        // Alternatively, could use _random.NextDouble() directly, but using NextBytes for consistency
        // _random.NextDouble()
    
    /// <summary>
    /// Returns a function that generates random uint32 values.
    /// </summary>
    member this.AsNextUInt() = fun () -> this.NextUInt
    
    interface IRando with
        member this.NextUInt () = this.NextUInt
        member this.NextPositiveInt () =
            _byteCount <- _byteCount + 4
            let bytes = Array.zeroCreate<byte> 4
            _random.NextBytes(bytes)
            int (BitConverter.ToUInt32(bytes, 0) % uint32 Int32.MaxValue)
        member this.NextIndex (modulus: int) =
            _byteCount <- _byteCount + 4
            let bytes = Array.zeroCreate<byte> 4
            _random.NextBytes(bytes)
            bytes.[3] <- (bytes.[3] >>> 1)
            let value = BitConverter.ToUInt32(bytes, 0)
            if modulus <= 0 then
                int value
            else
                int value % modulus
        member this.NextULong () = this.NextULong
        member this.NextGuid () =
            _byteCount <- _byteCount + 16
            let bytes = Array.zeroCreate<byte> 16
            _random.NextBytes(bytes)
            Guid(bytes)
        member this.NextFloat () = this.NextFloat
        member this.ByteCount = this.ByteCount
        member this.rngType = Net


    module Rando =
        
        let create (rngType:rngType) (guid:Guid) =
            let seed = RandomSeed.fromGuid guid
            match rngType with
            | Lcg -> randomLcg(seed) :> IRando
            | Net -> randomNet(UMX.tag<randomSeed> (int32 seed)) :> IRando


        let nextTwo (maxDex:int) (randy:IRando) =
            if (maxDex < 2) then failwith "array must have at least two elements"
            else if (maxDex = 2) then (0, 1)
            else
                let firstVal = randy.NextIndex(maxDex)
                let mutable sndVal = randy.NextIndex(maxDex)
                while (firstVal = sndVal) do
                    sndVal <- randy.NextIndex(maxDex)
                (firstVal, sndVal)

        //returns true if probability is less than the random value generated
        let getTrueOrFalse (probability:float) (randy:IRando) =
            if (probability < 0.0 || probability > 1.0) then failwith "Probability must be between 0 and 1"
            else
                let randVal = randy.NextFloat()
                if (randVal < probability) then true else false



// Mock IRando implementation for predictable random outputs
    type MockRando(nextFloatValues: float list, nextIndexValues: int list) =
        let mutable floats = nextFloatValues
        let mutable indices = nextIndexValues
        interface IRando with
            member this.rngType: rngType = 
                raise (System.NotImplementedException())
            member _.NextFloat() =
                match floats with
                | x :: xs ->
                    floats <- xs
                    x
                | _ -> failwith "No more float values available"
            member _.NextIndex(max) =
                match indices with
                | x :: xs when x < max ->
                    indices <- xs
                    x
                | _ -> failwith "No more index values available"
            member _.NextUInt() = failwith "Not implemented"
            member _.NextPositiveInt() = failwith "Not implemented"
            member _.NextULong() = failwith "Not implemented"
            member _.NextGuid() = failwith "Not implemented"
            member _.ByteCount = 0

module SysExt

type System.Byte with
    (* bit manipulation methods *)
    member x.isset i = x &&& (1uy <<< i) <> 0uy // test if bit set at a specified position
    member x.get i = x &&& (1uy <<< i) <> 0uy
    member x.set i = x ||| (1uy <<< i) // set bit to 1
    member x.unset i = x &&& ~~~(1uy <<< i) // set bit from 0
    member x.flip i = (x ^^^ (1uy <<< i)) // change bit

    member x.rev = // reverse bits
        let rec go b i acc =
            if i = 8 then
                acc
            else
                go (b >>> 1) (i + 1) ((acc <<< 1) ||| (b &&& 1uy))
        go x 0 0uy

    member x.count = // count bits set to 1
        let rec go b acc =
            if b = 0uy then acc else go (b &&& (b - 1uy)) (acc + 1) // sparse count
        go x 0

    member x.count_dense = // The loop will execute once for each unset bit
        8 - ((~~~x).count) // do sparse count

    member x.diff y = x &&& (~~~y) // subtract y from x
    member x.subset y = (x &&& y) = x // x &&& (~~~ super) = 0
    member x.propersubset y = (x < y) && ((x &&& y) = x)
    member x.rotateLeft r = (x <<< r) ||| (x >>> (8 - r))
    member x.rotateRight r = (x >>> r) ||| (x <<< (8 - r))

    member x.rotate r =
        if r > 0 then x.rotateLeft r else x.rotateRight (-r)

    member x.leftmost_one = //??
        let mutable y = 0uy
        y <- x ||| (x >>> 1)
        y <- y ||| (y >>> 2)
        y <- y ||| (y >>> 4)
        y ^^^ (y >>> 1)

    member x.leftmost_zero = x.leftmost_one <<< 1

    member x.rightmost_one = x &&& (~~~x + 1uy)
    member x.rightmost_zero = (x ^^^ (x + 1uy)) &&& ~~~x

    member x.rightmost_index = // index of lowest bit set
        let mutable r = 0
        let y = x &&& (~~~x + 1uy) // isolate lowest bit
        if y &&& 0xf0uy <> 0uy then
            r <- r + 4
        if y &&& 0xccuy <> 0uy then
            r <- r + 2
        if y &&& 0xaauy <> 0uy then
            r <- r + 1
        r

    member x.leftmost_index =
        if x = 0uy then
            0
        else
            let mutable r = 0
            let mutable y = x
            if y &&& 0xf0uy <> 0uy then
                y <- y >>> 4
                r <- r + 4
            if y &&& 0x0cuy <> 0uy then
                y <- y >>> 2
                r <- r + 2
            if y &&& 0x02uy <> 0uy then
                r <- r + 1
            r

    (* bit coercion methods *)
    member x.toHex = sprintf "0x%x" x // to hexadecimal
    member x.toBits = System.Convert.ToString(int32 x, 2).PadLeft(8, '0') // to binary

    member x.toBoolArrayLSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[i] <- true
        aRet

    member x.toBoolArrayMSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[length - i - 1] <- true
        aRet

    member x.applyBoolArray (bA: bool[]) =
        let mutable iRet = x
        for i = 0 to (bA.Length - 1) do
            if bA.[i] then
                iRet <- iRet.set i
        iRet

    member x.toResizeArray = // to Resizable array of positions set to 1
        let array = ResizeArray()
        for i = 0 to 7 do
            if x.isset i then
                array.Add(i)
        array

    member x.toArray = // to array of positions set to 1
        let res = x.toResizeArray
        res.ToArray()

    member x.toList = // to list of positions set to 1
        let res = x.toResizeArray
        Array.toList (res.ToArray())

    member x.toSeq = // to seq of positions set to 1
        let res = x.toResizeArray
        Array.toSeq (res.ToArray())

    (* bit print methods *)
    member x.print = printf "%A" x

    member x.display = // helper to show bits
        x.toArray |> Seq.iter (fun i -> printf "%A " i)

type System.Int32 with // x=this
    (* bit manipulation methods *)
    member x.shrl = int (uint32 x >>> 1) // logical right shift
    member x.shrln i = int (uint32 x >>> i) // logical right shift by n positions
    member x.isset i = x &&& (1 <<< i) <> 0 // test if bit set at a specified position
    member x.get i = x &&& (1 <<< i) <> 0
    member x.set i = x ||| (1 <<< i) // set bit to 1
    member x.unset i = x &&& ~~~(1 <<< i) // set bit from 0
    member x.flip i = (x ^^^ (1 <<< i)) // change bit

    member x.rev = // reverse bits
        let rec go b i acc =
            if i = 32 then
                acc
            else
                go (b >>> 1) (i + 1) ((acc <<< 1) ||| (b &&& 1))

        go x 0 0

    member x.count = // count bits set to 1
        let rec go b acc =
            if b = 0 then acc else go (b &&& (b - 1)) (acc + 1) //sparse count
        //if b = 0 then acc else go (b.shrl) (acc + (b &&& 1)) //add res of calc
        go x 0

    member x.count_dense = // The loop will execute once for each unset bit
        32 - ((~~~x).count) //do sparse count

    //as opposed to diff: 0101&(~1100)=0101&0011=0001 xor returns mutual difference: 0101^1100=1001
    member x.diff y = x &&& (~~~y) // subtract y from x
    member x.subset y = (x &&& y) = x // x &&& (~~~ super) = 0  //must be in Bitmap module
    member x.propersubset y = (x < y) && ((x &&& y) = x)
    member x.rotateLeft r = (x <<< r) ||| (x >>> (32 - r))
    member x.rotateRight r = (x >>> r) ||| (x <<< (32 - r))

    member x.rotate r =
        if r > 0 then x.rotateLeft r else x.rotateRight (-r)

    member x.contains_zero_byte = ((x - 0x01010101) ^^^ x) &&& (~~~x) &&& 0x80808080
    member x.rightmost_one = x &&& (-x)
    member x.rightmost_zero = (x ^^^ (x + 1)) &&& ~~~x

    member x.leftmost_one = //??
        let mutable y = 0
        y <- x ||| (x >>> 1)
        y <- y ||| (y >>> 2)
        y <- y ||| (y >>> 4)
        y <- y ||| (y >>> 8)
        y <- y ||| (y >>> 16)
        y ^^^ (y >>> 1)

    member x.leftmost_zero = x.leftmost_one <<< 1 //??

    member x.rightmost_index = // index of lowest bit set
        let mutable r = 0
        let y = x &&& -x // isolate lowest bit

        if y &&& 0xffff0000 <> 0 then
            r <- r + 16
        if y &&& 0xff00ff00 <> 0 then
            r <- r + 8
        if y &&& 0xf0f0f0f0 <> 0 then
            r <- r + 4
        if y &&& 0xcccccccc <> 0 then
            r <- r + 2
        if y &&& 0xaaaaaaaa <> 0 then
            r <- r + 1
        r

    member x.leftmost_index =
        if 0 = x then
            0
        else
            let mutable r = 0
            let mutable y = x

            if y &&& 0xffff0000 <> 0 then
                y <- y >>> 16
                r <- r + 16

            if y &&& 0x0000ff00 <> 0 then
                y <- y >>> 8
                r <- r + 8

            if y &&& 0x000000f0 <> 0 then
                y <- y >>> 4
                r <- r + 4

            if y &&& 0x0000000c <> 0 then
                y <- y >>> 2
                r <- r + 2

            if y &&& 0x00000002 <> 0 then
                r <- r + 1

            r

    (* bit coersion methods *)
    member x.toHex = sprintf "0x%x" x // to hexadecimal
    member x.toBits = System.Convert.ToString(x, 2).PadLeft(32, '0') // to binary

    member x.toBoolArrayLSB (length:int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[i] <- true
        aRet

    member x.toBoolArrayMSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[length - i - 1] <- true
        aRet

    member x.applyBoolArray (bA:bool[]) =
        let mutable iRet = x
        for i = 0 to (bA.Length - 1) do
            if bA.[i] then
                iRet <- iRet.set i
        iRet


    member x.toResizeArray = // to Resizable array of positions set to 1
        let array = ResizeArray()
        for i = 0 to 31 do
            if x.isset i then
                array.Add(i)
        array

    member x.toArray = // to array of positions set to 1
        let res = x.toResizeArray
        res.ToArray()

    member x.toList = // to list of positions set to 1
        let res = x.toResizeArray
        Array.toList (res.ToArray())

    member x.toSeq = // to seq of positions set to 1
        let res = x.toResizeArray
        Array.toSeq (res.ToArray())

    (* bit print methods *)
    member x.print = printf "%A" x

    member x.display = // helper to show bits
        x.toArray |> Seq.iter (fun i -> printf "%A " i)

    (* misc methods *)
    member x.abs = (x ^^^ (x >>> 31)) - (x >>> 31) //3000% faster than standard math.abs

type System.UInt16 with
    (* bit manipulation methods *)
    member x.isset i = x &&& (1us <<< i) <> 0us // test if bit set at a specified position
    member x.get i = x &&& (1us <<< i) <> 0us
    member x.set i = x ||| (1us <<< i) // set bit to 1
    member x.unset i = x &&& ~~~(1us <<< i) // set bit from 0
    member x.flip i = (x ^^^ (1us <<< i)) // change bit

    member x.rev = // reverse bits
        let rec go b i acc =
            if i = 16 then
                acc
            else
                go (b >>> 1) (i + 1) ((acc <<< 1) ||| (b &&& 1us))
        go x 0 0us

    member x.count = // count bits set to 1
        let rec go b acc =
            if b = 0us then acc else go (b &&& (b - 1us)) (acc + 1) // sparse count
        go x 0

    member x.count_dense = // The loop will execute once for each unset bit
        16 - ((~~~x).count) // do sparse count

    member x.diff y = x &&& (~~~y) // subtract y from x
    member x.subset y = (x &&& y) = x // x &&& (~~~ super) = 0
    member x.propersubset y = (x < y) && ((x &&& y) = x)
    member x.rotateLeft r = (x <<< r) ||| (x >>> (16 - r))
    member x.rotateRight r = (x >>> r) ||| (x <<< (16 - r))

    member x.rotate r =
        if r > 0 then x.rotateLeft r else x.rotateRight (-r)

    member x.leftmost_one =
        let mutable y = 0us
        y <- x ||| (x >>> 1)
        y <- y ||| (y >>> 2)
        y <- y ||| (y >>> 4)
        y <- y ||| (y >>> 8)
        y ^^^ (y >>> 1)

    member x.leftmost_zero = x.leftmost_one <<< 1

    member x.rightmost_one = x &&& (~~~x + 1us)
    member x.rightmost_zero = (x ^^^ (x + 1us)) &&& ~~~x

    member x.rightmost_index = // index of lowest bit set
        let mutable r = 0
        let y = x &&& (~~~x + 1us) // isolate lowest bit
        if y &&& 0xff00us <> 0us then
            r <- r + 8
        if y &&& 0xf0f0us <> 0us then
            r <- r + 4
        if y &&& 0xccccus <> 0us then
            r <- r + 2
        if y &&& 0xaaaaus <> 0us then
            r <- r + 1
        r

    member x.leftmost_index =
        if x = 0us then
            0
        else
            let mutable r = 0
            let mutable y = x
            if y &&& 0xff00us <> 0us then
                y <- y >>> 8
                r <- r + 8
            if y &&& 0x00f0us <> 0us then
                y <- y >>> 4
                r <- r + 4
            if y &&& 0x000cus <> 0us then
                y <- y >>> 2
                r <- r + 2
            if y &&& 0x0002us <> 0us then
                r <- r + 1
            r

    (* bit coercion methods *)
    member x.toHex = sprintf "0x%x" x // to hexadecimal
    member x.toBits = System.Convert.ToString(int32 x, 2).PadLeft(16, '0') // to binary

    member x.toBoolArrayLSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[i] <- true
        aRet

    member x.toBoolArrayMSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[length - i - 1] <- true
        aRet

    member x.applyBoolArray (bA: bool[]) =
        let mutable iRet = x
        for i = 0 to (bA.Length - 1) do
            if bA.[i] then
                iRet <- iRet.set i
        iRet

    member x.toResizeArray = // to Resizable array of positions set to 1
        let array = ResizeArray()
        for i = 0 to 15 do
            if x.isset i then
                array.Add(i)
        array

    member x.toArray = // to array of positions set to 1
        let res = x.toResizeArray
        res.ToArray()

    member x.toList = // to list of positions set to 1
        let res = x.toResizeArray
        Array.toList (res.ToArray())

    member x.toSeq = // to seq of positions set to 1
        let res = x.toResizeArray
        Array.toSeq (res.ToArray())

    (* bit print methods *)
    member x.print = printf "%A" x

    member x.display = // helper to show bits
        x.toArray |> Seq.iter (fun i -> printf "%A " i)

type System.UInt32 with
    (* bit manipulation methods *)
    member x.isset i = x &&& (1u <<< i) <> 0u // test if bit set at a specified position
    member x.get i = x &&& (1u <<< i) <> 0u
    member x.set i = x ||| (1u <<< i) // set bit to 1
    member x.unset i = x &&& ~~~(1u <<< i) // set bit from 0
    member x.flip i = (x ^^^ (1u <<< i)) // change bit

    member x.rev = // reverse bits
        let rec go b i acc =
            if i = 32 then
                acc
            else
                go (b >>> 1) (i + 1) ((acc <<< 1) ||| (b &&& 1u))
        go x 0 0u

    member x.count = // count bits set to 1
        let rec go b acc =
            if b = 0u then acc else go (b &&& (b - 1u)) (acc + 1) // sparse count
        go x 0

    member x.count_dense = // The loop will execute once for each unset bit
        32 - ((~~~x).count) // do sparse count

    member x.diff y = x &&& (~~~y) // subtract y from x
    member x.subset y = (x &&& y) = x // the one bits of x are in the one bits of y
    member x.propersubset y = (x < y) && ((x &&& y) = x)
    member x.rotateLeft r = (x <<< r) ||| (x >>> (32 - r))
    member x.rotateRight r = (x >>> r) ||| (x <<< (32 - r))

    member x.rotate r =
        if r > 0 then x.rotateLeft r else x.rotateRight (-r)

    member x.leftmost_one =
        let mutable y = 0u
        y <- x ||| (x >>> 1)
        y <- y ||| (y >>> 2)
        y <- y ||| (y >>> 4)
        y <- y ||| (y >>> 8)
        y <- y ||| (y >>> 16)
        y ^^^ (y >>> 1)

    member x.leftmost_zero = x.leftmost_one <<< 1

    member x.rightmost_one = x &&& (~~~x + 1u)
    member x.rightmost_zero = (x ^^^ (x + 1u)) &&& ~~~x

    member x.rightmost_index = // index of lowest bit set
        let mutable r = 0
        let y = x &&& (~~~x + 1u) // isolate lowest bit
        if y &&& 0xffff0000u <> 0u then
            r <- r + 16
        if y &&& 0xff00ff00u <> 0u then
            r <- r + 8
        if y &&& 0xf0f0f0f0u <> 0u then
            r <- r + 4
        if y &&& 0xccccccccu <> 0u then
            r <- r + 2
        if y &&& 0xaaaaaaaau <> 0u then
            r <- r + 1
        r

    member x.leftmost_index =
        if x = 0u then
            0
        else
            let mutable r = 0
            let mutable y = x
            if y &&& 0xffff0000u <> 0u then
                y <- y >>> 16
                r <- r + 16
            if y &&& 0x0000ff00u <> 0u then
                y <- y >>> 8
                r <- r + 8
            if y &&& 0x000000f0u <> 0u then
                y <- y >>> 4
                r <- r + 4
            if y &&& 0x0000000cu <> 0u then
                y <- y >>> 2
                r <- r + 2
            if y &&& 0x00000002u <> 0u then
                r <- r + 1
            r

    (* bit coercion methods *)
    member x.toHex = sprintf "0x%x" x // to hexadecimal
    member x.toBits = System.Convert.ToString(int64 x, 2).PadLeft(32, '0') // to binary

    member x.toBoolArrayLSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[i] <- true
        aRet

    member x.toBoolArrayMSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[length - i - 1] <- true
        aRet

    member x.applyBoolArray (bA: bool[]) =
        let mutable iRet = x
        for i = 0 to (bA.Length - 1) do
            if bA.[i] then
                iRet <- iRet.set i
        iRet

    member x.toResizeArray = // to Resizable array of positions set to 1
        let array = ResizeArray()
        for i = 0 to 31 do
            if x.isset i then
                array.Add(i)
        array

    member x.toArray = // to array of positions set to 1
        let res = x.toResizeArray
        res.ToArray()

    member x.toList = // to list of positions set to 1
        let res = x.toResizeArray
        Array.toList (res.ToArray())

    member x.toSeq = // to seq of positions set to 1
        let res = x.toResizeArray
        Array.toSeq (res.ToArray())

    (* bit print methods *)
    member x.print = printf "%A" x

    member x.display = // helper to show bits
        x.toArray |> Seq.iter (fun i -> printf "%A " i)

type System.UInt64 with // x=this
    (* bit manipulation methods *)
    member x.isset i = x &&& (1uL <<< i) <> 0uL // test if bit set at a specified position
    member x.get i = x &&& (1uL <<< i) <> 0uL
    member x.set i = x ||| (1uL <<< i) // set bit to 1
    member x.unset i = x &&& ~~~(1uL <<< i) // set bit from 0
    member x.flip i = (x ^^^ (1uL <<< i)) // change bit

    member x.rev = // reverse bits
        let rec go b i acc =
            if i = 64 then
                acc
            else
                go (b >>> 1) (i + 1) ((acc <<< 1) ||| (b &&& 1uL))

        go x 0 0uL

    member x.count = // count bits set to 1
        let rec go b acc =
            if b = 0uL then acc else go (b &&& (b - 1uL)) (acc + 1uL) //sparse count
        //if b = 0 then acc else go (b.shrl) (acc + (b &&& 1)) //add res of calc
        go x 0uL

    member x.count_dense = // The loop will execute once for each unset bit
        64uL - ((~~~x).count) //do sparse count

    member x.diff y = x &&& (~~~y) // subtract y from x
    member x.subset y = (x &&& y) = x // x &&& (~~~ super) = 0  //must be in Bitmap module
    member x.propersubset y = (x < y) && ((x &&& y) = x)
    member x.rotateLeft r = (x <<< r) ||| (x >>> (64 - r))
    member x.rotateRight r = (x >>> r) ||| (x <<< (64 - r))

    member x.rotate r =
        if r > 0 then x.rotateLeft r else x.rotateRight (-r)
    //member x.contains_zero_byte = ((x-0x01010101)^^^x) &&& (~~~x) &&& 0x80808080

    member x.leftmost_one =
        let mutable y = 0uL
        y <- x ||| (x >>> 1)
        y <- y ||| (y >>> 2)
        y <- y ||| (y >>> 4)
        y <- y ||| (y >>> 8)
        y <- y ||| (y >>> 16)
        y ^^^ (y >>> 1)

    member x.leftmost_zero = x.leftmost_one <<< 1

    member x.rightmost_one = x &&& (~~~x + 1UL)
    member x.rightmost_zero = (x ^^^ (x + 1UL)) &&& ~~~x

    member x.rightmost_index = // index of lowest bit set
        let mutable r = 0
        let y = x &&& (~~~x + 1UL) // isolate lowest bit
        if y &&& 0xffffffff00000000UL <> 0UL then
            r <- r + 32
        if y &&& 0xffff0000UL <> 0UL then
            r <- r + 16
        if y &&& 0xff00ff00UL <> 0UL then
            r <- r + 8
        if y &&& 0xf0f0f0f0UL <> 0UL then
            r <- r + 4
        if y &&& 0xccccccccUL <> 0UL then
            r <- r + 2
        if y &&& 0xaaaaaaaaUL <> 0UL then
            r <- r + 1
        r

    member x.leftmost_index =
        if 0uL = x then
            0
        else
            let mutable r = 0
            let mutable y = x

            if y &&& 18446744069414584320UL <> 0uL then
                y <- y >>> 32
                r <- r + 32

            if y &&& 4294901760UL <> 0uL then
                y <- y >>> 16
                r <- r + 16

            if y &&& 65280UL <> 0uL then
                y <- y >>> 8
                r <- r + 8

            if y &&& 240UL <> 0uL then
                y <- y >>> 4
                r <- r + 4

            if y &&& 12UL <> 0uL then
                y <- y >>> 2
                r <- r + 2

            if y &&& 2UL <> 0uL then
                r <- r + 1

            r

    (* bit coersion methods *)
    member x.toHex = sprintf "0x%x" x // to hexadecimal

    member x.toBits = System.Convert.ToString(int64 x, 2).PadLeft(64, '0') // to binary

    member x.toBoolArrayLSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[i] <- true
        aRet

    member x.toBoolArrayMSB (length: int) =
        let aRet = Array.create length false
        for i = 0 to (length - 1) do
            if x.isset i then
                aRet.[length - i - 1] <- true
        aRet

    member x.applyBoolArray (bA: bool[]) =
        let mutable iRet = x
        for i = 0 to (bA.Length - 1) do
            if bA.[i] then
                iRet <- iRet.set i
        iRet

    member x.toResizeArray = // to Resizable array of positions set to 1
        let array = ResizeArray()

        for i = 0 to 63 do
            if x.isset i then
                array.Add(i)

        array

    member x.toArray = // to array of positions set to 1
        let res = x.toResizeArray
        res.ToArray()

    member x.toList = // to list of positions set to 1
        let res = x.toResizeArray
        Array.toList (res.ToArray())

    member x.toSeq = // to seq of positions set to 1
        let res = x.toResizeArray
        Array.toSeq (res.ToArray())

    (* bit print methods *)
    member x.print = printf "%A" x

    member x.display = // helper to show bits
        x.toArray |> Seq.iter (fun i -> printf "%A " i)

    (* misc methods *)
    member x.abs = (x ^^^ (x >>> 31)) - (x >>> 31) //3000% faster than standard math.abs

namespace GeneSort.Core

open FSharp.UMX

module Uoms =
    let sumInt ( x : int<'u>) (y: int<'u>) = x + y
    let sumFloat ( x : float<'u>) (y: float<'u>) = x + y

    let multIntUomByInt (y:int) (x:int<'u>) = 
        let fv = x |> UMX.untag<'u>
        (fv * y) |> UMX.tag<'u>

    let multFloatUomByInt (y:int) (x:float<'u>)  = 
        let fv = x |> UMX.untag<'u>
        (fv * (float y)) |> UMX.tag<'u>

    let multIntUomByFloat (y:float) (x:int<'u>) = 
        let fv = x |> UMX.untag<'u>
        (fv * (int y)) |> UMX.tag<'u>

    let multFloatUomByFloat (y:float) (x:float<'u>) = 
        let fv = x |> UMX.untag<'u>
        (fv * y) |> UMX.tag<'u>


    let intString ( x : int<'u>) = sprintf "%d" x
    let floatString ( x : float<'u>) = sprintf "%f" x
    let guidString ( x : Guid<'u>) = sprintf "%O" x
           
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Core.MessagePack")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Core.MessagePack")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Core.MessagePack")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Core.Mp")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd0ecb4b7b45c20f3de2591024c41fde4f7aea3a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Core.Mp")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Core.Mp")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core


[<MessagePackObject>]
type IndelRatesArrayDto = {
    [<Key(0)>]
    Rates: IndelRatesDto array
}

module IndelRatesArrayDto =
    let toIndelRatesArray (dto: IndelRatesArrayDto) : IndelRatesArray =
        let rates = Array.map IndelRatesDto.toIndelRates dto.Rates
        IndelRatesArray.create rates

    let fromIndelRatesArray (domain: IndelRatesArray) : IndelRatesArrayDto = {
        Rates = Array.map IndelRatesDto.fromIndelRates domain.RatesArray
    }

namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core


[<MessagePackObject>]
type IndelRatesDto = {
    [<Key(0)>]
    MutationThresh: float
    [<Key(1)>]
    InsertionThresh: float
    [<Key(2)>]
    DeletionThresh: float
}

module IndelRatesDto =
    let toIndelRates (dto: IndelRatesDto) : IndelRates =
        IndelRates.create (dto.MutationThresh, dto.InsertionThresh - dto.MutationThresh, dto.DeletionThresh - dto.InsertionThresh)

    let fromIndelRates (domain: IndelRates) : IndelRatesDto = {
        MutationThresh = domain.MutationRate
        InsertionThresh = domain.MutationRate + domain.InsertionRate
        DeletionThresh = domain.MutationRate + domain.InsertionRate + domain.DeletionRate
    }

namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type OpActionRatesArrayDto = {
    [<Key(0)>]
    Rates: OpActionRatesDto array
}

module OpActionRatesArrayDto =
    let toOpActionRatesArray (dto: OpActionRatesArrayDto) : OpActionRatesArray =
        let rates = Array.map OpActionRatesDto.toOpActionRates dto.Rates
        OpActionRatesArray.create rates

    let fromOpActionRatesArray (domain: OpActionRatesArray) : OpActionRatesArrayDto = {
        Rates = Array.map OpActionRatesDto.fromOpActionRates domain.RatesArray
    }
namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type OpActionRatesDto = {
    [<Key(0)>]
    OrthoThresh: float
    [<Key(1)>]
    ParaThresh: float
}

module OpActionRatesDto =
    let toOpActionRates (dto: OpActionRatesDto) : OpActionRates =
        OpActionRates.create (dto.OrthoThresh, dto.ParaThresh - dto.OrthoThresh)

    let fromOpActionRates (domain: OpActionRates) : OpActionRatesDto = {
        OrthoThresh = domain.OrthoRate
        ParaThresh = domain.OrthoRate + domain.ParaRate
    }

namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core


[<MessagePackObject>]
type OpsActionRatesArrayDto = {
    [<Key(0)>]
    Rates: OpsActionRatesDto array
}

module OpsActionRatesArrayDto =
    let toOpsActionRatesArray (dto: OpsActionRatesArrayDto) : OpsActionRatesArray =
        let rates = Array.map OpsActionRatesDto.toOpsActionRates dto.Rates
        OpsActionRatesArray.create rates

    let fromOpsActionRatesArray (domain: OpsActionRatesArray) : OpsActionRatesArrayDto = {
        Rates = Array.map OpsActionRatesDto.fromOpsActionRates domain.RatesArray
    }
namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type OpsActionRatesDto = {
    [<Key(0)>]
    OrthoThresh: float
    [<Key(1)>]
    ParaThresh: float
    [<Key(2)>]
    SelfReflThresh: float
}

module OpsActionRatesDto =
    let toOpsActionRates (dto: OpsActionRatesDto) : OpsActionRates =
        OpsActionRates.create (dto.OrthoThresh, dto.ParaThresh - dto.OrthoThresh, dto.SelfReflThresh - dto.ParaThresh)

    let fromOpsActionRates (domain: OpsActionRates) : OpsActionRatesDto = {
        OrthoThresh = domain.OrthoRate
        ParaThresh = domain.OrthoRate + domain.ParaRate
        SelfReflThresh = domain.OrthoRate + domain.ParaRate + domain.SelfReflRate
    }

namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core


[<MessagePackObject>]
type OpsGenRatesArrayDto = {
    [<Key(0)>]
    Rates: OpsGenRatesDto array
}

module OpsGenRatesArrayDto =
    let toOpsGenRatesArray (dto: OpsGenRatesArrayDto) : OpsGenRatesArray =
        let rates = Array.map OpsGenRatesDto.toOpsGenRates dto.Rates
        OpsGenRatesArray.create rates

    let fromOpsGenRatesArray (domain: OpsGenRatesArray) : OpsGenRatesArrayDto = {
        Rates = Array.map OpsGenRatesDto.fromOpsGenRates domain.RatesArray
    }
namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type OpsGenRatesDto = {
    [<Key(0)>]
    OrthoThresh: float
    [<Key(1)>]
    ParaThresh: float
    [<Key(2)>]
    SelfReflThresh: float
}

module OpsGenRatesDto =
    let toOpsGenRates (dto: OpsGenRatesDto) : OpsGenRates =
        OpsGenRates.create (dto.OrthoThresh, dto.ParaThresh - dto.OrthoThresh, dto.SelfReflThresh - dto.ParaThresh)

    let fromOpsGenRates (domain: OpsGenRates) : OpsGenRatesDto = {
        OrthoThresh = domain.OrthoRate
        ParaThresh = domain.OrthoRate + domain.ParaRate
        SelfReflThresh = domain.OrthoRate + domain.ParaRate + domain.SelfReflRate
    }

namespace GeneSort.Core.Mp.RatesAndOps

open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type OpsTransitionRatesArrayDto = {
    [<Key(0)>]
    Rates: OpsTransitionRatesDto array
}

module OpsTransitionRatesArrayDto =
    let toOpsTransitionRatesArray (dto: OpsTransitionRatesArrayDto) : OpsTransitionRatesArray =
        let rates = Array.map OpsTransitionRatesDto.toOpsTransitionRates dto.Rates
        OpsTransitionRatesArray.create rates

    let fromOpsTransitionRatesArray (domain: OpsTransitionRatesArray) : OpsTransitionRatesArrayDto = {
        Rates = Array.map OpsTransitionRatesDto.fromOpsTransitionRates domain.RatesArray
    }


namespace GeneSort.Core.Mp.RatesAndOps
open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type OpsTransitionRatesDto = {
    [<Key(0)>]
    OrthoRates: OpsActionRatesDto
    [<Key(1)>]
    ParaRates: OpsActionRatesDto
    [<Key(2)>]
    SelfReflRates: OpsActionRatesDto
}

module OpsTransitionRatesDto =
    let toOpsTransitionRates (dto: OpsTransitionRatesDto) : OpsTransitionRates =
        OpsTransitionRates.create(
            OpsActionRatesDto.toOpsActionRates dto.OrthoRates,
            OpsActionRatesDto.toOpsActionRates dto.ParaRates,
            OpsActionRatesDto.toOpsActionRates dto.SelfReflRates
        )

    let fromOpsTransitionRates (domain: OpsTransitionRates) : OpsTransitionRatesDto = {
        OrthoRates = OpsActionRatesDto.fromOpsActionRates domain.OrthoRates
        ParaRates = OpsActionRatesDto.fromOpsActionRates domain.ParaRates
        SelfReflRates = OpsActionRatesDto.fromOpsActionRates domain.SelfReflRates
    }
namespace GeneSort.Core.Mp.RatesAndOps
open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type Seed6ActionRatesDto = {
    [<Key(0)>]
    Ortho1Thresh: float
    [<Key(1)>]
    Ortho2Thresh: float
    [<Key(2)>]
    Para1Thresh: float
    [<Key(3)>]
    Para2Thresh: float
    [<Key(4)>]
    Para3Thresh: float
    [<Key(5)>]
    Para4Thresh: float
    [<Key(6)>]
    SelfReflThresh: float
}

module Seed6ActionRatesDto =
    let toSeed6ActionRates (dto: Seed6ActionRatesDto) : Seed6ActionRates =
        Seed6ActionRates.create(
            dto.Ortho1Thresh,
            dto.Ortho2Thresh - dto.Ortho1Thresh,
            dto.Para1Thresh - dto.Ortho2Thresh,
            dto.Para2Thresh - dto.Para1Thresh,
            dto.Para3Thresh - dto.Para2Thresh,
            dto.Para4Thresh - dto.Para3Thresh,
            dto.SelfReflThresh - dto.Para4Thresh
        )

    let fromSeed6ActionRates (domain: Seed6ActionRates) : Seed6ActionRatesDto = {
        Ortho1Thresh = domain.Ortho1Rate
        Ortho2Thresh = domain.Ortho1Rate + domain.Ortho2Rate
        Para1Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate
        Para2Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate
        Para3Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate + domain.Para3Rate
        Para4Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate + domain.Para3Rate + domain.Para4Rate
        SelfReflThresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate + domain.Para3Rate + domain.Para4Rate + domain.SelfReflRate
    }
namespace GeneSort.Core.Mp.RatesAndOps
open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type Seed6GenRatesDto = {
    [<Key(0)>]
    Ortho1Thresh: float
    [<Key(1)>]
    Ortho2Thresh: float
    [<Key(2)>]
    Para1Thresh: float
    [<Key(3)>]
    Para2Thresh: float
    [<Key(4)>]
    Para3Thresh: float
    [<Key(5)>]
    Para4Thresh: float
    [<Key(6)>]
    SelfReflThresh: float
}

module Seed6GenRatesDto =
    let toSeed6GenRates (dto: Seed6GenRatesDto) : Seed6GenRates =
        Seed6GenRates.create(
            dto.Ortho1Thresh,
            dto.Ortho2Thresh - dto.Ortho1Thresh,
            dto.Para1Thresh - dto.Ortho2Thresh,
            dto.Para2Thresh - dto.Para1Thresh,
            dto.Para3Thresh - dto.Para2Thresh,
            dto.Para4Thresh - dto.Para3Thresh,
            dto.SelfReflThresh - dto.Para4Thresh
        )

    let fromSeed6GenRates (domain: Seed6GenRates) : Seed6GenRatesDto = {
        Ortho1Thresh = domain.Ortho1Rate
        Ortho2Thresh = domain.Ortho1Rate + domain.Ortho2Rate
        Para1Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate
        Para2Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate
        Para3Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate + domain.Para3Rate
        Para4Thresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate + domain.Para3Rate + domain.Para4Rate
        SelfReflThresh = domain.Ortho1Rate + domain.Ortho2Rate + domain.Para1Rate + domain.Para2Rate + domain.Para3Rate + domain.Para4Rate + domain.SelfReflRate
    }
namespace GeneSort.Core.Mp.RatesAndOps
open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type Seed6TransitionRatesDto = {
    [<Key(0)>]
    Ortho1Rates: Seed6ActionRatesDto
    [<Key(1)>]
    Ortho2Rates: Seed6ActionRatesDto
    [<Key(2)>]
    Para1Rates: Seed6ActionRatesDto
    [<Key(3)>]
    Para2Rates: Seed6ActionRatesDto
    [<Key(4)>]
    Para3Rates: Seed6ActionRatesDto
    [<Key(5)>]
    Para4Rates: Seed6ActionRatesDto
    [<Key(6)>]
    SelfReflRates: Seed6ActionRatesDto
}

module Seed6TransitionRatesDto =
    let toSeed6TransitionRates (dto: Seed6TransitionRatesDto) : Seed6TransitionRates =
        Seed6TransitionRates.create(
            Seed6ActionRatesDto.toSeed6ActionRates dto.Ortho1Rates,
            Seed6ActionRatesDto.toSeed6ActionRates dto.Ortho2Rates,
            Seed6ActionRatesDto.toSeed6ActionRates dto.Para1Rates,
            Seed6ActionRatesDto.toSeed6ActionRates dto.Para2Rates,
            Seed6ActionRatesDto.toSeed6ActionRates dto.Para3Rates,
            Seed6ActionRatesDto.toSeed6ActionRates dto.Para4Rates,
            Seed6ActionRatesDto.toSeed6ActionRates dto.SelfReflRates
        )

    let fromSeed6TransitionRates (domain: Seed6TransitionRates) : Seed6TransitionRatesDto = {
        Ortho1Rates = Seed6ActionRatesDto.fromSeed6ActionRates domain.Ortho1Rates
        Ortho2Rates = Seed6ActionRatesDto.fromSeed6ActionRates domain.Ortho2Rates
        Para1Rates = Seed6ActionRatesDto.fromSeed6ActionRates domain.Para1Rates
        Para2Rates = Seed6ActionRatesDto.fromSeed6ActionRates domain.Para2Rates
        Para3Rates = Seed6ActionRatesDto.fromSeed6ActionRates domain.Para3Rates
        Para4Rates = Seed6ActionRatesDto.fromSeed6ActionRates domain.Para4Rates
        SelfReflRates = Seed6ActionRatesDto.fromSeed6ActionRates domain.SelfReflRates
    }
namespace GeneSort.Core.Mp.RatesAndOps
open MessagePack
open GeneSort.Core

[<MessagePackObject>]
type Uf4GenRatesDto = {
    [<Key(0)>]
    Order: int
    [<Key(1)>]
    OpsGenRatesDto: OpsGenRatesDto
    [<Key(2)>]
    OpsGenRatesDtoList: OpsGenRatesDto list
}

module Uf4GenRatesDto =
    let toUf4GenRates (dto: Uf4GenRatesDto) : Uf4GenRates =
        {
            order = dto.Order
            seedOpsGenRates = OpsGenRatesDto.toOpsGenRates dto.OpsGenRatesDto
            opsGenRatesList = List.map OpsGenRatesDto.toOpsGenRates dto.OpsGenRatesDtoList
        }

    let fromUf4GenRates (domain: Uf4GenRates) : Uf4GenRatesDto = {
        Order = domain.order
        OpsGenRatesDto = OpsGenRatesDto.fromOpsGenRates domain.seedOpsGenRates
        OpsGenRatesDtoList = List.map OpsGenRatesDto.fromOpsGenRates domain.opsGenRatesList
    }

namespace GeneSort.Core.Mp.TwoOrbitUnfolder

open System
open GeneSort.Core
open MessagePack

[<MessagePackObject; Struct>]
type TwoOrbitUf4DTO =
    { [<Key(0)>] SeedType: TwoOrbitType
      [<Key(1)>] TwoOrbitUfSteps: TwoOrbitUfStepDTO list }
    
    static member Create(seedType: TwoOrbitType, twoOrbitUnfolderSteps: TwoOrbitUfStepDTO list) : Result<TwoOrbitUf4DTO, string> =
        if List.isEmpty twoOrbitUnfolderSteps then
            Error "TwoOrbitUnfolderSteps list cannot be empty"
        else
            Ok { SeedType = seedType
                 TwoOrbitUfSteps = twoOrbitUnfolderSteps }

module TwoOrbitUf4DTO =
    type TwoOrbitUf4DTOError =
        | EmptyTwoOrbitUfSteps of string
        | StepConversionError of TwoOrbitUnfolderStepDTO.TwoOrbitUnfolderStepDTOError

    let toTwoOrbitUnfolder4DTO (tou: TwoOrbitUf4) : TwoOrbitUf4DTO =
        { SeedType = tou.TwoOrbitType
          TwoOrbitUfSteps = tou.TwoOrbitUnfolderSteps |> List.map TwoOrbitUnfolderStepDTO.toTwoOrbitUnfolderStepDTO }

    let toTwoOrbitUnfolder4 (dto: TwoOrbitUf4DTO) : Result<TwoOrbitUf4, TwoOrbitUf4DTOError> =
        let stepsResult = 
            dto.TwoOrbitUfSteps 
            |> List.map TwoOrbitUnfolderStepDTO.toTwoOrbitUnfolderStep
            |> List.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok step -> Ok (arr @ [step])
                | Ok _, Error e -> Error (StepConversionError e)
                | Error e, _ -> Error e
            ) (Ok [])
        
        match stepsResult with
        | Error e -> Error e
        | Ok steps ->
            try
                let tou = TwoOrbitUf4.create dto.SeedType steps
                Ok tou
            with
            | :? ArgumentException as ex when ex.Message.Contains("empty") ->
                Error (EmptyTwoOrbitUfSteps ex.Message)
            | ex ->
                Error (EmptyTwoOrbitUfSteps ex.Message)


    let getOrder (twoOrbitUnfolder: TwoOrbitUf4DTO) : int =
            4 * (MathUtils.integerPower 2 (List.length twoOrbitUnfolder.TwoOrbitUfSteps))
namespace GeneSort.Core.Mp.TwoOrbitUnfolder


open System
open FSharp.UMX
open GeneSort.Core
open MessagePack

[<MessagePackObject>]
type TwoOrbitUf6DTO =
    { [<Key(0)>] SeedType: TwoOrbitTripleType
      [<Key(1)>] TwoOrbitUfSteps: TwoOrbitUfStepDTO list }
    
    static member Create(seedType: TwoOrbitTripleType, twoOrbitUnfolderSteps: TwoOrbitUfStepDTO list) : Result<TwoOrbitUf6DTO, string> =
        if List.isEmpty twoOrbitUnfolderSteps then
            Error "TwoOrbitUnfolderSteps list cannot be empty"
        else
            let computedOrder = 6 * (MathUtils.integerPower 2 (List.length twoOrbitUnfolderSteps))
            if twoOrbitUnfolderSteps |> List.exists (fun step -> step.Order < 4 || step.Order % 2 <> 0) then
                Error $"All TwoOrbitUfStep orders must be at least 4 and even"
            else
                Ok { SeedType = seedType
                     TwoOrbitUfSteps = twoOrbitUnfolderSteps }

module TwoOrbitUf6DTO =
    type TwoOrbitUf6DTOError =
        | EmptyTwoOrbitUnfolderSteps of string
        | InvalidStepOrder of string
        | StepConversionError of TwoOrbitUnfolderStepDTO.TwoOrbitUnfolderStepDTOError

    let toTwoOrbitUf6DTO (tou: TwoOrbitUf6) : TwoOrbitUf6DTO =
        { SeedType = tou.Seed6TwoOrbitType
          TwoOrbitUfSteps = tou.TwoOrbitUnfolderSteps |> List.map TwoOrbitUnfolderStepDTO.toTwoOrbitUnfolderStepDTO }

    let toTwoOrbitUf6 (dto: TwoOrbitUf6DTO) : Result<TwoOrbitUf6, TwoOrbitUf6DTOError> =
        let stepsResult = 
            dto.TwoOrbitUfSteps 
            |> List.map TwoOrbitUnfolderStepDTO.toTwoOrbitUnfolderStep
            |> List.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok step -> Ok (arr @ [step])
                | Ok _, Error e -> Error (StepConversionError e)
                | Error e, _ -> Error e
            ) (Ok [])
        
        match stepsResult with
        | Error e -> Error e
        | Ok steps ->
            try
                let tou = TwoOrbitUf6.create dto.SeedType steps
                Ok tou
            with
            | :? ArgumentException as ex when ex.Message.Contains("empty") ->
                Error (EmptyTwoOrbitUnfolderSteps ex.Message)
            | ex ->
                Error (EmptyTwoOrbitUnfolderSteps ex.Message)


    let getOrder (twoOrbitUnfolder: TwoOrbitUf6DTO) : int =
            6 * (MathUtils.integerPower 2 (List.length twoOrbitUnfolder.TwoOrbitUfSteps))
namespace GeneSort.Core.MessagePack.TwoOrbitUnfolder


open System
open FSharp.UMX
open EvoMergeSort.Core
open MessagePack
open GeneSort.Core.MessagePack
open EvoMergeSort.Core.Uf6Seeds
open GeneSort.Core.MessagePack.TwoOrbit
open GeneSort.Core.MessagePack.TwoOrbit.Unfolder6Seeds


[<MessagePackObject>]
type TwoOrbitUf4GenRatesDTO =
    { [<Key(0)>] Order: int
      [<Key(1)>] SeedGenRates: {| Ortho: float; Para: float; SelfRefl: float |}
      [<Key(2)>] TwoOrbitTypeGenRatesList: TwoOrbitTypeGenRatesDTO list }
    
    static member Create(order: int, seedGenRates: {| Ortho: float; Para: float; SelfRefl: float |}, twoOrbitTypeGenRatesList: TwoOrbitTypeGenRatesDTO list) 
        : Result<TwoOrbitUf4GenRatesDTO, string> =
        if order < 4 then
            Error $"Order must be at least 4, got {order}"
        else if order % 2 <> 0 then
            Error $"Order must be even, got {order}"
        else if order % 4 <> 0 then
            Error $"Order must be divisible by 4, got {order}"
        else if seedGenRates.Ortho < 0.0 || seedGenRates.Ortho > 1.0 then
            Error $"SeedGenRates.Ortho must be between 0 and 1, got {seedGenRates.Ortho}"
        else if seedGenRates.Para < 0.0 || seedGenRates.Para > 1.0 then
            Error $"SeedGenRates.Para must be between 0 and 1, got {seedGenRates.Para}"
        else if seedGenRates.SelfRefl < 0.0 || seedGenRates.SelfRefl > 1.0 then
            Error $"SeedGenRates.SelfRefl must be between 0 and 1, got {seedGenRates.SelfRefl}"
        else if seedGenRates.Ortho + seedGenRates.Para + seedGenRates.SelfRefl > 1.0 then
            Error $"Sum of SeedGenRates must not exceed 1.0, got Ortho={seedGenRates.Ortho}, Para={seedGenRates.Para}, SelfRefl={seedGenRates.SelfRefl}"
        else
            try
                let expectedLength = MathUtils.exactLog2(order / 4)
                if twoOrbitTypeGenRatesList.Length <> expectedLength then
                    Error $"TwoOrbitTypeGenRatesList length ({twoOrbitTypeGenRatesList.Length}) must equal log2(order/4) ({expectedLength})"
                else
                    Ok { Order = order
                         SeedGenRates = seedGenRates
                         TwoOrbitTypeGenRatesList = twoOrbitTypeGenRatesList }
            with
            | :? ArgumentException as ex ->
                Error ex.Message

module TwoOrbitUf4GenRatesDTO =
    type TwoOrbitUf4GenRatesDTOError =
        | InvalidOrder of string
        | NotEvenOrder of string
        | NotDivisibleByFour of string
        | InvalidSeedGenRatesOrtho of string
        | InvalidSeedGenRatesPara of string
        | InvalidSeedGenRatesSelfRefl of string
        | InvalidSeedGenRatesSum of string
        | InvalidTwoOrbitTypeGenRatesLength of string
        | TwoOrbitTypeGenRatesConversionError of TwoOrbitTypeGenRatesDTO.TwoOrbitTypeGenRatesDTOError

    let toTwoOrbitUnfolder4GenRatesDTO (genRates: Uf4GenRates) : TwoOrbitUf4GenRatesDTO =
        { Order = genRates.order
          SeedGenRates = {| Ortho = genRates.seedGenRatesUf4.Ortho
                            Para = genRates.seedGenRatesUf4.Para
                            SelfRefl = genRates.seedGenRatesUf4.SelfRefl |}
          TwoOrbitTypeGenRatesList = genRates.opsGenRatesList |> List.map TwoOrbitTypeGenRatesDTO.toTwoOrbitTypeGenRatesDTO }

    let toTwoOrbitUnfolder4GenRates (dto: TwoOrbitUf4GenRatesDTO) : Result<Uf4GenRates, TwoOrbitUf4GenRatesDTOError> =
        let genRatesListResult = 
            dto.TwoOrbitTypeGenRatesList 
            |> List.map TwoOrbitTypeGenRatesDTO.toTwoOrbitTypeGenRates
            |> List.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok gr -> Ok (arr @ [gr])
                | Ok _, Error e -> Error (TwoOrbitTypeGenRatesConversionError e)
                | Error e, _ -> Error e
            ) (Ok [])
        
        match genRatesListResult with
        | Error e -> Error e
        | Ok genRatesList ->
            try
                let seedGenRates: SeedGenRatesUf4 = 
                        { Ortho = dto.SeedGenRates.Ortho
                          Para = dto.SeedGenRates.Para
                          SelfRefl = dto.SeedGenRates.SelfRefl }
                let twoOrbitUnfolder4GenRates = 
                    { order = dto.Order
                      seedGenRatesUf4 = seedGenRates
                      opsGenRatesList = genRatesList }
                Ok twoOrbitUnfolder4GenRates
            with
            | :? ArgumentException as ex when ex.Message.Contains("Order") && not (ex.Message.Contains("even")) && not (ex.Message.Contains("divisible by 4")) ->
                Error (InvalidOrder ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("even") ->
                Error (NotEvenOrder ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("divisible by 4") ->
                Error (NotDivisibleByFour ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("Ortho") ->
                Error (InvalidSeedGenRatesOrtho ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("Para") ->
                Error (InvalidSeedGenRatesPara ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("SelfRefl") ->
                Error (InvalidSeedGenRatesSelfRefl ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("sum") ->
                Error (InvalidSeedGenRatesSum ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("log2") ->
                Error (InvalidTwoOrbitTypeGenRatesLength ex.Message)
            | ex ->
                Error (InvalidOrder ex.Message)



[<MessagePackObject>]
type TwoOrbitUf6GenRatesDTO =
    { [<Key(0)>] Order: int
      [<Key(1)>] SeedGenRartes: Order6GenRatesDTO
      [<Key(2)>] TwoOrbitTypeGenRatesList: TwoOrbitTypeGenRatesDTO list }
    
    static member Create(order: int, seedGenRartes: Order6GenRatesDTO, twoOrbitTypeGenRatesList: TwoOrbitTypeGenRatesDTO list) 
        : Result<TwoOrbitUf6GenRatesDTO, string> =
        if order < 6 then
            Error $"Order must be at least 6, got {order}"
        else if order % 6 <> 0 then
            Error $"Order must be divisible by 6, got {order}"
        else
            try
                let expectedLength = MathUtils.exactLog2(order / 6)
                if twoOrbitTypeGenRatesList.Length <> expectedLength then
                    Error $"TwoOrbitTypeGenRatesList length ({twoOrbitTypeGenRatesList.Length}) must equal log2(order/6) ({expectedLength})"
                else
                    Ok { Order = order
                         SeedGenRartes = seedGenRartes
                         TwoOrbitTypeGenRatesList = twoOrbitTypeGenRatesList }
            with
            | :? ArgumentException as ex ->
                Error ex.Message


module TwoOrbitUf6GenRatesDTO =
    type TwoOrbitUf6GenRatesDTOError =
        | InvalidOrder of string
        | NotDivisibleBySix of string
        | NullTwoOrbitTypeGenRatesList of string
        | InvalidTwoOrbitTypeGenRatesLength of string
        | SeedGenRartesConversionError of Order6GenRatesDTO.Order6GenRatesDTOError
        | TwoOrbitTypeGenRatesConversionError of TwoOrbitTypeGenRatesDTO.TwoOrbitTypeGenRatesDTOError

    let toTwoOrbitUf6GenRatesDTO (genRates: Uf6GenRates) : TwoOrbitUf6GenRatesDTO =
        { Order = genRates.order
          SeedGenRartes = Order6GenRatesDTO.toOrder6GenRatesDTO genRates.seedGenRatesUf6
          TwoOrbitTypeGenRatesList = genRates.twoOrbitTypeGenRatesList |> List.map TwoOrbitTypeGenRatesDTO.toTwoOrbitTypeGenRatesDTO }

    let toTwoOrbitUf6GenRates (dto: TwoOrbitUf6GenRatesDTO) : Result<Uf6GenRates, TwoOrbitUf6GenRatesDTOError> =
        let seedGenRartesResult = Order6GenRatesDTO.toOrder6GenRates dto.SeedGenRartes
        let genRatesListResult = 
            dto.TwoOrbitTypeGenRatesList 
            |> List.map TwoOrbitTypeGenRatesDTO.toTwoOrbitTypeGenRates
            |> List.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok gr -> Ok (arr @ [gr])
                | Ok _, Error e -> Error (TwoOrbitTypeGenRatesConversionError e)
                | Error e, _ -> Error e
            ) (Ok [])
        
        match seedGenRartesResult, genRatesListResult with
        | Error e, _ -> Error (SeedGenRartesConversionError e)
        | _, Error e -> Error e
        | Ok seedGenRartes, Ok genRatesList ->
            try
                let genRates = 
                    { order = dto.Order
                      seedGenRatesUf6 = seedGenRartes
                      twoOrbitTypeGenRatesList = genRatesList }
                Ok genRates
            with
            | :? ArgumentException as ex when ex.Message.Contains("Order") && not (ex.Message.Contains("divisible by 6")) ->
                Error (InvalidOrder ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("divisible by 6") ->
                Error (NotDivisibleBySix ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("log2") ->
                Error (InvalidTwoOrbitTypeGenRatesLength ex.Message)
            | ex ->
                Error (InvalidOrder ex.Message)









namespace GeneSort.Core.Mp.TwoOrbitUnfolder

open System
open FSharp.UMX
open MessagePack
open GeneSort.Core

[<MessagePackObject; Struct>]
type TwoOrbitUfStepDTO =
    { [<Key(0)>] TwoOrbitTypes: TwoOrbitType list
      [<Key(1)>] Order: int }
    
    static member Create(twoOrbitTypes: TwoOrbitType list, order: int) : Result<TwoOrbitUfStepDTO, string> =
        if order < 4 then
            Error $"Order must be at least 4, got {order}"
        else if order % 2 <> 0 then
            Error $"Order must be even, got {order}"
        else if List.length twoOrbitTypes <> order / 2 then
            Error $"TwoOrbitTypes length ({List.length twoOrbitTypes}) must be order / 2 ({order / 2})"
        else
            Ok { TwoOrbitTypes = twoOrbitTypes; Order = order }

module TwoOrbitUnfolderStepDTO =
    type TwoOrbitUnfolderStepDTOError =
        | InvalidOrder of string
        | NotEvenOrder of string
        | InvalidTwoOrbitTypesLength of string

    let toTwoOrbitUnfolderStepDTO (step: TwoOrbitUfStep) : TwoOrbitUfStepDTO =
        { TwoOrbitTypes = step.TwoOrbitTypes
          Order = step.Order }

    let toTwoOrbitUnfolderStep (dto: TwoOrbitUfStepDTO) : Result<TwoOrbitUfStep, TwoOrbitUnfolderStepDTOError> =
        try
            let step = TwoOrbitUfStep.create dto.TwoOrbitTypes dto.Order
            Ok step
        with
        | :? ArgumentException as ex when ex.Message.Contains("at least 4") ->
            Error (InvalidOrder ex.Message)
        | :? ArgumentException as ex when ex.Message.Contains("even") ->
            Error (NotEvenOrder ex.Message)
        | :? ArgumentException as ex when ex.Message.Contains("length") ->
            Error (InvalidTwoOrbitTypesLength ex.Message)
        | ex ->
            Error (InvalidOrder ex.Message)


namespace GeneSort.Core.Mp

open System
open GeneSort.Core
open MessagePack

[<MessagePackObject; Struct>]
type PermutationDTO =
    { [<Key(0)>] Array: int array }
    
    static member Create(arr: int array) : Result<PermutationDTO, string> =
        if isNull arr then
            Error "Array cannot be null"
        else if arr.Length = 0 then
            Error "Array cannot be empty"
        else
            let n = arr.Length
            let sorted = Array.sort arr
            let isValid = Array.forall2 (fun i v -> i = v) [|0 .. n-1|] sorted
            if not isValid then
                Error "Invalid permutation: must contain each integer from 0 to n-1 exactly once"
            else
                Ok { Array = arr }

module PermutationDTO =
    type PermutationDTOError =
        | NullArray of string
        | EmptyArray of string
        | InvalidPermutation of string

    let toPermutationDTO (perm: Permutation) : PermutationDTO =
        { Array = perm.Array }

    let toPermutation (dto: PermutationDTO) : Result<Permutation, PermutationDTOError> =
        try
            let perm = Permutation.create dto.Array
            Ok perm
        with
        | :? ArgumentException as ex when ex.Message.Contains("empty") ->
            Error (EmptyArray ex.Message)
        | :? ArgumentException as ex when ex.Message.Contains("Invalid permutation") ->
            Error (InvalidPermutation ex.Message)
        | ex ->
            Error (InvalidPermutation ex.Message) // Fallback for unexpected errors
namespace GeneSort.Core.Mp

open System
open GeneSort.Core
open MessagePack

[<MessagePackObject; Struct>]
type Perm_RsDTO =
    { [<Key(0)>] Perm_Si: Perm_SiDTO }
    
    static member Create(arr: int array) : Result<Perm_RsDTO, string> =
        if arr.Length < 4 then
            Error "Perm_Rs order must be at least 4"
        else if arr.Length % 2 <> 0 then
            Error "Perm_Rs order must be divisible by 2"
        else
            match Perm_SiDTO.Create(arr) with
            | Error e -> Error e
            | Ok permSiDTO ->
                let permSi = Perm_Si.create arr
                if not (Perm_Si.isReflectionSymmetric permSi) then
                    Error "Invalid Perm_Rs: permutation must be reflection-symmetric"
                else
                    Ok { Perm_Si = permSiDTO }


module Perm_RsDTO =
    type Perm_RsDTOError =
        | OrderTooSmall of string
        | OrderNotDivisibleByTwo of string
        | NotReflectionSymmetric of string
        | PermSiConversionError of Perm_SiDTO.Perm_SiDTOError

    let toPerm_RsDTO (permRs: Perm_Rs) : Perm_RsDTO =
        { Perm_Si = Perm_SiDTO.toPerm_SiDTO permRs.Perm_Si }

    let toPerm_Rs (dto: Perm_RsDTO) : Result<Perm_Rs, Perm_RsDTOError> =
        match Perm_SiDTO.toPerm_Si dto.Perm_Si with
        | Error e -> Error (PermSiConversionError e)
        | Ok permSi ->
            try
                let permRs = Perm_Rs.create permSi.Array
                Ok permRs
            with
            | :? ArgumentException as ex when ex.Message.Contains("order must be at least 4") ->
                Error (OrderTooSmall ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("divisible by 2") ->
                Error (OrderNotDivisibleByTwo ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("reflection-symmetric") ->
                Error (NotReflectionSymmetric ex.Message)
            | ex ->
                Error (NotReflectionSymmetric ex.Message) // Fallback for unexpected errors
namespace GeneSort.Core.Mp

open System
open GeneSort.Core
open MessagePack


[<MessagePackObject; Struct>]
type Perm_SiDTO =
    { [<Key(0)>] Permutation: PermutationDTO }
    
    static member Create(arr: int array) : Result<Perm_SiDTO, string> =
        match PermutationDTO.Create(arr) with
        | Error e -> Error e
        | Ok permDTO ->
            let perm = Permutation.create arr
            if not (Permutation.isSelfInverse perm) then
                Error "Invalid: permutation must be self-inverse"
            else
                Ok { Permutation = permDTO }

module Perm_SiDTO =
    type Perm_SiDTOError =
        | NullArray of string
        | EmptyArray of string
        | InvalidPermutation of string
        | NotSelfInverse of string
        | PermutationConversionError of PermutationDTO.PermutationDTOError

    let toPerm_SiDTO (permSi: Perm_Si) : Perm_SiDTO =
        { Permutation = PermutationDTO.toPermutationDTO permSi.Permutation }

    let toPerm_Si (dto: Perm_SiDTO) : Result<Perm_Si, Perm_SiDTOError> =
        match PermutationDTO.toPermutation dto.Permutation with
        | Error e -> Error (PermutationConversionError e)
        | Ok perm ->
            try
                let permSi = Perm_Si.create perm.Array
                Ok permSi
            with
            | :? ArgumentException as ex when ex.Message.Contains("array must contain items") ->
                Error (EmptyArray ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("self-inverse") ->
                Error (NotSelfInverse ex.Message)
            | ex ->
                Error (InvalidPermutation ex.Message) // Fallback for unexpected errors
// For more information see https://aka.ms/fsharp-console-apps
printfn "Hello from F#"
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Microsoft.Testing.Platform.MSBuild
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.TestingPlatform.Extensions

open System.Runtime.CompilerServices

[<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage>]
[<Extension>]
type SelfRegisteredExtensions() =

    [<Extension>]
    static member AddSelfRegisteredExtensions (builder: Microsoft.Testing.Platform.Builder.ITestApplicationBuilder, args: string[]) =
        Microsoft.Testing.Platform.MSBuild.TestingPlatformBuilderHook.AddExtensions(builder, args)
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Core.MessagePack.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Core.MessagePack.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Core.MessagePack.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Core.Mp.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd0ecb4b7b45c20f3de2591024c41fde4f7aea3a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Core.Mp.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Core.Mp.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
namespace GeneSort.Core.Test

open System
open Xunit
open FsUnit.Xunit
open GeneSort.Core
open GeneSort.Core.Mp.RatesAndOps

module IndelRatesArrayTests =
    let epsilon = 1e-10 // Tolerance for floating-point comparisons

    [<Fact>]
    let ``create should succeed with valid IndelRates array`` () =
        let rates = [| IndelRates.create (0.2, 0.3, 0.4); IndelRates.create (0.3, 0.3, 0.3) |]
        let indelRatesArray = IndelRatesArray.create rates
        indelRatesArray.Length |> should equal 2
        indelRatesArray.Item(0).MutationRate |> should (equalWithin epsilon) 0.2
        indelRatesArray.RatesArray |> should equal rates

    [<Fact>]
    let ``create should fail with empty array`` () =
        (fun () -> IndelRatesArray.create [||] |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createLinearVariation should interpolate rates correctly`` () =
        let startRates = IndelRates.create (0.2, 0.3, 0.4)
        let endRates = IndelRates.create (0.4, 0.2, 0.3)
        let indelRatesArray = IndelRatesArray.createLinearVariation 3 startRates endRates
        indelRatesArray.Length |> should equal 3
        indelRatesArray.Item(0).MutationRate |> should (equalWithin epsilon) 0.2
        indelRatesArray.Item(0).InsertionRate |> should (equalWithin epsilon) 0.3
        indelRatesArray.Item(0).DeletionRate |> should (equalWithin epsilon) 0.4
        indelRatesArray.Item(2).MutationRate |> should (equalWithin epsilon) 0.4
        indelRatesArray.Item(2).InsertionRate |> should (equalWithin epsilon) 0.2
        indelRatesArray.Item(2).DeletionRate |> should (equalWithin epsilon) 0.3
        indelRatesArray.Item(1).MutationRate |> should (equalWithin epsilon) 0.3 // Midpoint
        indelRatesArray.Item(1).NoActionRate |> should (equalWithin epsilon) 0.1 // 1.0 - (0.3 + 0.25 + 0.35)

    [<Fact>]
    let ``createLinearVariation should fail with non-positive length`` () =
        let rates = IndelRates.create (0.2, 0.3, 0.4)
        (fun () -> IndelRatesArray.createLinearVariation 0 rates rates |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createSinusoidalVariation should apply sinusoidal variation`` () =
        let baseRates = IndelRates.create (0.3, 0.3, 0.3)
        let amplitudes = IndelRates.create (0.1, 0.1, 0.1)
        let indelRatesArray = IndelRatesArray.createSinusoidalVariation 5 baseRates amplitudes 1.0
        indelRatesArray.Length |> should equal 5
        // Check approximate values at index 0 (sin(0) = 0)
        indelRatesArray.Item(0).MutationRate |> should (equalWithin epsilon) 0.3
        // Check approximate values at index 2 (near peak, sin(π) = 0)
        indelRatesArray.Item(2).MutationRate |> should be (lessThanOrEqualTo 0.4)
        indelRatesArray.Item(2).MutationRate |> should be (greaterThanOrEqualTo 0.2)

    [<Fact>]
    let ``createSinusoidalVariation should fail with non-positive length`` () =
        let rates = IndelRates.create (0.2, 0.3, 0.4)
        let amplitudes = IndelRates.create (0.1, 0.1, 0.1)
        (fun () -> IndelRatesArray.createSinusoidalVariation 0 rates amplitudes 1.0 |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createGaussianHotSpot should create peak at specified index`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        let indelRatesArray = IndelRatesArray.createGaussianHotSpot 5 baseRates 2 hotSpotRates 1.0
        indelRatesArray.Length |> should equal 5
        // Peak at index 2
        indelRatesArray.Item(2).MutationRate |> should (equalWithin epsilon) 0.5
        indelRatesArray.Item(2).InsertionRate |> should (equalWithin epsilon) 0.3
        indelRatesArray.Item(2).DeletionRate |> should (equalWithin epsilon) 0.1
        // Away from peak (index 0), closer to base rates
        indelRatesArray.Item(0).MutationRate |> should be (greaterThan 0.2)
        indelRatesArray.Item(0).MutationRate |> should be (lessThan 0.5)

    [<Fact>]
    let ``createGaussianHotSpot should fail with non-positive length`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        (fun () -> IndelRatesArray.createGaussianHotSpot 0 baseRates 0 hotSpotRates 1.0 |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createGaussianHotSpot should fail with invalid hotSpotIndex`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        (fun () -> IndelRatesArray.createGaussianHotSpot 5 baseRates 5 hotSpotRates 1.0 |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createGaussianHotSpot should fail with non-positive sigma`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        (fun () -> IndelRatesArray.createGaussianHotSpot 5 baseRates 2 hotSpotRates 0.0 |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createStepHotSpot should apply hot spot rates in specified range`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        let indelRatesArray = IndelRatesArray.createStepHotSpot 5 baseRates 1 3 hotSpotRates
        indelRatesArray.Length |> should equal 5
        // Outside hot spot (index 0)
        indelRatesArray.Item(0).MutationRate |> should (equalWithin epsilon) 0.2
        indelRatesArray.Item(0).InsertionRate |> should (equalWithin epsilon) 0.2
        indelRatesArray.Item(0).DeletionRate |> should (equalWithin epsilon) 0.2
        // Inside hot spot (index 2)
        indelRatesArray.Item(2).MutationRate |> should (equalWithin epsilon) 0.5
        indelRatesArray.Item(2).InsertionRate |> should (equalWithin epsilon) 0.3
        indelRatesArray.Item(2).DeletionRate |> should (equalWithin epsilon) 0.1
        // Outside hot spot (index 4)
        indelRatesArray.Item(4).MutationRate |> should (equalWithin epsilon) 0.2

    [<Fact>]
    let ``createStepHotSpot should fail with non-positive length`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        (fun () -> IndelRatesArray.createStepHotSpot 0 baseRates 0 1 hotSpotRates |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``createStepHotSpot should fail with invalid range`` () =
        let baseRates = IndelRates.create (0.2, 0.2, 0.2)
        let hotSpotRates = IndelRates.create (0.5, 0.3, 0.1)
        (fun () -> IndelRatesArray.createStepHotSpot 5 baseRates 3 2 hotSpotRates |> ignore)
        |> should throw typeof<System.Exception>
        (fun () -> IndelRatesArray.createStepHotSpot 5 baseRates 0 5 hotSpotRates |> ignore)
        |> should throw typeof<System.Exception>
namespace GeneSort.Core.Test

open System
open Xunit
open FsUnit.Xunit
open GeneSort.Core
open GeneSort.Core.Mp.RatesAndOps

type IndelRatesTests() =
    let epsilon = 1e-10 // Tolerance for floating-point comparisons

    [<Fact>]
    let ``IndelRatesDto toIndelRates should correctly map to domain type`` () =
        let dto = { MutationThresh = 0.2; InsertionThresh = 0.5; DeletionThresh = 0.9 }
        let rates = IndelRatesDto.toIndelRates dto
        rates.MutationRate |> should (equalWithin epsilon) 0.2
        rates.InsertionRate |> should (equalWithin epsilon) 0.3 // 0.5 - 0.2
        rates.DeletionRate |> should (equalWithin epsilon) 0.4 // 0.9 - 0.5
        rates.NoActionRate |> should (equalWithin epsilon) 0.1 // 1.0 - 0.9

    [<Fact>]
    let ``IndelRatesDto fromIndelRates should correctly map to DTO`` () =
        let rates = IndelRates.create (0.2, 0.3, 0.4)
        let dto = IndelRatesDto.fromIndelRates rates
        dto.MutationThresh |> should (equalWithin epsilon) 0.2
        dto.InsertionThresh |> should (equalWithin epsilon) 0.5 // 0.2 + 0.3
        dto.DeletionThresh |> should (equalWithin epsilon) 0.9 // 0.2 + 0.3 + 0.4

    [<Fact>]
    let ``Roundtrip conversion through IndelRatesDto should preserve rates`` () =
        let original = IndelRates.create (0.2, 0.3, 0.4)
        let dto = IndelRatesDto.fromIndelRates original
        let converted = IndelRatesDto.toIndelRates dto
        converted.MutationRate |> should (equalWithin epsilon) original.MutationRate
        converted.InsertionRate |> should (equalWithin epsilon) original.InsertionRate
        converted.DeletionRate |> should (equalWithin epsilon) original.DeletionRate
        converted.NoActionRate |> should (equalWithin epsilon) original.NoActionRate
module Program

module Tests

open System
open Xunit

[<Fact>]
let ``My test`` () =
    Assert.True(true)
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Microsoft.Testing.Platform.MSBuild
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.TestingPlatform.Extensions

open System.Runtime.CompilerServices

[<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage>]
[<Extension>]
type SelfRegisteredExtensions() =

    [<Extension>]
    static member AddSelfRegisteredExtensions (builder: Microsoft.Testing.Platform.Builder.ITestApplicationBuilder, args: string[]) =
        Microsoft.Testing.Platform.MSBuild.TestingPlatformBuilderHook.AddExtensions(builder, args)
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0341568e6de31d96807f09cf8255cb26c1320b13")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Microsoft.Testing.Platform.MSBuild
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.TestingPlatform.Extensions

open System.Runtime.CompilerServices

[<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage>]
[<Extension>]
type SelfRegisteredExtensions() =

    [<Extension>]
    static member AddSelfRegisteredExtensions (builder: Microsoft.Testing.Platform.Builder.ITestApplicationBuilder, args: string[]) =
        Microsoft.Testing.Platform.MSBuild.TestingPlatformBuilderHook.AddExtensions(builder, args)
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Release")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+c0cdc112d9c5b01145f143569ebe9e98ebe2e8d2")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Core.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
namespace GeneSort.Core.Test

open Xunit
open FsUnit.Xunit
open GeneSort.Core


type IndelRatesArrayTests() =
    let epsilon = 1e-10 // Tolerance for floating-point comparisons

    let createRates (m, i, d) = IndelRates.create (m, i, d)
    let indelRatesArray rates = IndelRatesArray.create (Array.create 1 rates)
    let inserter () = 0
    let mutator x = x + 1
    let arrayToMutate = [| 1 |]

    [<Fact>]
    let ``mutate should fail when array and rates lengths differ`` () =
        let rates = IndelRatesArray.create [| createRates (0.2, 0.3, 0.4); createRates (0.2, 0.3, 0.4) |]
        let array = [| 1 |]
        (fun () -> IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) array |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``mutate should apply Mutation mode correctly`` () =
        let rates = indelRatesArray (createRates (1.0, 0.0, 0.0)) // Always Mutation
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) arrayToMutate
        result |> should equal [| 2 |] // mutator 1 = 2

    [<Fact>]
    let ``mutate should apply Insertion mode correctly`` () =
        let rates = indelRatesArray (createRates (0.0, 1.0, 0.0)) // Always Insertion
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) arrayToMutate
        result |> should equal [| 0 |] // inserter () = 0

    [<Fact>]
    let ``mutate should apply Deletion mode and append insertion to maintain length`` () =
        let rates = indelRatesArray (createRates (0.0, 0.0, 1.0)) // Always Deletion
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) arrayToMutate
        result |> should equal [| 0 |] // Deletion, then inserter () to maintain length

    [<Fact>]
    let ``mutate should apply NoAction mode correctly`` () =
        let rates = indelRatesArray (createRates (0.0, 0.0, 0.0)) // Always NoAction
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.9) arrayToMutate
        result |> should equal [| 1 |] // Unchanged

    [<Fact>]
    let ``mutate should maintain length with multiple deletions`` () =
        let rates = IndelRatesArray.create [| createRates (0.0, 0.0, 1.0); createRates (0.0, 0.0, 1.0) |]
        let array = [| 1; 2 |]
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) array
        result |> should equal [| 0; 0 |] // Two deletions, two insertions appended

    [<Fact>]
    let ``mutate should trim excess insertions to maintain length`` () =
        let rates = IndelRatesArray.create [| createRates (0.0, 1.0, 0.0); createRates (0.0, 1.0, 0.0) |] // Always Insertion
        let array = [| 1; 2 |]
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) array
        result |> should haveLength 2 // Two insertions, trimmed to length 2
        result |> should equal [| 0; 1 |] // Both are inserter () calls

    [<Fact>]
    let ``mutate should maintain length with mixed operations`` () =
        let rates = IndelRatesArray.create [| createRates (1.0, 0.0, 0.0); createRates (0.0, 0.0, 1.0) |]
        let array = [| 1; 2 |]
        let floatPicker () = 0.0 // Triggers Mutation, then Deletion
        let result = IndelRatesArray.mutate rates inserter mutator floatPicker array
        result |> should equal [| 2; 0 |] // Mutation (1 -> 2), Deletion + Insertion (0)

    [<Fact>]
    let ``mutate should handle single-element array correctly`` () =
        let rates = indelRatesArray (createRates (0.0, 0.0, 1.0)) // Deletion
        let result = IndelRatesArray.mutate rates inserter mutator (fun () -> 0.0) arrayToMutate
        result |> should equal [| 0 |] // Deletion + Insertion to maintain length

namespace GeneSort.Core.Test

open System
open Xunit
open FsUnit.Xunit
open GeneSort.Core


type IndelRatesTests() =
    let epsilon = 1e-10 // Tolerance for floating-point comparisons

    [<Fact>]
    let ``create should succeed with valid rates`` () =
        let rates = IndelRates.create (0.2, 0.3, 0.4)
        rates.MutationRate |> should (equalWithin epsilon) 0.2
        rates.InsertionRate |> should (equalWithin epsilon) 0.3
        rates.DeletionRate |> should (equalWithin epsilon) 0.4
        rates.NoActionRate |> should (equalWithin epsilon) 0.1

    [<Fact>]
    let ``create should fail when mutationRate is negative`` () =
        (fun () -> IndelRates.create (-0.1, 0.3, 0.4) |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``create should fail when insertionRate is negative`` () =
        (fun () -> IndelRates.create (0.2, -0.1, 0.4) |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``create should fail when deletionRate is negative`` () =
        (fun () -> IndelRates.create (0.2, 0.3, -0.1) |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``create should fail when rates sum exceeds 1.0`` () =
        (fun () -> IndelRates.create (0.5, 0.4, 0.2) |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``create should succeed when rates sum to 1.0`` () =
        let rates = IndelRates.create (0.3, 0.3, 0.4)
        rates.NoActionRate |> should (equalWithin epsilon) 0.0

    [<Fact>]
    let ``PickMode should return Mutation when random value is below mutationThresh`` () =
        let rates = IndelRates.create (0.3, 0.2, 0.1)
        let floatPicker () = 0.15 // Within mutation range (0.0 to 0.3)
        rates.PickMode floatPicker |> should equal IndelMode.Mutation

    [<Fact>]
    let ``PickMode should return Insertion when random value is between mutationThresh and insertionThresh`` () =
        let rates = IndelRates.create (0.3, 0.2, 0.1)
        let floatPicker () = 0.45 // Within insertion range (0.3 to 0.5)
        rates.PickMode floatPicker |> should equal IndelMode.Insertion

    [<Fact>]
    let ``PickMode should return Deletion when random value is between insertionThresh and deletionThresh`` () =
        let rates = IndelRates.create (0.3, 0.2, 0.1)
        let floatPicker () = 0.55 // Within deletion range (0.5 to 0.6)
        rates.PickMode floatPicker |> should equal IndelMode.Deletion

    [<Fact>]
    let ``PickMode should return NoAction when random value is above deletionThresh`` () =
        let rates = IndelRates.create (0.3, 0.2, 0.1)
        let floatPicker () = 0.75 // Above deletion range (0.6 to 1.0)
        rates.PickMode floatPicker |> should equal IndelMode.NoAction

    [<Fact>]
    let ``Equals should return true for identical IndelRates`` () =
        let rates1 = IndelRates.create (0.2, 0.3, 0.4)
        let rates2 = IndelRates.create (0.2, 0.3, 0.4)
        rates1.Equals(rates2) |> should be True
        (rates1 :> IEquatable<IndelRates>).Equals(rates2) |> should be True

    [<Fact>]
    let ``Equals should return false for different IndelRates`` () =
        let rates1 = IndelRates.create (0.2, 0.3, 0.4)
        let rates2 = IndelRates.create (0.3, 0.3, 0.3)
        rates1.Equals(rates2) |> should be False

    [<Fact>]
    let ``GetHashCode should be equal for identical IndelRates`` () =
        let rates1 = IndelRates.create (0.2, 0.3, 0.4)
        let rates2 = IndelRates.create (0.2, 0.3, 0.4)
        rates1.GetHashCode() |> should equal (rates2.GetHashCode())
namespace GeneSort.Core.Test.TwoOrbit
open System
open Xunit
open FsUnit.Xunit
open GeneSort.Core


type Perm_SiTests() =
    // Tests for Perm_Si.getTwoOrbits
    [<Fact>]
    let ``Perm_Si.getTwoOrbits with valid order 4 permutation returns correct TwoOrbits`` () =
        let perm_Rs = Perm_Si.create [|1; 0; 3; 2|]
        let result = Perm_Si.getTwoOrbits perm_Rs
        let expected = [|
            TwoOrbit.create [0; 1]
            TwoOrbit.create [2; 3]
        |]
        Assert.Equal<TwoOrbit array>(expected, result)

    [<Fact>]
    let ``Perm_Si.getTwoOrbits with different valid order 4 permutation returns correct TwoOrbits`` () =
        let perm_Rs = Perm_Si.create  [|2; 3; 0; 1|]
        let result = Perm_Si.getTwoOrbits perm_Rs
        let expected = [|
            TwoOrbit.create [0; 2]
            TwoOrbit.create [1; 3]
        |]
        Assert.Equal<TwoOrbit array>(expected, result)

    [<Fact>]
    let ``Perm_Si.getTwoOrbits with odd order throws exception`` () =
        let perm_Rs = Perm_Si.create [|1; 0; 2|]
        let ex = Assert.Throws<Exception>(fun () -> Perm_Si.getTwoOrbits perm_Rs |> ignore)
        Assert.Equal("Perm_Si order must be non-negative and even", ex.Message)


    [<Fact>]
    let ``Perm_Si.makeReflection`` () =
        let perm_Rs = Perm_Si.create [|1; 0; 2; 3; 5; 4|]
        let reflPerm = perm_Rs |> Perm_Si.makeReflection
        Assert.Equal(reflPerm |> Perm_Si.isReflectionSymmetric, true)
namespace GeneSort.Core.Test.TwoOrbit
open System
open Xunit
open GeneSort.Core
open FSharp.UMX
open GeneSort.Core.TwoOrbitPairOps
open GeneSort.Core.PrototypeUnfolder

type TwoOrbitPairTests() =

    [<Fact>]
    let ``Create TwoOrbitPair with valid Ortho pair succeeds`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let order = 4
        let pair = TwoOrbitPair.create order orbit1 (orbit2 |> Some)
        Assert.Equal(orbit1, pair.FirstOrbit)
        Assert.Equal(orbit2, pair.SecondOrbit.Value)
        Assert.Equal(order, pair.Order)
        Assert.Equal(TwoOrbitPairType.Ortho, pair |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal((orbit1, orbit2), (pair.FirstOrbit, pair.SecondOrbit.Value))

    [<Fact>]
    let ``Create TwoOrbitPair with valid Para pair succeeds`` () =
        let orbit1 = TwoOrbit.create [2; 4]
        let orbit2 = TwoOrbit.create [3; 5]
        let order = 8
        let pair = TwoOrbitPair.create order orbit1 (orbit2 |> Some)
        Assert.Equal(orbit1, pair.FirstOrbit)
        Assert.Equal(orbit2, pair.SecondOrbit.Value)
        Assert.Equal(order, pair.Order)
        Assert.Equal(TwoOrbitPairType.Para, pair |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal((orbit1, orbit2), (pair.FirstOrbit, pair.SecondOrbit.Value))

    [<Fact>]
    let ``Create TwoOrbitPair with ReflectionSymmetric pair succeeds`` () =
        let orbit1 = TwoOrbit.create [1; 2]
        let orbit2 = TwoOrbit.create [0; 3]
        let order = 4
        let pair = TwoOrbitPair.create order orbit1 (orbit2 |> Some)
        Assert.Equal(orbit2, pair.FirstOrbit)
        Assert.Equal(orbit1, pair.SecondOrbit.Value)
        Assert.Equal(order, pair.Order)
        Assert.Equal(TwoOrbitPairType.SelfRefl, pair |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal((orbit2, orbit1), (pair.FirstOrbit, pair.SecondOrbit.Value))

    [<Fact>]
    let ``Create TwoOrbitPair with non-disjoint indices fails`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [1; 2]
        let order = 4
        Assert.Throws<Exception>(fun () -> TwoOrbitPair.create order orbit1 (orbit2 |> Some) |> ignore)

    [<Fact>]
    let ``Create TwoOrbitPair with order less than 4 fails`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let order = 3
        Assert.Throws<Exception>(fun () -> TwoOrbitPair.create order orbit1 (orbit2 |> Some) |> ignore)

    [<Fact>]
    let ``Create TwoOrbitPair with invalid orbit pair fails`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 4]
        let order = 4
        Assert.Throws<Exception>(fun () -> TwoOrbitPair.create order orbit1 (orbit2 |> Some) |> ignore)

    [<Fact>]
    let ``TwoOrbitPair equality with same orbits and order`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let order = 4
        let pair1 = TwoOrbitPair.create order orbit1 (orbit2 |> Some)
        let pair2 = TwoOrbitPair.create order orbit2 (orbit1 |> Some)
        Assert.True(pair1.Equals(pair2))
        Assert.Equal(pair1.GetHashCode(), pair2.GetHashCode())

    [<Fact>]
    let ``TwoOrbitPair inequality with different orbits`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let orbit3 = TwoOrbit.create [0; 3]
        let orbit4 = TwoOrbit.create [1; 2]
        let order = 4
        let pair1 = TwoOrbitPair.create order orbit1 (orbit2 |> Some)
        let pair2 = TwoOrbitPair.create order orbit3 (orbit4 |> Some)
        Assert.False(pair1.Equals(pair2))

    [<Fact>]
    let ``TwoOrbitPair inequality with different orders and orbits`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let orbit2s = TwoOrbit.create [4; 5]
        let pair1 = TwoOrbitPair.create 4 orbit1 (orbit2 |> Some)
        let pair2 = TwoOrbitPair.create 6 orbit1 (orbit2s |> Some)
        Assert.False(pair1.Equals(pair2))

    //unfoldTwoOrbitIntoTwoOrbitPair
    [<Fact>]
    let ``unfoldTwoOrbitIntoTwoOrbitPair with Ortho type creates correct TwoOrbitPair`` () =
        let twoOrbit = TwoOrbit.create [0; 1]
        let order = 4
        let pair = unfoldTwoOrbitIntoTwoOrbitPair twoOrbit order TwoOrbitType.Ortho
        let expectedFirst = TwoOrbit.create [0; 1]
        let expectedSecond = TwoOrbit.create [6; 7]
        Assert.Equal(expectedFirst, pair.FirstOrbit)
        Assert.Equal(expectedSecond, pair.SecondOrbit.Value)
        Assert.Equal(order * 2, pair.Order) // order * 2 = 8
        Assert.Equal(TwoOrbitPairType.Ortho, pair |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal((expectedFirst, expectedSecond), (pair.FirstOrbit, pair.SecondOrbit.Value))

    [<Fact>]
    let ``unfoldTwoOrbitIntoTwoOrbitPair with Para type creates correct TwoOrbitPair`` () =
        let twoOrbit = TwoOrbit.create [0; 1]
        let order = 4
        let pair = unfoldTwoOrbitIntoTwoOrbitPair twoOrbit order TwoOrbitType.Para
        let expectedFirst = TwoOrbit.create [0; 6]
        let expectedSecond = TwoOrbit.create [1; 7]
        Assert.Equal(expectedFirst, pair.FirstOrbit)
        Assert.Equal(expectedSecond, pair.SecondOrbit.Value)
        Assert.Equal(order * 2, pair.Order) // order * 2 = 8
        Assert.Equal(TwoOrbitPairType.Para, pair |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal((expectedFirst, expectedSecond), (pair.FirstOrbit, pair.SecondOrbit.Value))

    [<Fact>]
    let ``unfoldTwoOrbitIntoTwoOrbitPair with ReflectionSymmetric type creates correct TwoOrbitPair`` () =
        let twoOrbit = TwoOrbit.create [1; 2]
        let order = 4
        let pair = unfoldTwoOrbitIntoTwoOrbitPair twoOrbit order TwoOrbitType.SelfRefl
        let expectedFirst = TwoOrbit.create [1; 6]
        let expectedSecond = TwoOrbit.create [2; 5]
        Assert.Equal(expectedFirst, pair.FirstOrbit)
        Assert.Equal(expectedSecond, pair.SecondOrbit.Value)
        Assert.Equal(order * 2, pair.Order) // order * 2 = 8
        Assert.Equal(TwoOrbitPairType.SelfRefl, pair |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal((expectedFirst, expectedSecond), (pair.FirstOrbit, pair.SecondOrbit.Value))

    [<Fact>]
    let ``unfoldTwoOrbitIntoTwoOrbitPair with order less than 2 fails`` () =
        let twoOrbit = TwoOrbit.create [0; 1]
        let order = 1
        Assert.Throws<Exception>(fun () -> unfoldTwoOrbitIntoTwoOrbitPair twoOrbit order TwoOrbitType.Ortho |> ignore)


    [<Fact>]
    let ``makeTwoCycleFromRsOrbitPairTypes with no seed`` () =
        let types = [
                TwoOrbitType.SelfRefl; TwoOrbitType.Ortho; 
                TwoOrbitType.Para; TwoOrbitType.SelfRefl; 
                TwoOrbitType.Para; TwoOrbitType.Ortho; TwoOrbitType.Para]
        let perm_Rs = makePerm_SiFromTwoOrbitTypes None types
        Assert.Equal((perm_Rs.Order |> UMX.untag), 16)


    [<Fact>]
    let ``makeTwoCycleFromRsOrbitPairTypes with a seed`` () =
        let types = [TwoOrbitType.Para; TwoOrbitType.SelfRefl; 
                     TwoOrbitType.Para; TwoOrbitType.Ortho; 
                     TwoOrbitType.Para; TwoOrbitType.SelfRefl;]
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let pair = TwoOrbitPair.create 4 orbit1 (orbit2 |> Some)
        let perm_Rs = makePerm_SiFromTwoOrbitTypes (Some [pair]) types
        Assert.Equal((perm_Rs.Order |> UMX.untag), 16)


    [<Fact>]
    let ``makeAllRsTwoCyclesOfOrder`` () =
        let types = makeAllPerm_SisOfOrder 16 |> Seq.toList
        let setOf = types |> Set.ofList
        Assert.Equal(16, 16)


    [<Fact>]
    let ``makeRandomRsTwoCycles classic`` () =
        let randSeed = 123UL |> UMX.tag<randomSeed>
        let order = 32
        let randy = new randomLcg(randSeed)
        let res = makeRandomPerm_Sis randy order |> Seq.take 200000
        let seti = 
            res 
            |> Seq.groupBy(id)
            |> Seq.map (fun (len, arr) -> len, arr |> Seq.length)
            |> Seq.toArray
            |> Array.sortByDescending(snd)
        Assert.Equal(16, 16)
namespace GeneSort.Core.Test

open Xunit
open FsUnit.Xunit
open GeneSort.Core.ArrayProperties

type ArrayPropertiesTests() =

    // Tests for distanceSquared
    [<Fact>]
    let ``distanceSquared with equal float arrays returns zero`` () =
        let a = [|0.0; 0.0; 0.0|]
        let b = [|0.0; 0.0; 0.0|]
        let result = distanceSquared a b
        result |> should equal 0.0

    [<Fact>]
    let ``distanceSquared with different float arrays returns correct sum`` () =
        let a = [|1.0; 2.0; 3.0|]
        let b = [|0.0; 0.0; 0.0|]
        let result = distanceSquared a b
        result |> should equal 14.0  // 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14

    [<Fact>]
    let ``distanceSquared with integer arrays returns correct sum`` () =
        let a = [|1; 2; 3|]
        let b = [|0; 0; 0|]
        let result = distanceSquared a b
        result |> should equal 14

    // Tests for distanceSquaredOffset
    [<Fact>]
    let ``distanceSquaredOffset with matching arrays returns zero array`` () =
        let longArray = [|0.0; 0.0; 0.0; 0.0|]
        let shortArray = [|0.0; 0.0|]
        let result = distanceSquaredOffset longArray shortArray
        result |> should equal <| [|0.0; 0.0|]

    [<Fact>]
    let ``distanceSquaredOffset with float arrays returns correct distances`` () =
        let longArray = [|1.0; 0.0; 0.0; 1.0|]
        let shortArray = [|0.0; 0.0|]
        let result = distanceSquaredOffset longArray shortArray
        result |> should equal [|1.0; 1.0|]  // [(1-0)^2 + (0-0)^2; (0-0)^2 + (1-0)^2]

    [<Fact>]
    let ``distanceSquaredOffset with integer arrays returns correct distances`` () =
        let longArray = [|1; 0; 0; 1|]
        let shortArray = [|0; 0|]
        let result = distanceSquaredOffset longArray shortArray
        result |> should equal [|1; 1|]

    // Tests for isSorted
    [<Fact>]
    let ``isSorted with sorted array returns true`` () =
        let values = [|1; 2; 3; 4|]
        isSorted values |> should equal true

    [<Fact>]
    let ``isSorted with unsorted array returns false`` () =
        let values = [|1; 3; 2; 4|]
        isSorted values |> should equal false

    [<Fact>]
    let ``isSorted with empty array returns true`` () =
        let values = [||]
        isSorted values |> should equal true

    [<Fact>]
    let ``isSorted with single element returns true`` () =
        let values = [|1|]
        isSorted values |> should equal true

    [<Fact>]
    let ``isSorted with null array throws exception`` () =
        let values: int[] = null
        (fun () -> isSorted values |> ignore) |> should throw typeof<System.Exception>

    // Tests for isSortedOffset
    [<Fact>]
    let ``isSortedOffset with sorted segment returns true`` () =
        let values = [|5; 1; 2; 3; 4|]
        isSortedOffset values 1 3 |> should equal true

    [<Fact>]
    let ``isSortedOffset with unsorted segment returns false`` () =
        let values = [|5; 3; 2; 1; 4|]
        isSortedOffset values 1 3 |> should equal false

    [<Fact>]
    let ``isSortedOffset with single element returns true`` () =
        let values = [|1; 2; 3|]
        isSortedOffset values 1 1 |> should equal true

    [<Fact>]
    let ``isSortedOffset with zero length returns true`` () =
        let values = [|1; 2; 3|]
        isSortedOffset values 1 0 |> should equal true

    [<Fact>]
    let ``isSortedOffset with negative offset throws exception`` () =
        let values = [|1; 2; 3|]
        (fun () -> isSortedOffset values -1 2 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``isSortedOffset with negative length throws exception`` () =
        let values = [|1; 2; 3|]
        (fun () -> isSortedOffset values 0 -1 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``isSortedOffset with offset plus length exceeding array size throws exception`` () =
        let values = [|1; 2; 3|]
        (fun () -> isSortedOffset values 1 3 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``isSortedOffset with null array throws exception`` () =
        let values: int[] = null
        (fun () -> isSortedOffset values 0 1 |> ignore) |> should throw typeof<System.Exception>
namespace GeneSort.Core.Test

open Xunit
open GeneSort.Core
open BytePack

type BytePackTests() =

    // Helper function to parse a string of comma-separated bytes (e.g., "0b10110010,0b00001111")
    let parseByteArray (s: string) : byte[] =
        s.Split(',')
        |> Array.map (fun bs -> System.Convert.ToByte(bs.Trim(), 2))

    // Helper function to parse a string of comma-separated integers (e.g., "11,2,15")
    let parseIntArray (s: string) : int[] =
        s.Split(',')
        |> Array.map (fun n -> int (n.Trim()))

    let parseUInt64Array (s: string) : uint64[] =
        s.Split(',')
        |> Array.map (fun n -> uint64 (n.Trim()))

    let parseUInt8Array (s: string) : uint8[] =
        s.Split(',')
        |> Array.map (fun n -> uint8 (n.Trim()))

    let parseUInt16Array (s: string) : uint16[] =
        s.Split(',')
        |> Array.map (fun n -> uint16 (n.Trim()))

    let parseUInt32Array (s: string) : uint32[] =
        s.Split(',')
        |> Array.map (fun n -> uint32 (n.Trim()))


    [<Fact>]
    let ``toBitSequence converts byte array to correct boolean sequence`` () =
        let bp:BytePack = { bitsPerSymbol = 4; symbolCount = 2; data = parseByteArray "10110010,00001111" }
        let expected = [ true; false; true; true; false; false; true; false; 
                         false; false; false; false; true; true; true; true;  ]
        let actual = toBitSequence bp |> Seq.toList
        Assert.Equal<bool list>(expected, actual)


    [<Fact>]
    let ``toBitSequence handles empty data array`` () =
        let bp:BytePack = { bitsPerSymbol = 4; symbolCount = 0; data = [||] }
        let actual = toBitSequence bp |> Seq.toList
        Assert.Empty(actual)


    [<Theory>]
    [<InlineData(4, 3, "10110010,11110000", "11,2,15")>]
    [<InlineData(2, 4, "11001001", "3,0,2,1")>]
    [<InlineData(1, 8, "10110010", "1,0,1,1,0,0,1,0")>]
    let ``toSequenceOfInt converts bits to integers with MSB order`` (bitsPerSymbol: int, symbolCount: int, data: string, expected: string) =
        let bp:BytePack = { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = parseByteArray data }
        let expectedInts = parseIntArray expected
        let actual = toSequenceOfInt bp |> Seq.toList
        Assert.Equal<int list>(expectedInts |> Array.toList, actual)

    [<Fact>]
    let ``toSequenceOfInt throws when insufficient bits`` () =
        let bp:BytePack = { bitsPerSymbol = 4; symbolCount = 3; data = parseByteArray "10110010" } // 8 bits, need 12
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfInt bp |> Seq.toList |> ignore)
        Assert.Equal("Not enough bits in data: expected 12 bits for 3 symbols of 4 bits each, but got 8 bits", ex.Message)

    [<Theory>]
    [<InlineData("11,2,15", 4, 3, "10110010,11110000")>]
    [<InlineData("3,0,2,1", 2, 4, "11001001")>]
    [<InlineData("1,0,1,1,0,0,1,0", 1, 8, "10110010")>]
    let ``fromSequenceOfInt converts integers to BytePack with MSB order`` (ints: string, bitsPerSymbol: int, symbolCount: int, expectedData: string) =
        let inputInts = parseIntArray ints
        let bp:BytePack = fromSequenceOfInt inputInts bitsPerSymbol
        let expectedBytes = parseByteArray expectedData
        Assert.Equal(bitsPerSymbol, bp.bitsPerSymbol)
        Assert.Equal(symbolCount, bp.symbolCount)
        Assert.Equal<byte[]>(expectedBytes, bp.data)


    [<Fact>]
    let ``fromSequenceOfInt handles empty sequence`` () =
        let bp:BytePack = fromSequenceOfInt [] 4
        Assert.Equal(4, bp.bitsPerSymbol)
        Assert.Equal(0, bp.symbolCount)
        Assert.Empty(bp.data)


    [<Fact>]
    let ``fromSequenceOfInt throws on non-positive bitsPerSymbol`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfInt [1; 2; 3] 0 |> ignore)
        Assert.Equal("bitsPerSymbol must be positive", ex.Message)

    [<Theory>]
    [<InlineData("11,2,15", 4)>]
    [<InlineData("3,0,2,1", 2)>]
    [<InlineData("1,0,1,1,0,0,1,0", 1)>]
    let ``round-trip toSequenceOfInt and fromSequenceOfInt preserves data`` (ints: string, bitsPerSymbol: int) =
        let inputInts = parseIntArray ints
        let bp:BytePack = fromSequenceOfInt inputInts bitsPerSymbol
        let result = toSequenceOfInt bp |> Seq.toList
        Assert.Equal<int list>(inputInts |> Array.toList, result)


    // toBitSequence Tests
    [<Fact>]
    let ``toBitSequence converts byte array to correct boolean sequence`` () =
        let bp:BytePack = { bitsPerSymbol = 4; symbolCount = 2; data = parseByteArray "10110010,00001111" }
        let expected = [ true; false; true; true; false; false; true; false; 
                         false; false; false; false; true; true; true; true ]
        let actual = toBitSequence bp |> Seq.toList
        Assert.Equal<bool list>(expected, actual)

    [<Fact>]
    let ``toBitSequence handles empty data array`` () =
        let bp:BytePack = { bitsPerSymbol = 4; symbolCount = 0; data = [||] }
        let actual = toBitSequence bp |> Seq.toList
        Assert.Empty(actual)

    // toSequenceOfUInt64 Tests
    [<Theory>]
    [<InlineData(4, 3, "10110010,11110000", "11,2,15")>]
    [<InlineData(2, 4, "11001001", "3,0,2,1")>]
    [<InlineData(1, 8, "10110010", "1,0,1,1,0,0,1,0")>]
    [<InlineData(16, 1, "10110010,10110000", "45744")>] // 1011001011110000
    [<InlineData(32, 1, "10110010,11110000,00000000,00000000", "3002073088")>] // 10110010111100000000000000000000
    let ``toSequenceOfUInt64 converts bits to uint64 with MSB order`` (bitsPerSymbol: int, symbolCount: int, data: string, expected: string) =
        let bp:BytePack = { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = parseByteArray data }
        let expectedUInt64s = parseUInt64Array expected
        let actual = toSequenceOfUInt64 bp |> Seq.toList
        Assert.Equal<uint64 list>(expectedUInt64s |> Array.toList, actual)

    [<Fact>]
    let ``toSequenceOfUInt64 throws when bitsPerSymbol exceeds 64`` () =
        let bp:BytePack = { bitsPerSymbol = 65; symbolCount = 1; data = parseByteArray "10110010,11110000" }
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfUInt64 bp |> Seq.toList |> ignore)
        Assert.Equal("bitsPerSymbol (65) exceeds uint64 capacity (64 bits)", ex.Message)

    [<Fact>]
    let ``toSequenceOfUInt64 throws when bitsPerSymbol is non-positive`` () =
        let bp:BytePack = { bitsPerSymbol = 0; symbolCount = 1; data = parseByteArray "10110010" }
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfUInt64 bp |> Seq.toList |> ignore)
        Assert.Equal("bitsPerSymbol must be positive", ex.Message)

    [<Fact>]
    let ``toSequenceOfUInt64 throws when insufficient bits`` () =
        let bp:BytePack = { bitsPerSymbol = 4; symbolCount = 3; data = parseByteArray "10110010" } // 8 bits, need 12
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfUInt64 bp |> Seq.toList |> ignore)
        Assert.Equal("Not enough bits in data: expected 12 bits for 3 symbols of 4 bits each, but got 8 bits", ex.Message)

    // fromSequenceOfUInt64 Tests
    [<Theory>]
    [<InlineData("11,2,15", 4, 3, "10110010,11110000")>]
    [<InlineData("3,0,2,1", 2, 4, "11001001")>]
    [<InlineData("1,0,1,1,0,0,1,0", 1, 8, "10110010")>]
    [<InlineData("45744", 16, 1, "10110010,10110000")>]
    [<InlineData("3002073088", 32, 1, "10110010,11110000,00000000,00000000")>]
    let ``fromSequenceOfUInt64 converts uint64 to BytePack with MSB order`` (uint64s: string, bitsPerSymbol: int, symbolCount: int, expectedData: string) =
        let inputUInt64s = parseUInt64Array uint64s
        let bp = fromSequenceOfUInt64 inputUInt64s bitsPerSymbol
        let expectedBytes = parseByteArray expectedData
        Assert.Equal(bitsPerSymbol, bp.bitsPerSymbol)
        Assert.Equal(symbolCount, bp.symbolCount)
        Assert.Equal<byte[]>(expectedBytes, bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt64 handles empty sequence`` () =
        let bp = fromSequenceOfUInt64 [] 4
        Assert.Equal(4, bp.bitsPerSymbol)
        Assert.Equal(0, bp.symbolCount)
        Assert.Empty(bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt64 throws on non-positive bitsPerSymbol`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt64 [1uL; 2uL; 3uL] 0 |> ignore)
        Assert.Equal("bitsPerSymbol must be positive", ex.Message)

    [<Fact>]
    let ``fromSequenceOfUInt64 throws when bitsPerSymbol exceeds 64`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt64 [1uL; 2uL; 3uL] 65 |> ignore)
        Assert.Equal("bitsPerSymbol (65) exceeds uint64 capacity (64 bits)", ex.Message)

    [<Theory>]
    [<InlineData("11,2,15", 4)>]
    [<InlineData("3,0,2,1", 2)>]
    [<InlineData("1,0,1,1,0,0,1,0", 1)>]
    [<InlineData("45744", 16)>]
    [<InlineData("3003121664", 32)>]
    let ``toSequenceOfUInt64 and fromSequenceOfUInt64 round-trip preserves data`` (uint64s: string, bitsPerSymbol: int) =
        let inputUInt64s = parseUInt64Array uint64s
        let bp = fromSequenceOfUInt64 inputUInt64s bitsPerSymbol
        let result = toSequenceOfUInt64 bp |> Seq.toList
        Assert.Equal<uint64 list>(inputUInt64s |> Array.toList, result)

    // toSequenceOfUInt8 Tests
    [<Theory>]
    [<InlineData(4, 3, "10110010,11110000", "11,2,15")>]
    [<InlineData(2, 4, "11001001", "3,0,2,1")>]
    [<InlineData(1, 8, "10110010", "1,0,1,1,0,0,1,0")>]
    [<InlineData(8, 2, "10110010,11110000", "178,240")>]
    let ``toSequenceOfUInt8 converts bits to uint8 with MSB order`` (bitsPerSymbol: int, symbolCount: int, data: string, expected: string) =
        let bp:BytePack = { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = parseByteArray data }
        let expectedUInt8s = parseUInt8Array expected
        let actual = toSequenceOfUInt8 bp |> Seq.toList
        Assert.Equal<uint8 list>(expectedUInt8s |> Array.toList, actual)

    [<Fact>]
    let ``toSequenceOfUInt8 throws when bitsPerSymbol exceeds 8`` () =
        let bp:BytePack = { bitsPerSymbol = 9; symbolCount = 1; data = parseByteArray "10110010" }
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfUInt8 bp |> Seq.toList |> ignore)
        Assert.Equal("bitsPerSymbol (9) exceeds uint8 capacity (8 bits)", ex.Message)

    // fromSequenceOfUInt8 Tests
    [<Theory>]
    [<InlineData("11,2,15", 4, 3, "10110010,11110000")>]
    [<InlineData("3,0,2,1", 2, 4, "11001001")>]
    [<InlineData("1,0,1,1,0,0,1,0", 1, 8, "10110010")>]
    [<InlineData("178,240", 8, 2, "10110010,11110000")>]
    let ``fromSequenceOfUInt8 converts uint8 to BytePack with MSB order`` (uint8s: string, bitsPerSymbol: int, symbolCount: int, expectedData: string) =
        let inputUInt8s = parseUInt8Array uint8s
        let bp = fromSequenceOfUInt8 inputUInt8s bitsPerSymbol
        let expectedBytes = parseByteArray expectedData
        Assert.Equal(bitsPerSymbol, bp.bitsPerSymbol)
        Assert.Equal(symbolCount, bp.symbolCount)
        Assert.Equal<byte[]>(expectedBytes, bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt8 handles empty sequence`` () =
        let bp = fromSequenceOfUInt8 [] 4
        Assert.Equal(4, bp.bitsPerSymbol)
        Assert.Equal(0, bp.symbolCount)
        Assert.Empty(bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt8 throws on non-positive bitsPerSymbol`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt8 [1uy; 2uy; 3uy] 0 |> ignore)
        Assert.Equal("bitsPerSymbol must be positive", ex.Message)

    [<Fact>]
    let ``fromSequenceOfUInt8 throws when bitsPerSymbol exceeds 8`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt8 [1uy; 2uy; 3uy] 9 |> ignore)
        Assert.Equal("bitsPerSymbol (9) exceeds uint8 capacity (8 bits)", ex.Message)

    [<Theory>]
    [<InlineData("11,2,15", 4)>]
    [<InlineData("3,0,2,1", 2)>]
    [<InlineData("1,0,1,1,0,0,1,0", 1)>]
    [<InlineData("178,240", 8)>]
    let ``toSequenceOfUInt8 and fromSequenceOfUInt8 round-trip preserves data`` (uint8s: string, bitsPerSymbol: int) =
        let inputUInt8s = parseUInt8Array uint8s
        let bp = fromSequenceOfUInt8 inputUInt8s bitsPerSymbol
        let result = toSequenceOfUInt8 bp |> Seq.toList
        Assert.Equal<uint8 list>(inputUInt8s |> Array.toList, result)

    // toSequenceOfUInt16 Tests
    [<Theory>]
    [<InlineData(4, 3, "10110010,11110000", "11,2,15")>]
    [<InlineData(8, 2, "10110010,11110000", "178,240")>]
    [<InlineData(16, 1, "10110010,10110000", "45744")>]
    let ``toSequenceOfUInt16 converts bits to uint16 with MSB order`` (bitsPerSymbol: int, symbolCount: int, data: string, expected: string) =
        let bp:BytePack = { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = parseByteArray data }
        let expectedUInt16s = parseUInt16Array expected
        let actual = toSequenceOfUInt16 bp |> Seq.toList
        Assert.Equal<uint16 list>(expectedUInt16s |> Array.toList, actual)

    [<Fact>]
    let ``toSequenceOfUInt16 throws when bitsPerSymbol exceeds 16`` () =
        let bp:BytePack = { bitsPerSymbol = 17; symbolCount = 1; data = parseByteArray "10110010,11110000" }
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfUInt16 bp |> Seq.toList |> ignore)
        Assert.Equal("bitsPerSymbol (17) exceeds uint16 capacity (16 bits)", ex.Message)

    [<Theory>]
    [<InlineData("3,15,127", 7, 3, "00000110,00111111,11111000")>]
    [<InlineData("11,2,15", 4, 3, "10110010,11110000")>]
    [<InlineData("45744", 16, 1, "10110010,10110000")>]
    [<InlineData("15744,222", 15, 2, "01111011, 00000000, 00000011,01111000")>]
    let ``fromSequenceOfUInt16 converts uint16 to BytePack with MSB order`` (uint16s: string, bitsPerSymbol: int, symbolCount: int, expectedData: string) =
        let inputUInt16s = parseUInt16Array uint16s
        let bytePack:BytePack = fromSequenceOfUInt16 inputUInt16s bitsPerSymbol
        let expectedBytes = parseByteArray expectedData
        Assert.Equal(bitsPerSymbol, bytePack.bitsPerSymbol)
        Assert.Equal(symbolCount, bytePack.symbolCount)
        Assert.Equal<byte[]>(expectedBytes, bytePack.data)

    [<Fact>]
    let ``fromSequenceOfUInt16 handles empty sequence`` () =
        let bp = fromSequenceOfUInt16 [] 4
        Assert.Equal(4, bp.bitsPerSymbol)
        Assert.Equal(0, bp.symbolCount)
        Assert.Empty(bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt16 throws on non-positive bitsPerSymbol`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt16 [1us; 2us; 3us] 0 |> ignore)
        Assert.Equal("bitsPerSymbol must be positive", ex.Message)

    [<Fact>]
    let ``fromSequenceOfUInt16 throws when bitsPerSymbol exceeds 16`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt16 [1us; 2us; 3us] 17 |> ignore)
        Assert.Equal("bitsPerSymbol (17) exceeds uint16 capacity (16 bits)", ex.Message)

    [<Theory>]
    [<InlineData("11,2,15", 4)>]
    [<InlineData("178,240", 8)>]
    [<InlineData("45744", 16)>]
    let ``toSequenceOfUInt16 and fromSequenceOfUInt16 round-trip preserves data`` (uint16s: string, bitsPerSymbol: int) =
        let inputUInt16s = parseUInt16Array uint16s
        let bp = fromSequenceOfUInt16 inputUInt16s bitsPerSymbol
        let result = toSequenceOfUInt16 bp |> Seq.toList
        Assert.Equal<uint16 list>(inputUInt16s |> Array.toList, result)

    // toSequenceOfUInt32 Tests
    [<Theory>]
    [<InlineData(4, 3, "10110010,11110000", "11,2,15")>]
    [<InlineData(8, 2, "10110010,11110000", "178,240")>]
    [<InlineData(16, 1, "10110010,10110000", "45744")>]
    [<InlineData(32, 1, "10110010,11110000,00000000,00000000", "3002073088")>]
    [<InlineData(31, 2, "10110010,11110000,00000000,00000001,01100101,11100000,00000000,00000000", "1501036544,1501036544")>]
    let ``toSequenceOfUInt32 converts bits to uint32 with MSB order`` (bitsPerSymbol: int, symbolCount: int, data: string, expected: string) =
        let bp:BytePack = { bitsPerSymbol = bitsPerSymbol; symbolCount = symbolCount; data = parseByteArray data }
        let expectedUInt32s = parseUInt32Array expected
        let actual = toSequenceOfUInt32 bp |> Seq.toList
        Assert.Equal<uint32 list>(expectedUInt32s |> Array.toList, actual)

    [<Fact>]
    let ``toSequenceOfUInt32 throws when bitsPerSymbol exceeds 32`` () =
        let bp:BytePack = { bitsPerSymbol = 33; symbolCount = 1; data = parseByteArray "10110010,11110000" }
        let ex = Assert.Throws<System.Exception>(fun () -> toSequenceOfUInt32 bp |> Seq.toList |> ignore)
        Assert.Equal("bitsPerSymbol (33) exceeds uint32 capacity (32 bits)", ex.Message)

    // fromSequenceOfUInt32 Tests
    [<Theory>]
    [<InlineData("11,2,15", 4, 3, "10110010,11110000")>]
    [<InlineData("178,240", 8, 2, "10110010,11110000")>]
    [<InlineData("45744", 16, 1, "10110010,10110000")>]
    [<InlineData("3002073088", 32, 1, "10110010,11110000,00000000,00000000")>]
    [<InlineData("1501036544,1501036544", 31, 2, "10110010,11110000,00000000,00000001,01100101,11100000,00000000,00000000")>]
    let ``fromSequenceOfUInt32 converts uint32 to BytePack with MSB order`` (uint32s: string, bitsPerSymbol: int, symbolCount: int, expectedData: string) =
        let inputUInt32s = parseUInt32Array uint32s
        let bp = fromSequenceOfUInt32 inputUInt32s bitsPerSymbol
        let expectedBytes = parseByteArray expectedData
        Assert.Equal(bitsPerSymbol, bp.bitsPerSymbol)
        Assert.Equal(symbolCount, bp.symbolCount)
        Assert.Equal<byte[]>(expectedBytes, bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt32 handles empty sequence`` () =
        let bp = fromSequenceOfUInt32 [] 4
        Assert.Equal(4, bp.bitsPerSymbol)
        Assert.Equal(0, bp.symbolCount)
        Assert.Empty(bp.data)

    [<Fact>]
    let ``fromSequenceOfUInt32 throws on non-positive bitsPerSymbol`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt32 [1u; 2u; 3u] 0 |> ignore)
        Assert.Equal("bitsPerSymbol must be positive", ex.Message)

    [<Fact>]
    let ``fromSequenceOfUInt32 throws when bitsPerSymbol exceeds 32`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> fromSequenceOfUInt32 [1u; 2u; 3u] 33 |> ignore)
        Assert.Equal("bitsPerSymbol (33) exceeds uint32 capacity (32 bits)", ex.Message)

    [<Theory>]
    [<InlineData("11,2,15", 4)>]
    [<InlineData("178,240", 8)>]
    [<InlineData("45744", 16)>]
    [<InlineData("3003121664", 32)>]
    let ``toSequenceOfUInt32 and fromSequenceOfUInt32 round-trip preserves data`` (uint32s: string, bitsPerSymbol: int) =
        let inputUInt32s = parseUInt32Array uint32s
        let bp = fromSequenceOfUInt32 inputUInt32s bitsPerSymbol
        let result = toSequenceOfUInt32 bp |> Seq.toList
        Assert.Equal<uint32 list>(inputUInt32s |> Array.toList, result)
namespace GeneSort.Core.Test

open Xunit
open GeneSort.Core.CollectionUtils
open GeneSort.Core.ByteUtils
open FsUnit.Xunit
open GeneSort.Core
open System


type ByteUtilsTests() =


    [<Fact>]
    let ``Convert uint8 to binary string`` () =
        let value = 0b10100101uy
        let result = uint8ToBinaryString value
        let expected = "10100101"
        Assert.Equal(expected, result)

    [<Fact>]
    let ``Convert uint16 to binary string`` () =
        let value = 0b0101101010101010us
        let result = uint16ToBinaryString value
        let expected = "0101101010101010"
        Assert.Equal(expected, result)

    [<Fact>]
    let ``Convert uint32 to binary string`` () =
        let value = 0b01011010101001111000000011110000u
        let result = uint32ToBinaryString value
        let expected = "01011010101001111000000011110000"
        Assert.Equal(expected, result)

    [<Fact>]
    let ``Convert uint64 to binary string`` () =
        let value = 0b0101010110101010001100111100110000001111111100001111000011110000UL
        let result = uint64ToBinaryString value
        let expected = "0101010110101010001100111100110000001111111100001111000011110000"
        Assert.Equal(expected, result)

    [<Fact>]
    let ``Convert zero values to binary strings`` () =
        Assert.Equal("00000000", uint8ToBinaryString 0uy)
        Assert.Equal("0000000000000000", uint16ToBinaryString 0us)
        Assert.Equal("00000000000000000000000000000000", uint32ToBinaryString 0u)
        Assert.Equal("0000000000000000000000000000000000000000000000000000000000000000", uint64ToBinaryString 0UL)


namespace GeneSort.Core.Test

open Xunit
open GeneSort.Core.CollectionUtils
open FsUnit.Xunit

type CollectionUtilsTests() =

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=12, offset=3`` () =
        let result = steppedOffsetPairs 0 12 3 |> Seq.toList
        let expected = [(0,3); (1,4); (2,5); (6,9); (7,10); (8,11)]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=1 order=12, offset=3`` () =
        let result = steppedOffsetPairs 1 12 3 |> Seq.toList
        let expected = [(1,4); (2,5); (3,6); (7,10); (8,11)]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=18, offset=3`` () =
        let result = steppedOffsetPairs 0 18 3 |> Seq.toList
        let expected = [(0,3); (1,4); (2,5); (6,9); (7,10); (8,11); (12,15); (13,16); (14,17)]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=24, offset=3`` () =
        let result = steppedOffsetPairs 0 24 3 |> Seq.toList
        let expected = [(0, 3); (1, 4); (2, 5); (6, 9); (7, 10); (8, 11); (12, 15); (13, 16); (14, 17); (18, 21); (19, 22); (20, 23)]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=10, offset=3`` () =
        let result = steppedOffsetPairs 0 10 3 |> Seq.toList
        let expected = [(0, 3); (1, 4); (2, 5); (6, 9);]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=7, offset=2`` () =
        let result = steppedOffsetPairs 0 7 2 |> Seq.toList
        let expected = [(0,2); (1,3); (4,6)]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=1 order=7, offset=2`` () =
        let result = steppedOffsetPairs 1 7 2 |> Seq.toList
        let expected = [(1,3); (2,4);]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=1 order=7, offset=1`` () =
        let result = steppedOffsetPairs 1 7 1 |> Seq.toList
        let expected = [(1,2); (3,4); (5,6)]
        result |> should equal expected

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=0, offset=3 should return empty sequence`` () =
        let result = steppedOffsetPairs 0 0 3 |> Seq.toList
        result |> should be Empty

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=5, offset=5 should return empty sequence`` () =
        let result = steppedOffsetPairs 0 5 5 |> Seq.toList
        result |> should be Empty

    [<Fact>]
    let ``steppedOffsetPairs start=0 order=10, offset=0 should return empty sequence`` () =
        let result = steppedOffsetPairs 0 10 0 |> Seq.toList
        result |> should be Empty


    //pairWithNext
    [<Fact>]
    let ``pairWithNext with two integers returns a pair`` () =
        let input = seq [1; 2;]
        let result = pairWithNext input |> Seq.toList
        let expected = [(1, Some 2)]
        Assert.Equal<(int * int option) list>(expected, result)

    [<Fact>]
    let ``pairWithNext with three integers returns correct pairs`` () =
        let input = seq [1; 2; 3]
        let result = pairWithNext input |> Seq.toList
        let expected = [(1, Some 2); (3, None)]
        Assert.Equal<(int * int option) list>(expected, result)

    [<Fact>]
    let ``pairWithNext with single integer returns single pair with None`` () =
        let input = seq [42]
        let result = pairWithNext input |> Seq.toList
        let expected = [(42, None)]
        Assert.Equal<(int * int option) list>(expected, result)

    [<Fact>]
    let ``pairWithNext with empty sequence returns empty sequence`` () =
        let input = Seq.empty<int>
        let result = pairWithNext input |> Seq.toList
        Assert.Empty(result)

    [<Fact>]
    let ``pairWithNext with strings returns correct pairs`` () =
        let input = seq ["a"; "b"; "c"; "d"]
        let result = pairWithNext input |> Seq.toList
        let expected = [("a", Some "b"); ("c", Some "d");]
        Assert.Equal<(string * string option) list>(expected, result)

    [<Fact>]
    let ``pairWithNext with large sequence returns correct pairs`` () =
        let input = seq { 1 .. 11 }
        let result = pairWithNext input |> Seq.toList
        let expected = [ for i in 1 .. 5 -> (2*i - 1, Some (2*i)) ] @ [(11, None)]
        Assert.Equal<(int * int option) list>(expected, result)


    //chunkByPowersOfTwo
    [<Fact>]
    let ``chunkByPowersOfTwo with empty sequence returns empty sequence`` () =
        let input = Seq.empty<int>
        let result = chunkByPowersOfTwo 1 input
        Assert.Empty(result)

    [<Fact>]
    let ``chunkByPowersOfTwo with single element returns one chunk`` () =
        let input = seq [1]
        let result = chunkByPowersOfTwo 1 input |> Seq.toList
        Assert.Equal(1, result.Length)
        Assert.Equal<int list>([1], result.[0] |> Seq.toList)

    [<Fact>]
    let ``chunkByPowersOfTwo with exact power of 2 length (7 = 1+2+4) returns correct chunks`` () =
        let input = seq [1; 2; 3; 4; 5; 6; 7]
        let result = chunkByPowersOfTwo 1 input |> Seq.map Seq.toList |> Seq.toList
        let expected = [[1]; [2; 3]; [4; 5; 6; 7]]
        Assert.Equal(expected.Length, result.Length)
        Assert.Equal<int list>(expected.[0], result.[0])
        Assert.Equal<int list>(expected.[1], result.[1])
        Assert.Equal<int list>(expected.[2], result.[2])

    [<Fact>]
    let ``chunkByPowersOfTwo with non-power-of-2 length (9) returns correct chunks`` () =
        let input = seq [1; 2; 3; 4; 5; 6; 7; 8; 9]
        let result = chunkByPowersOfTwo 1 input |> Seq.map Seq.toList |> Seq.toList
        let expected = [[1]; [2; 3]; [4; 5; 6; 7]; [8; 9]]
        Assert.Equal(expected.Length, result.Length)
        Assert.Equal<int list>(expected.[0], result.[0])
        Assert.Equal<int list>(expected.[1], result.[1])
        Assert.Equal<int list>(expected.[2], result.[2])
        Assert.Equal<int list>(expected.[3], result.[3])


    [<Fact>]
    let ``chunkByPowersOfTwo with large sequence returns correct chunks`` () =
        let input = seq { 1 .. 20 }
        let result = chunkByPowersOfTwo 1 input |> Seq.map Seq.toList |> Seq.toList
        let expected = [[1]; [2; 3]; [4; 5; 6; 7]; [8; 9; 10; 11; 12; 13; 14; 15]; [16; 17; 18; 19; 20]]
        Assert.Equal(expected.Length, result.Length)
        Assert.Equal<int list>(expected.[0], result.[0])
        Assert.Equal<int list>(expected.[1], result.[1])
        Assert.Equal<int list>(expected.[2], result.[2])
        Assert.Equal<int list>(expected.[3], result.[3])
        Assert.Equal<int list>(expected.[4], result.[4])


    [<Fact>]
    let ``chunkByPowersOfTwo with non-zero startingPower large sequence returns correct chunks`` () =
        let input = seq { 1 .. 20 }
        let startingMultiple = 4
        let result = chunkByPowersOfTwo startingMultiple input |> Seq.map Seq.toList |> Seq.toList
        let expected = [[1; 2; 3; 4]; [5; 6; 7; 8; 9; 10; 11; 12]; [13; 14; 15; 16; 17; 18; 19; 20]]
        Assert.Equal(expected.Length, result.Length)
        Assert.Equal<int list>(expected.[0], result.[0])
        Assert.Equal<int list>(expected.[1], result.[1])
        Assert.Equal<int list>(expected.[2], result.[2])


    [<Fact>]
    let ``chunkByPowersOfTwo preserves element order within chunks`` () =
        let input = seq ['a'; 'b'; 'c'; 'd'; 'e']
        let result = chunkByPowersOfTwo 1 input |> Seq.map Seq.toList |> Seq.toList
        let expected = [['a']; ['b'; 'c']; ['d'; 'e']]
        Assert.Equal(expected.Length, result.Length)
        Assert.Equal<char list>(expected.[0], result.[0])
        Assert.Equal<char list>(expected.[1], result.[1])
        Assert.Equal<char list>(expected.[2], result.[2])
namespace GeneSort.Core.Test

open Xunit
open GeneSort.Core.Combinatorics
open FsUnit.Xunit
open FSharp.UMX
open GeneSort.Core

type CombinatoricsTests() =

    [<Fact>]
    let ``Empty list of lists returns empty sequence`` () =
        let input = []
        let result = cartesianProduct input |> Seq.toList
        result |> Seq.isEmpty |> should equal true

    [<Fact>]
    let ``Single empty list returns empty sequence`` () =
        let input = [[]]
        let result = cartesianProduct input |> Seq.toList
        result |> Seq.isEmpty |> should equal true

    [<Fact>]
    let ``Single list returns sequence of single-element lists`` () =
        let input = [[1; 2; 3]]
        let result = cartesianProduct input |> Seq.toList
        result |> should equal [[1]; [2]; [3]]

    [<Fact>]
    let ``Two lists return correct Cartesian product`` () =
        let input = [[1; 2]; [3; 4]]
        let result = cartesianProduct input |> Seq.toList
        result |> should equal [[1; 3]; [1; 4]; [2; 3]; [2; 4]]

    [<Fact>]
    let ``Three lists return correct Cartesian product`` () =
        let input = [[1]; [2; 3]; [4; 5]]
        let result = cartesianProduct input |> Seq.toList
        result |> should equal [[1; 2; 4]; [1; 2; 5]; [1; 3; 4]; [1; 3; 5]]

    [<Fact>]
    let ``Lists with single elements return single combination`` () =
        let input = [[1]; [2]; [3]]
        let result = cartesianProduct input |> Seq.toList
        result |> should equal [[1; 2; 3]]

    [<Fact>]
    let ``One empty list among others returns empty sequence`` () =
        let input = [[1; 2]; []; [3; 4]]
        let result = cartesianProduct input |> Seq.toList
        result |> Seq.isEmpty |> should equal true

    [<Fact>]
    let ``Lists with strings return correct Cartesian product`` () =
        let input = [["a"; "b"]; ["c"]]
        let result = cartesianProduct input |> Seq.toList
        result |> should equal [["a"; "c"]; ["b"; "c"]]

    [<Fact>]
    let ``Large lists produce correct number of combinations`` () =
        let input = [[1; 2]; [3; 4]; [5; 6]]
        let result = cartesianProduct input |> Seq.length
        result |> should equal 8 // 2 * 2 * 2 = 8 combinations


    let input: list<string * list<string>> = [
        ("key1", [("desc1"); ("desc2")])
        ("key2", [("desc3"); ("desc4")])
    ]

    [<Fact>]
    let ``cartesianProductMaps with empty input returns empty sequence`` () =
        let result = cartesianProductMaps [] |> Seq.toList
        result |> should be Empty

    [<Fact>]
    let ``cartesianProductMaps with single key returns single-entry maps`` () =
        let input = [("key1", [("desc1"); ("desc2")])]
        let expected = [
            Map.ofList [("key1", ("desc1"))]
            Map.ofList [("key1", ("desc2"))]
        ]
        let result = cartesianProductMaps input |> Seq.toList
        result |> should equal expected

    [<Fact>]
    let ``cartesianProductMaps with multiple keys returns correct combinations`` () =
        let expected = [
            Map.ofList [("key1", ("desc1")); ("key2", ("desc3"))]
            Map.ofList [("key1", ("desc1")); ("key2", ("desc4"))]
            Map.ofList [("key1", ("desc2")); ("key2", ("desc3"))]
            Map.ofList [("key1", ("desc2")); ("key2", ("desc4"))]
        ]
        let result = cartesianProductMaps input |> Seq.toList
        result |> should haveLength 4
        result |> should equal expected

    [<Fact>]
    let ``cartesianProductMaps with empty value list returns empty sequence`` () =
        let input = [("key1", []); ("key2", [("desc3")])]
        let result = cartesianProductMaps input |> Seq.toList
        result |> should be Empty

    [<Fact>]
    let ``findMapIndex with matching map returns correct index`` () =
        let targetMap = Map.ofList [("key1", ("desc1")); ("key2", ("desc3"))]
        let index = findMapIndex targetMap input
        index |> should equal (Some 0)

    [<Fact>]
    let ``findMapIndex with another matching map returns correct index`` () =
        let targetMap = Map.ofList [("key1", ("desc2")); ("key2", ("desc4"))]
        let index = findMapIndex targetMap input
        index |> should equal (Some 3)

    [<Fact>]
    let ``findMapIndex with invalid key returns None`` () =
        let targetMap = Map.ofList [("key1", ("desc1")); ("key3", ("desc5"))]
        let index = findMapIndex targetMap input
        index |> should equal None

    [<Fact>]
    let ``findMapIndex with missing key returns None`` () =
        let targetMap = Map.ofList [("key1", ("desc1"))]
        let index = findMapIndex targetMap input
        index |> should equal None

    [<Fact>]
    let ``findMapIndex with invalid value returns None`` () =
        let targetMap = Map.ofList [("key1", ("desc1")); ("key2", ("desc5"))]
        let index = findMapIndex targetMap input
        index |> should equal None

    [<Fact>]
    let ``findMapIndex with empty input returns None`` () =
        let targetMap = Map.ofList [("key1", ("desc1"))]
        let index = findMapIndex targetMap []
        index |> should equal None
namespace GeneSort.Core.Test

open Xunit
open FSharp.UMX
open GeneSort.Core
open GeneSort.Core.CollectionUtils
open GeneSort.Core.Permutation
open GeneSort.Core.PermutationSets
open GeneSort.Core.CoreGen
open System

type CoreGenTests() =

    [<Fact>]
    let ``randomPermutations generates distinct permutations`` () =
        let permutationCount = 100
        let order = 32
        let randomSeed = 123UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(randomSeed);
        let perms = randomPermutations order randy 
                    |> Seq.take permutationCount
                    |> toDictionary false None (fun p -> p.Id)


        Assert.Equal(perms.Count, permutationCount)

    [<Fact>]
    let ``A permutation and it's conjugate generates the same sized cyclic group `` () =
        let permutationCount = 50
        let order = 16
        let randomSeed = 17423UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(randomSeed);
        let perms = randomPermutations order randy 
                    |> Seq.take permutationCount
                    |> Seq.toArray

        let conjies = randomPermutations order randy 
                    |> Seq.take permutationCount
                    |> Seq.toArray

        for i = 0 to permutationCount - 1 do
            let perm = perms.[i]
            let permSet = makeCyclicGroup perm |> Seq.toArray
            let conj = conjugate perms.[i] conjies.[i]
            let conjSet = makeCyclicGroup conj |> Seq.toArray
            Console.WriteLine(permSet.Length)
            Assert.Equal(permSet.Length, conjSet.Length)
            
    [<Fact>]
    let ``A permutation and it's conjugate generates the same sized cyclic group `` () =
        let permutationCount = 50
        let order = 16
        let randomSeed = 17423UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(randomSeed);
        let perms = randomPermutations order randy 
                    |> Seq.take permutationCount
                    |> Seq.toArray

        let conjies = randomPermutations order randy 
                    |> Seq.take permutationCount
                    |> Seq.toArray

        for i = 0 to permutationCount - 1 do
            let perm = perms.[i]
            let permSet = makeCyclicGroup perm |> Seq.toArray
            let conj = conjugate perms.[i] conjies.[i]
            let conjSet = makeCyclicGroup conj |> Seq.toArray
            Console.WriteLine(permSet.Length)
            Assert.Equal(permSet.Length, conjSet.Length)
            

            
    [<Fact>]
    let ``Histogram of permutation group length`` () =
        let permutationCount = 100
        let order = 16
        let randomSeed = 17423UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(randomSeed)
        let perms = randomPermutations order randy 
                    |> Seq.take permutationCount
                    |> Seq.toArray


        // Collect lengths of permSet
        let lengths = 
            [| for i = 0 to permutationCount - 1 do
                let perm = perms.[i]
                let permSet = makeCyclicGroup perm |> Seq.toArray
                yield permSet.Length |]

        // Create histogram data
        let histogram = 
            lengths
            |> Array.groupBy id
            |> Array.map (fun (len, arr) -> len, arr.Length)
            |> Array.sortBy fst
            |> Array.map (fun (len, count) -> len, count, String.replicate (count / 10) "*") // Scale for display

        // Print histogram
        System.Diagnostics.Debug.WriteLine("\nHistogram of permSet.Length:")
        System.Diagnostics.Debug.WriteLine("Length | Count | Visual")
        System.Diagnostics.Debug.WriteLine("-------|-------|-------")
        for (len, count, bars) in histogram do
            System.Diagnostics.Debug.WriteLine($"{len,-6} | {count,-5} | {bars}")
    
        Assert.Equal(1, 1)


    [<Fact>]
    let ``Cycles of identity permutation returns only identity`` () =
        let id = identity 4
        let cycles = makeCyclicGroup id |> Seq.toList
        let expected = [identity 4]
        Assert.Equal<int array list>(List.map (fun (p: Permutation) -> p.Array) expected, 
                                     List.map (fun (p: Permutation) -> p.Array) cycles)


    [<Fact>]
    let ``The conjugate of a Perm_Rs is a Perm_Rs`` () =
        let testCount = 50
        let order = 16
        let randomSeed = 17423UL |> UMX.tag<randomSeed>
        let randy = new randomLcg(randomSeed);
        let perm_Rss = randomSaturatedPerm_Si order randy 
                        |> Seq.take testCount
                        |> Seq.toArray

        let conjies = randomPermutations order randy 
                    |> Seq.take testCount
                    |> Seq.toArray

        for i = 0 to testCount - 1 do
            let conj = Perm_Si.conjugate perm_Rss.[i] conjies.[i]
            Assert.True (conj.Permutation |> Permutation.isSelfInverse)
            
namespace GeneSort.Core.Test

open Xunit
open FsUnit.Xunit
open System
open GeneSort.Core
open GeneSort.Core.OrbitSet

type OrbitSetTests() =

    [<Fact>]
    let ``Create valid orbit set with disjoint orbits covering all indices`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [2; 3]
        let (orbitSet) = OrbitSet.create [orbit1; orbit2] 4
        orbitSet.Orbits |> List.map (fun o -> o.Indices) |> should equal [[0; 1]; [2; 3]]
        orbitSet.Order |> should equal 4

    [<Fact>]
    let ``Create empty orbit set with order 0`` () =
        let ex = Assert.Throws<Exception>(fun () -> OrbitSet.create [] 0 |> ignore)
        ex.Message |> should equal "orbits cannot be empty"


    [<Fact>]
    let ``Fail to create orbit set with negative order`` () =
        let orbit = Orbit.create [0; 1]
        (fun () -> OrbitSet.create [orbit] -1 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``Fail to create orbit set with non-disjoint orbits`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [1; 2]
        (fun () -> OrbitSet.create [orbit1; orbit2] 3 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``Fail to create orbit set with incomplete coverage`` () =
        let orbit = Orbit.create [0; 1]
        (fun () -> OrbitSet.create [orbit] 3 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``Fail to create orbit set with duplicate orbits`` () =
        let orbit = Orbit.create [0; 1]
        (fun () -> OrbitSet.create [orbit; orbit] 2 |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``Orbit sets with same orbits and order are equal`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [2; 3]
        let set1 = OrbitSet.create [orbit1; orbit2] 4
        let set2 = OrbitSet.create [orbit2; orbit1] 4 // Different input order, same normalized
        set1.Equals(set2) |> should be True
        set1.GetHashCode() |> should equal (set2.GetHashCode())

    [<Fact>]
    let ``Orbit sets with different orbits or order are not equal`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [2; 3]
        let set1 = OrbitSet.create [orbit1; orbit2] 4
        let set2 = OrbitSet.create [orbit1] 2
        set1.Equals(set2) |> should be False

    [<Fact>]
    let ``To orbit notation for non-empty orbit set`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [2; 3]
        let orbitSet = OrbitSet.create [orbit1; orbit2] 4
        toOrbitNotation orbitSet |> should equal "(0 1)(2 3)"

    [<Fact>]
    let ``Get reflection symmetric orbits`` () =
        let orbit1 = Orbit.create [0; 3] // Reflects to [3; 0] (same orbit)
        let orbit2 = Orbit.create [1; 2] // Reflects to [2; 1] (same orbit)
        let orbitSet = OrbitSet.create [orbit1; orbit2] 4
        let symmetric = getReflectionPartnerOrbits orbitSet
        symmetric |> List.map (fun o -> o.Indices) |> should equal [[0; 3]; [1; 2]]

    [<Fact>]
    let ``Get reflection symmetric orbits with no symmetric pairs`` () =
        let orbit1 = Orbit.create [0; 1; 2] // Reflects to [2; 1; 0] (different orbit)
        let orbitSet = OrbitSet.create [orbit1] 3
        let symmetric = getReflectionPartnerOrbits orbitSet
        symmetric.Length |> should equal 0
namespace GeneSort.Core.Test

open Xunit
open FsUnit.Xunit
open System.Collections.Generic
open GeneSort.Core
open GeneSort.Core.Orbit

// Custom equality comparer for Orbit to use in HashSet
type OrbitEqualityComparer() =
    interface IEqualityComparer<Orbit> with
        member _.Equals(x: Orbit, y: Orbit) = x.Equals(y)
        member _.GetHashCode(orbit: Orbit) = orbit.GetHashCode()

type OrbitTests() =

    [<Fact>]
    let ``Create valid orbit with unique non-negative indices`` () =
        let indices = [2; 0; 1]
        let orbit = Orbit.create indices
        orbit.Indices |> should equal [0; 1; 2] // Normalized with smallest index first

    [<Fact>]
    let ``Create empty orbit`` () =
        let orbit = Orbit.create []
        orbit.Indices.Length |> should equal 0

    [<Fact>]
    let ``Fail to create orbit with negative indices`` () =
        let indices = [1; -2; 3]
        (fun () -> Orbit.create indices |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``Fail to create orbit with duplicate indices`` () =
        let indices = [1; 2; 1]
        (fun () -> Orbit.create indices |> ignore) |> should throw typeof<System.Exception>

    [<Fact>]
    let ``Orbits with same normalized indices are equal`` () =
        let orbit1 = Orbit.create [2; 0; 1]
        let orbit2 = Orbit.create [0; 1; 2]
        orbit1.Equals(orbit2) |> should be True
        orbit1.GetHashCode() |> should equal (orbit2.GetHashCode())

    [<Fact>]
    let ``Orbits with different indices are not equal`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [0; 2]
        orbit1.Equals(orbit2) |> should be False

    [<Fact>]
    let ``Get reflection of orbit`` () =
        let orbit = Orbit.create [0; 1; 2]
        let reflected = getReflection 3 orbit
        reflected.Indices |> should equal [0; 2; 1] // Reflection about (3-1)/2 = 1

    [<Fact>]
    let ``Get reflection of orbit with order 4`` () =
        let orbit = Orbit.create [0; 2]
        let reflected = getReflection 4 orbit
        reflected.Indices |> should equal [1; 3] // Reflection: 0 -> 3, 2 -> 1


    [<Fact>]
    let ``Orbits in HashSet collection handle equality correctly`` () =
        let orbit1 = Orbit.create [2; 5; 0]
        let orbit2 = Orbit.create [5; 0; 2]
        let orbit3 = Orbit.create [1; 3; 4]
        let orbitSet = HashSet<Orbit>(OrbitEqualityComparer())
        orbitSet.Add orbit1 |> should be True
        orbitSet.Add orbit2 |> should be False // orbit2 is equal to orbit1, so not added
        orbitSet.Add orbit3 |> should be True  // orbit3 is distinct, so added
        orbitSet.Count |> should equal 2
        orbitSet.Contains orbit1 |> should be True
        orbitSet.Contains orbit2 |> should be True
        orbitSet.Contains orbit3 |> should be True

    [<Fact>]
    let ``GetHashCode is consistent across equal orbits`` () =
        let orbit1 = Orbit.create [2; 5; 0]
        let orbit2 = Orbit.create [5; 0; 2]
        let orbit3 = Orbit.create [0; 2; 5]
        orbit1.GetHashCode() |> should equal (orbit2.GetHashCode())
        orbit1.GetHashCode() |> should equal (orbit3.GetHashCode())
namespace GeneSort.Core.Test
open FSharp.UMX
open Xunit
open GeneSort.Core.CoreGen
open GeneSort.Core
open FsUnit.Xunit

type TwoCycleGenTests() =

    let parseIntArray (s: string) : int[] =
        s.Split(',')
        |> Array.map (fun n -> int (n.Trim()))

    [<Theory>]
    [<InlineData("1,0,3,2", "1,0,3,2")>]
    [<InlineData("1,0,2,4,3", "1,0,2,4,3")>]
    [<InlineData("4,1,0,3,5,2", "4,5,2,3,0,1")>]
    [<InlineData("4,1,2,7,6,5,0,3", "4,1,2,7,0,5,6,3")>]
    let ``decodePermutations`` (code: string, expected: string) =
        let codeA = parseIntArray code
        let expectedDecodeA = parseIntArray expected
        let permOfCode = Permutation.create codeA
        let perm_RsRSA = PermRsGen_old.decodePermutation permOfCode
        perm_RsRSA.Array |> should equal expectedDecodeA

    [<Fact>]
    let ``decoded TwoCycleRS orbit stats made from random Permutations`` () =
        let permSize = 512
        let permCount = 1000
        let perms = randomPermutations permSize (new randomLcg (9234UL |> UMX.tag<randomSeed>))
                    |> Seq.take permCount |> Seq.toArray
        let decodedTwoCycleRSAs = 
                perms 
                |> Array.map(PermRsGen_old.decodePermutation)


        //let orbitCounts = 
        //        decodedTwoCycleRSAs
        //        |> Array.map(fun tsRS -> tsRS.Perm_Rs |> Perm_Rs.countOrbits)


        //let ocHisto =
        //        orbitCounts
        //           |> Array.groupBy(id)
        //           |> Array.sortBy (fst)
        //           |> Array.map (fun (k, arr) -> (k, arr.Length))


        //let pos7histo = 
        //           decodedTwoCycleRSAs |> Array.map(fun dc -> dc.Array.[6])
        //           |> Array.groupBy(id)
        //           |> Array.sortBy (fst)
        //           |> Array.map (fun (k, arr) -> (k, arr.Length))


        1 |> should equal 1


    [<Fact>]
    let ``all the orbits made by TwoCycleRS rndSymmetric are RS (for even order)`` () =
        let permSize = 32
        let perm_RsCount = 10
        let randy = new randomLcg (9234UL |> UMX.tag<randomSeed>)
        let perm_RsRSAs = Array.init perm_RsCount (fun _ -> PermRsGen_old.rndSymmetric permSize randy)

        1|> should equal 1
namespace GeneSort.Core.Test

open Xunit
open GeneSort.Core
open GeneSort.Core.PermutationSets

type PermutationSetsTests() =

    [<Fact>]
    let ``Powers of permutation are correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        let cycles = makeCyclicGroup p |> Seq.toList
        let expected = [
            Permutation.create [|1; 2; 0; 3|]; // p
            Permutation.create [|2; 0; 1; 3|]; // p^2
            Permutation.create [|0; 1; 2; 3|]  // p^3 = identity
        ]
        Assert.Equal<int array list>(List.map (fun (p: Permutation) -> p.Array) expected, List.map (fun (p: Permutation) -> p.Array) cycles)

    [<Fact>]
    let ``Cycles of identity permutation returns only identity`` () =
        let id = Permutation.identity 4
        let cycles = makeCyclicGroup id |> Seq.toList
        let expected = [Permutation.identity 4]
        Assert.Equal<int array list>(List.map (fun (p: Permutation) -> p.Array) expected, List.map (fun (p: Permutation) -> p.Array) cycles)
namespace GeneSort.Core.Test
open System
open Xunit
open FsUnit.Xunit
open GeneSort.Core.Permutation
open GeneSort.Core
open GeneSort.Core.OrbitSet

type PermutationTests() =

    [<Fact>]
    let ``Identity permutation is valid`` () =
        let id = identity 4
        Assert.Equal<int>([|0; 1; 2; 3|], id.Array)
        Assert.True(Array.forall2 (fun i v -> i = v) [|0 .. 3|] (Array.sort id.Array))

    [<Fact>]
    let ``Rotated identity by 1 is correct`` () =
        let r = rotated 1 4
        Assert.Equal<int>([|1; 2; 3; 0|], r.Array) // Expected: (0 1 2 3)

    [<Fact>]
    let ``Rotated identity by -1 is correct`` () =
        let r = rotated -1 4
        Assert.Equal<int>([|3; 0; 1; 2|], r.Array) // Expected: (0 3 2 1)

    [<Fact>]
    let ``Rotated identity by 0 is identity`` () =
        let r = rotated 0 4
        Assert.Equal<int>([|0; 1; 2; 3|], r.Array) // Expected: (0)(1)(2)(3)

    [<Fact>]
    let ``Rotated identity by n is identity`` () =
        let r = rotated 4 4
        Assert.Equal<int>([|0; 1; 2; 3|], r.Array) // Expected: (0)(1)(2)(3)

    [<Fact>]
    let ``Rotated with invalid order throws exception`` () =
        Assert.Throws<System.Exception>(fun () -> rotated 1 0 |> ignore)

    [<Fact>]
    let ``Orbit notation of rotated identity is correct`` () =
        let r = rotated 1 4
        Assert.Equal("(0 1 2 3)", toOrbitNotation (r |> Permutation.toOrbitSet) )

    [<Fact>]
    let ``Identity permutation has all indices as fixed points`` () =
        let perm = Permutation.createUnsafe [|0; 1; 2; 3|]
        let fixedPoints = getFixedPoints perm
        fixedPoints |> should equal [|0; 1; 2; 3|]

    [<Fact>]
    let ``Permutation with no fixed points returns empty array`` () =
        let perm = Permutation.createUnsafe [|1; 0; 3; 2|]
        let fixedPoints = getFixedPoints perm
        fixedPoints |> should equal [||]

    [<Fact>]
    let ``Permutation with some fixed points returns correct indices`` () =
        let perm = Permutation.createUnsafe [|0; 2; 2; 3|]
        let fixedPoints = getFixedPoints perm
        fixedPoints |> should equal [|0; 2; 3|]

    [<Fact>]
    let ``Empty permutation returns empty fixed points`` () =
        let perm = Permutation.createUnsafe [||]
        let fixedPoints = getFixedPoints perm
        fixedPoints |> should equal [||]

    [<Fact>]
    let ``Single element permutation has that element as fixed point`` () =
        let perm = Permutation.createUnsafe [|0|]
        let fixedPoints = getFixedPoints perm
        fixedPoints |> should equal [|0|]


    [<Fact>]
    let ``Composition of two permutations is correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        let q = Permutation.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let result = compose p q
        Assert.Equal<int>([|0; 3; 1; 2|], result.Array) // Expected: (0)(1 3 2)

    [<Fact>]
    let ``Orbit notation of composition is correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        let q = Permutation.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let result = compose p q
        Assert.Equal("(0)(1 3 2)", toOrbitNotation (result |> Permutation.toOrbitSet) )

    [<Fact>]
    let ``Composition with mismatched orders throws exception`` () =
        let p = Permutation.create [|1; 2; 0|]
        let q = Permutation.create [|1; 0; 3; 2|]
        Assert.Throws<System.Exception>(fun () -> compose p q |> ignore)

    [<Fact>]
    let ``Inverse of permutation is correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        let inv = inverse p
        Assert.Equal<int>([|2; 0; 1; 3|], inv.Array) // Expected: (0 2 1)(3)
        Assert.Equal<int>((identity 4).Array, (compose p inv).Array)
        Assert.Equal<int>((identity 4).Array, (compose inv p).Array)

    [<Fact>]
    let ``Conjugate of permutation is correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        let q = Permutation.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let result = Permutation.conjugate p q
        Assert.Equal<int>([|3; 0; 2; 1|], result.Array) // Expected: (0 3 1)(2)

    [<Fact>]
    let ``Conjugate with mismatched orders throws exception`` () =
        let p = Permutation.create [|1; 2; 0|]
        let q = Permutation.create [|1; 0; 3; 2|]
        Assert.Throws<System.Exception>(fun () -> Permutation.conjugate p q |> ignore)
    
    [<Fact>]
    let ``Orbits of permutation are correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        let expected = [[0; 1; 2]; [3]]
        let actual = (p |> Permutation.toOrbitSet).Orbits |> List.map (fun orbit -> (orbit.Indices))
        actual |> should equal expected

    [<Fact>]
    let ``Orbits of identity permutation are singletons`` () =
        let id = identity 3
        let expected = [[0]; [1]; [2]]
        let actual = (id |> Permutation.toOrbitSet).Orbits |> List.map (fun orbit -> orbit.Indices)
        actual |> should equal expected

    [<Fact>]
    let ``Permutation with fixed points returns the correct orbits`` () =
        // Permutation [1; 0; 2; 4; 3] has cycles (0,1), (2), (3,4)
        let perm = Permutation.createUnsafe [|1; 0; 2; 4; 3|]
        let orbits = (perm |> Permutation.toOrbitSet).Orbits |> List.map (fun orbit -> orbit.Indices)
        orbits |> should equal [ [0; 1]; [2]; [3; 4] ]

    [<Fact>]
    let ``Identity permutation returns fixed points`` () =
        // Permutation [0; 1; 2; 3] has only fixed points
        let perm = Permutation.createUnsafe [|0; 1; 2; 3|]
        let orbits = (perm |> Permutation.toOrbitSet).Orbits |> List.map (fun orbit -> orbit.Indices)
        orbits |> should equal [ [0]; [1]; [2]; [3] ]

    [<Fact>]
    let ``Permutation with only non-trivial cycle returns that cycle`` () =
        // Permutation [1; 2; 0] has cycle (0,1,2)
        let perm = Permutation.createUnsafe [|1; 2; 0|]
        let orbits = (perm|> Permutation.toOrbitSet).Orbits |> List.map (fun orbit -> orbit.Indices)
        orbits |> should equal [ [0; 1; 2] ]

    [<Fact>]
    let ``Permutation with multiple cycles returns all`` () =
        // Permutation [2; 0; 1; 4; 3] has cycles (0,2,1), (3,4)
        let perm = Permutation.createUnsafe [|2; 0; 1; 4; 3|]
        let orbits = (perm |> Permutation.toOrbitSet).Orbits |> List.map (fun orbit -> orbit.Indices)
        orbits |> should equal [ [0; 2; 1]; [3; 4] ]

    [<Fact>]
    let ``Orbit notation of identity is correct`` () =
        let id = identity 4
        Assert.Equal("(0)(1)(2)(3)", toOrbitNotation (id |> Permutation.toOrbitSet))

    [<Fact>]
    let ``Orbit notation of permutation is correct`` () =
        let p = Permutation.create [|1; 2; 0; 3|] // (0 1 2)(3)
        Assert.Equal("(0 1 2)(3)", toOrbitNotation (p |> Permutation.toOrbitSet))

    [<Fact>]
    let ``toPermutation converts multiple cycles with fixed points correctly`` () =
        let orbit1 = Orbit.create [0; 1]
        let orbit2 = Orbit.create [2]
        let orbit3 = Orbit.create [3; 4]
        let orbitSet = OrbitSet.create [orbit1; orbit2; orbit3] 5
        let perm = fromOrbitSet orbitSet
        perm.Array |> should equal [|1; 0; 2; 4; 3|] // (0 1)(2)(3 4)

    [<Fact>]
    let ``toPermutation converts identity OrbitSet correctly`` () =
        let orbits = [Orbit.create [0]; Orbit.create [1]; Orbit.create [2]]
        let orbitSet = OrbitSet.create orbits 3
        let perm = fromOrbitSet orbitSet
        perm.Array |> should equal [|0; 1; 2|] // (0)(1)(2)

    [<Fact>]
    let ``toPermutation converts full cycle OrbitSet correctly`` () =
        let orbit = Orbit.create [0; 1; 2; 3]
        let orbitSet = OrbitSet.create [orbit] 4
        let perm = fromOrbitSet orbitSet
        perm.Array |> should equal [|1; 2; 3; 0|] // (0 1 2 3)

    [<Fact>]
    let ``OrbitSet.create throws for incomplete coverage`` () =
        let orbit = Orbit.create [0; 1]
        let ex = Assert.Throws<Exception>(fun () -> OrbitSet.create [orbit] 3 |> ignore)
        ex.Message |> should equal "Orbits must cover indices 0 to order-1"

    [<Fact>]
    let ``toPermutation handles empty OrbitSet for order 0`` () =
        let ex = Assert.Throws<Exception>(fun () -> OrbitSet.create [] 3 |> ignore)
        ex.Message |> should equal "orbits cannot be empty"

    [<Fact>]
    let ``toPermutation round-trip with getOrbits preserves permutation`` () =
        let originalPerm = Permutation.create [|2; 0; 1; 4; 3|] // (0 2 1)(3 4)
        let newPerm = fromOrbitSet (originalPerm |> Permutation.toOrbitSet)
        newPerm.Array |> should equal originalPerm.Array
namespace GeneSort.Core.Test
open Xunit
open GeneSort.Core
open GeneSort.Core.Combinatorics


type Perm_RsTests() =

    // Helper function to create a Perm_Rs from an array
    let createPermRs (arr: int array) : Perm_Rs =
        Perm_Rs.create arr


    // Helper to check if a permutation is self-inverse
    let isSelfInverse (perm: Perm_Rs) : bool =
        let arr = perm.Array
        arr |> Array.indexed |> Array.forall (fun (i, x) -> arr.[x] = i)


    [<Fact>]
    let ``NoAction mode returns original permutation`` () =
        let originalArray = [| 3; 2; 1; 0 |] // Self-inverse permutation
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Should not be used in NoAction
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.NoAction permRs
        Assert.True(result.equals permRs)
        Assert.Equal<int array>(originalArray, result.Array)


    [<Fact>]
    let ``SS_Pair with SelfSymmetric mode`` () =
        let originalArray = [| 3; 2; 1; 0 |] // All self-symmetric pairs: (0,3), (1,2)
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker  [|0; 1|] // Pick pairs (0,3) and (1,2)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.SelfRefl permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(originalArray, result.Array) // SelfSymmetric should not change SS_Pair

    [<Fact>]
    let ``SS_Pair with Ortho mode`` () =
        let originalArray = [| 3; 2; 1; 0 |]
        let expectedArray = [| 1; 0; 3; 2 |]
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|]// Pick pairs (0,3) and (1,2)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Ortho permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array) // Ortho should not change SS_Pair

    [<Fact>]
    let ``SS_Pair with Para mode`` () =
        let originalArray = [| 3; 2; 1; 0 |]
        let expectedArray = [| 2; 3; 0; 1 |]
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Pick pairs (0,3) and (1,2)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Para permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array) // Para should not change SS_Pair


    [<Fact>]
    let ``Mixed_Pair with SelfSymmetric mode`` () =
        let originalArray = [| 5; 2; 1; 4; 3; 0 |]
        let expectedArray = [| 5; 4; 3; 2; 1; 0 |]
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Pick pairs (0,5) and (1,2)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.SelfRefl permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)

    [<Fact>]
    let ``Mixed_Pair with Ortho mode`` () =
        let originalArray = [| 5; 2; 1; 4; 3; 0 |] // (0,5), (1,2), (3,4)
        let expectedArray = [| 5; 2; 1; 4; 3; 0 |]
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Pick (0,3) and (4,5)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Ortho permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)

    [<Fact>]
    let ``Mixed_Pair with Para mode`` () =
        let originalArray = [| 5; 2; 1; 4; 3; 0 |] // (0,5), (1,2), (3,4)
        let expectedArray = [| 5; 3; 4; 1; 2; 0 |]
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 2|] // Pick (0,4) and (1,2)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Para permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)


    [<Fact>]
    let ``Mixed_Pair with Para mode another rsTwoOrbit`` () =
        let originalArray = [| 11; 2; 1; 8; 5; 4; 7; 6; 3; 10; 9; 0 |]
        let expectedArray = [| 8; 2; 1; 11; 5; 4; 7; 6; 0; 10; 9; 3 |]
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 2; 0|] // Pick (0,4) and (1,2)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Para permRs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)


    [<Fact>]
    let ``RS_Pair with Ortho mode`` () =
        let originalArray = [| 1; 0; 3; 2 |] // (0,1), (2,3)
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Pick (0,1) and (2,3)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Ortho permRs
        let expectedArray = [| 1; 0; 3; 2 |] // Ortho swap should preserve for valid pairs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)

    [<Fact>]
    let ``RS_Pair with Para mode`` () =
        let originalArray = [| 1; 0; 3; 2 |] // (0,1), (2,3)
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Pick (0,1) and (2,3)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.Para permRs
        let expectedArray = [| 2; 3; 0; 1 |] // Para swap should preserve for valid pairs
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)
         
    [<Fact>]
    let ``RS_Pair with SelfSymmetric mode`` () =
        let originalArray = [| 1; 0; 3; 2 |] // (0,1), (2,3)
        let permRs = Perm_Rs.create originalArray
        let indexPicker = indexPicker [|0; 1|] // Pick (0,1) and (2,3)
        let result = Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.SelfRefl permRs
        let expectedArray = [| 3; 2; 1; 0 |] // Map 0->3, 1->2, 2->1, 3->0
        Assert.True(isSelfInverse result)
        Assert.Equal<int array>(expectedArray, result.Array)



    [<Fact>]
    let ``Throws on invalid order less than 4`` () =
        let invalidArray = [| 1; 0 |] // Order 2, too small
        let permRs = Perm_Rs.createUnsafe invalidArray // Use unsafe to bypass create validation
        let indexPicker = indexPicker [|0; 1|]
        Assert.ThrowsAny<System.ArgumentException>(fun () ->
            Perm_RsOps.mutatePerm_Rs indexPicker OpsActionMode.SelfRefl permRs |> ignore
        )

namespace GeneSort.Core.Test
open System
open FSharp.UMX
open Xunit
open GeneSort.Core
open GeneSort.Core.Combinatorics
open GeneSort.Core.Permutation
open GeneSort.Core.Perm_Si
open GeneSort.Core.CoreGen
open FsUnit.Xunit

type PermSiTests() =

    let parseIntArray (s: string) : int[] =
        s.Split(',')
        |> Array.map (fun n -> int (n.Trim()))

    [<Fact>]
    let ``Perm_Rs counts are preserved by conjugation`` () =
        let order = 16
        let startIndex = 1
        let perm_RsCount = 5
        let orbitCount = order - perm_RsCount
        let permCount = 5
        let randSeed = 123UL |> UMX.tag<randomSeed>
        let rndPerms = randomPermutations order (new randomLcg(randSeed))
                        |> Seq.take permCount |> Seq.toList
        let perm_Rs = adjacentTwoCycles order startIndex perm_RsCount       
        let conjugates = rndPerms |> List.map(fun p -> Perm_Si.conjugate perm_Rs p)
        let perm_RsOrbitCounts = 
            conjugates |> List.map(fun c -> 
                            (c.Permutation |> Permutation.toOrbitSet).Orbits.Length) 
                       |> List.countBy(id)

        Assert.Equal<int>(orbitCount, perm_RsOrbitCounts.Head |> fst)
        Assert.Equal<int>(1, perm_RsOrbitCounts |> List.length)


    // Deterministic index shuffler for testing: reverses the array
    let testShuffler (n: int) : int =
        (2 * n - 1) % n

    [<Fact>]
    let ``Even order creates maximum transpositions correctly`` () =
        let perm_Rs = saturatedWithTwoCycles 4
        // Expected: [(0,1), (2,3)] -> [1; 0; 3; 2]
        let expected = Perm_Si.createUnsafe [|1; 0; 3; 2|]
        perm_Rs.Permutation.Array |> should equal expected.Permutation.Array
        (perm_Rs.Permutation|> Permutation.toOrbitSet).Orbits.Length |> should equal 2 // n/2 = 4/2 = 2 orbits

    [<Fact>]
    let ``Odd order creates maximum transpositions with one fixed point`` () =
        let perm_Rs = saturatedWithTwoCycles 5
        // Expected: [(0,1), (2,3)] -> [1; 0; 3; 2; 4]
        let expected = Perm_Si.createUnsafe [|1; 0; 3; 2; 4|]
        perm_Rs.Permutation.Array |> should equal expected.Permutation.Array
        (perm_Rs.Permutation |> Permutation.toOrbitSet).Orbits.Length |> should equal 3
        getFixedPoints perm_Rs.Permutation |> should equal [|4|] // One fixed point

    [<Fact>]
    let ``Order 2 creates one transposition`` () =
        let perm_Rs = saturatedWithTwoCycles 2
        // Expected: [(0,1)] -> [1; 0]
        let expected = Perm_Si.createUnsafe [|1; 0|]
        perm_Rs.Permutation.Array |> should equal expected.Permutation.Array
        (perm_Rs.Permutation |> Permutation.toOrbitSet).Orbits.Length |> should equal 1 // n/2 = 2/2 = 1 orbit

    [<Fact>]
    let ``Order 1 creates empty Perm_Rs with one fixed point`` () =
        let perm_Rs = saturatedWithTwoCycles 1
        // Expected: [] -> [0]
        let expected = Perm_Si.createUnsafe [|0|]
        perm_Rs.Permutation.Array |> should equal expected.Permutation.Array
        (perm_Rs.Permutation |> Permutation.toOrbitSet).Orbits.Length |> should equal 1 // n/2 = 1/2 = 0 orbits
        getFixedPoints perm_Rs.Permutation |> should equal [|0|]

    [<Fact>]
    let ``Negative order throws exception`` () =
        let ex = Assert.Throws<System.Exception>(fun () -> saturatedWithTwoCycles -1 |> ignore)
        ex.Message |> should equal "Perm_Si order must not be negative"

    [<Fact>]
    let ``Perm_Rs Reflection`` () =
        let orig = Perm_Si.create [|2; 6; 0; 4; 3; 7; 1; 5|]
        let refl = Perm_Si.makeReflection orig
        let reflA = Perm_Si.makeReflection refl
        reflA.Permutation.Array |> should equal orig.Permutation.Array
        orig |> Perm_Si.isReflectionSymmetric |> should equal true
        let origB = Perm_Si.create [|1; 0; 6; 4; 3; 7; 2; 5|]
        origB |> Perm_Si.isReflectionSymmetric |> should equal false

    [<Fact>]
    let ``Perm_Rs Reflection is it's own inverse`` () =
        let origA = Perm_Si.createUnsafe [|1; 0; 3; 2; 4|]
        let reflA = Perm_Si.makeReflection origA
        let reflA2 = Perm_Si.makeReflection reflA
        reflA2.Permutation.Array |> should equal origA.Permutation.Array

        let origB = Perm_Si.createUnsafe [|7; 1; 5; 0; 3; 6; 2; 4|]
        let reflB = Perm_Si.makeReflection origB
        let reflB2 = Perm_Si.makeReflection reflB
        reflB2.Permutation.Array |> should equal origB.Permutation.Array

    // Helper function to parse a string of comma-separated integers (e.g., "11,2,15")
    let parseIntArray (s: string) : int[] =
        s.Split(',')
        |> Array.map (fun n -> int (n.Trim()))

    [<Theory>]
    [<InlineData("3,1,2,0,4", "3,1,2,0,4,5,9,7,8,6")>]
    [<InlineData("2,7,0,6,5,4,3,1", "2,7,0,6,5,4,3,1,14,12,11,10,9,15,8,13")>]
    let ``unfoldReflection`` (startingArray:string, reflectedArray:string) =
        let startingInts = parseIntArray startingArray
        let reflectedInts = parseIntArray reflectedArray
        let startingTwoCycle = Perm_Si.create startingInts
        let expectedTwoCycle = Perm_Si.create reflectedInts
        let reflectedTwoCycle = Perm_Si.unfoldReflection startingTwoCycle
        reflectedTwoCycle.Array |> should equal expectedTwoCycle.Array


    [<Fact>]
    let ``mutatePerm_Sis with None mode returns original permutation`` () =
        let perm = Perm_Si.create [|1; 0; 2; 3|] // (0 1)
        let mockIndexPicker = indexPicker [|0; 1|]
        let result = mutate mockIndexPicker MutationMode.NoAction perm
        Assert.True(perm.equals result)
        Assert.Equal<int array>(perm.Array, result.Array)

    [<Fact>]
    let ``mutatePerm_Sis with same orbit indices returns original permutation`` () =
        let perm = Perm_Si.create [|1; 0; 2; 3|] // (0 1)
        let mockIndexPicker = indexPicker [|0; 1|] // Picks indices in the same orbit
        let resultOrtho = mutate mockIndexPicker MutationMode.Ortho perm
        let resultPara = mutate mockIndexPicker MutationMode.Para perm
        Assert.True(perm.equals resultOrtho)
        Assert.True(perm.equals resultPara)
        Assert.Equal<int array>(perm.Array, resultOrtho.Array)
        Assert.Equal<int array>(perm.Array, resultPara.Array)

    [<Fact>]
    let ``mutatePerm_Sis with Ortho mode produces valid self-inverse permutation`` () =
        let perm = Perm_Si.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let mockIndexPicker = indexPicker [|0; 2|] // Picks indices 0 and 2
        let result = mutate mockIndexPicker MutationMode.Ortho perm
        let expectedArray = [|2; 3; 0; 1|] // Expected: (0 2)(1 3)
        Assert.Equal<int array>(expectedArray, result.Array)
        Assert.True(Permutation.isSelfInverse result.Permutation)
        Assert.Equal(UMX.tag<Order> 4, result.Order)

    [<Fact>]
    let ``mutatePerm_Sis with Para mode produces valid self-inverse permutation`` () =
        let perm = Perm_Si.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let mockIndexPicker = indexPicker [|0; 2|] // Picks indices 0 and 2
        let result = mutate mockIndexPicker MutationMode.Para perm
        let expectedArray = [|3; 2; 1; 0|] // Expected: (0 3)(1 2)
        Assert.Equal<int array>(expectedArray, result.Array)
        Assert.True(Permutation.isSelfInverse result.Permutation)
        Assert.Equal(UMX.tag<Order> 4, result.Order)

    [<Fact>]
    let ``mutatePerm_Sis with Ortho mode swaps correctly for non-adjacent indices`` () =
        let perm = Perm_Si.create [|1; 0; 3; 2; 5; 4|] // (0 1)(2 3)(4 5)
        let mockIndexPicker = indexPicker [|1; 4|] // Picks indices 1 and 4
        let result = mutate mockIndexPicker MutationMode.Ortho perm
        let expectedArray = [|4; 5; 3; 2; 0; 1|] // Expected: (0 1)(2 3)(4 5)
        Assert.Equal<int array>(expectedArray, result.Array)
        Assert.True(Permutation.isSelfInverse result.Permutation)

    [<Fact>]
    let ``mutatePerm_Sis with Para mode swaps correctly for non-adjacent indices`` () =
        let perm = Perm_Si.create [|1; 0; 3; 2; 5; 4|] // (0 1)(2 3)(4 5)
        let mockIndexPicker = indexPicker [|1; 4|] // Picks indices 1 and 4
        let result = mutate mockIndexPicker MutationMode.Para perm
        let expectedArray = [|5; 4; 3; 2; 1; 0|] // Expected: (0 5)(2 3)(1 4)
        Assert.Equal<int array>(expectedArray, result.Array)
        Assert.True(Permutation.isSelfInverse result.Permutation)

    [<Fact>]
    let ``mutatePerm_Sis preserves order of permutation`` () =
        let perm = Perm_Si.create [|1; 0; 2; 3; 4; 5|] // (0 1)
        let mockIndexPicker = indexPicker [|2; 4|]
        let resultOrtho = mutate mockIndexPicker MutationMode.Ortho perm
        let resultPara = mutate mockIndexPicker MutationMode.Para perm
        Assert.Equal(UMX.tag<Order> 6, resultOrtho.Order)
        Assert.Equal(UMX.tag<Order> 6, resultPara.Order)

    [<Fact>]
    let ``mutatePerm_Sis throws on invalid input permutation`` () =
        let invalidPerm = Permutation.createUnsafe [|1; 1; 2; 3|] // Not a valid permutation
        Assert.Throws<Exception>(fun () -> Perm_Si.create invalidPerm.Array |> ignore)
module Program

//[<EntryPoint>]
//let main _ = 0
namespace GeneSort.Core.Test

open System
open Xunit
open FsUnit.Xunit
open GeneSort.Core
open GeneSort.Core.TwoOrbitPairOps
open GeneSort.Core.PrototypeUnfolder


type PrototypeUnfolderTests() =
    let epsilon = 1e-10 // Tolerance for floating-point comparisons


    // unfoldTwoOrbitPairsIntoTwoOrbitPairs
    [<Fact>]
    let ``unfoldTwoOrbitPairsIntoTwoOrbitPairs with empty inputs returns empty list`` () =
        let types = []
        let pairs = []
        let result = unfoldTwoOrbitPairsIntoTwoOrbitPairs types pairs
        Assert.Empty(result)

    [<Fact>]
    let ``unfoldTwoOrbitPairsIntoTwoOrbitPairs from ortho seed generates correct pairs`` () =
        let pair0 = twoOrbitPairsForOrder4 TwoOrbitType.Ortho
        let types = [TwoOrbitType.Ortho; TwoOrbitType.Para]
        let result = unfoldTwoOrbitPairsIntoTwoOrbitPairs types [pair0]
        let expected = [
            unfoldTwoOrbitIntoTwoOrbitPair pair0.FirstOrbit 4 TwoOrbitType.Ortho
            unfoldTwoOrbitIntoTwoOrbitPair pair0.SecondOrbit.Value 4 TwoOrbitType.Para
        ]
        Assert.Equal(2, result.Length)
        Assert.Equal<int list>(expected.[0].FirstOrbit.Indices, result.[0].FirstOrbit.Indices)
        Assert.Equal<int list>(expected.[0].SecondOrbit.Value.Indices, result.[0].SecondOrbit.Value.Indices)
        Assert.Equal<int>(expected.[0].Order, result.[0].Order)
        Assert.Equal(expected.[0] |> TwoOrbitPairOps.getTwoOrbitPairType, result.[0] |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal<int list>(expected.[1].FirstOrbit.Indices, result.[1].FirstOrbit.Indices)
        Assert.Equal<int list>(expected.[1].SecondOrbit.Value.Indices, result.[1].SecondOrbit.Value.Indices)
        Assert.Equal(expected.[1].Order, result.[1].Order)
        Assert.Equal(expected.[1] |> TwoOrbitPairOps.getTwoOrbitPairType, result.[1] |> TwoOrbitPairOps.getTwoOrbitPairType)


    [<Fact>]
    let ``unfoldTwoOrbitPairsIntoTwoOrbitPairs two levels generates correct pairs`` () =
        let pairs0 = [twoOrbitPairsForOrder4 TwoOrbitType.SelfRefl]
        let types0 = [TwoOrbitType.Ortho; TwoOrbitType.Para]
        let pairs1 = unfoldTwoOrbitPairsIntoTwoOrbitPairs types0 pairs0
        let expected1 = [
            unfoldTwoOrbitIntoTwoOrbitPair pairs0[0].FirstOrbit 4 TwoOrbitType.Ortho
            unfoldTwoOrbitIntoTwoOrbitPair pairs0[0].SecondOrbit.Value 4 TwoOrbitType.Para
        ]
        Assert.Equal(2, pairs1.Length)
        Assert.Equal<int list>(expected1.[0].FirstOrbit.Indices, pairs1.[0].FirstOrbit.Indices)
        Assert.Equal<int list>(expected1.[0].SecondOrbit.Value.Indices, pairs1.[0].SecondOrbit.Value.Indices)
        Assert.Equal<int>(expected1.[0].Order, pairs1.[0].Order)
        Assert.Equal(expected1.[0] |> TwoOrbitPairOps.getTwoOrbitPairType, pairs1.[0] |> TwoOrbitPairOps.getTwoOrbitPairType)
        Assert.Equal<int list>(expected1.[1].FirstOrbit.Indices, pairs1.[1].FirstOrbit.Indices)
        Assert.Equal<int list>(expected1.[1].SecondOrbit.Value.Indices, pairs1.[1].SecondOrbit.Value.Indices)
        Assert.Equal(expected1.[1].Order, pairs1.[1].Order)
        Assert.Equal(expected1.[1] |> TwoOrbitPairOps.getTwoOrbitPairType, pairs1.[1] |> TwoOrbitPairOps.getTwoOrbitPairType)
        /// next round
        let types1 = [TwoOrbitType.Ortho; TwoOrbitType.SelfRefl; TwoOrbitType.Para; TwoOrbitType.Para]
        let pairs2 = unfoldTwoOrbitPairsIntoTwoOrbitPairs types1 pairs1
        Assert.Equal(4, pairs2.Length)


    [<Fact>]
    let ``unfoldTwoOrbitPairsIntoTwoOrbitPairs with mismatched lengths throws exception`` () =
        let orbit1 = TwoOrbit.create [0; 1]
        let orbit2 = TwoOrbit.create [2; 3]
        let pair = TwoOrbitPair.create 4 orbit1 (orbit2 |> Some)
        let types = [TwoOrbitType.Ortho; TwoOrbitType.Para; TwoOrbitType.SelfRefl] // Length 3
        let pairs = [pair] // Length 1, 2*1 != 3
        Assert.Throws<ArgumentException>(fun () -> unfoldTwoOrbitPairsIntoTwoOrbitPairs types pairs |> ignore)








namespace GeneSort.Core.Test

open Xunit
open FsUnit.Xunit
open System
open GeneSort.Core
open FSharp.UMX
open GeneSort.Core.RandomSeed

type RandoTests() =

    // Helper function for chi-squared test for uniformity
    let chiSquaredTest (values: int[]) buckets =
        let n = values.Length
        let expected = float n / float buckets
        let counts = Array.zeroCreate buckets
        for v in values do
            counts.[v] <- counts.[v] + 1
        let chi2 =
            counts
            |> Array.map (fun count -> (float count - expected) ** 2.0 / expected)
            |> Array.sum
        // Critical value for 10% significance level, degrees of freedom = buckets - 1
        let criticalValues = Map [
            9, 18.307 // 10 buckets - 1, 10% significance
            99, 123.225 // 100 buckets - 1
        ]
        chi2, Map.tryFind (buckets - 1) criticalValues

    // Test randomLcg with explicit UMX tagging
    [<Theory>]
    [<InlineData(42UL)>]
    [<InlineData(123456789UL)>]
    let ``randomLcg produces values in expected ranges`` (seed: uint64) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng = randomLcg taggedSeed :> IRando
        let uintVal = rng.NextUInt()
        let intVal = rng.NextPositiveInt()
        let floatVal = rng.NextFloat()
        let indexVal = rng.NextIndex 10
        let ulongVal = rng.NextULong()
        let guidVal = rng.NextGuid()
    
        Assert.InRange(uintVal, 0u, UInt32.MaxValue)
        Assert.InRange(intVal, 0, Int32.MaxValue)
        Assert.InRange(floatVal, 0.0, 1.0 - Double.Epsilon)
        Assert.InRange(indexVal, 0, 9)
        Assert.InRange(ulongVal, 0UL, UInt64.MaxValue)
        Assert.NotEqual(Guid.Empty, guidVal)
        Assert.Equal(40, rng.ByteCount)

    [<Theory>]
    [<InlineData(42)>]
    [<InlineData(123456789)>]
    let ``randomNet produces values in expected ranges`` (seed: int32) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng = randomNet taggedSeed :> IRando
        let uintVal = rng.NextUInt()
        let intVal = rng.NextPositiveInt()
        let floatVal = rng.NextFloat()
        let indexVal = rng.NextIndex 10
        let ulongVal = rng.NextULong()
        let guidVal = rng.NextGuid()
    
        Assert.InRange(uintVal, 0u, UInt32.MaxValue)
        Assert.InRange(intVal, 0, Int32.MaxValue)
        Assert.InRange(floatVal, 0.0, 1.0 - Double.Epsilon)
        Assert.InRange(indexVal, 0, 9)
        Assert.InRange(ulongVal, 0UL, UInt64.MaxValue)
        Assert.NotEqual(Guid.Empty, guidVal)
        Assert.Equal(44, rng.ByteCount)

    [<Theory>]
    [<InlineData(42UL)>]
    [<InlineData(123456789UL)>]
    let ``randomLcg is deterministic with same seed`` (seed: uint64) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng1 = randomLcg taggedSeed :> IRando
        let rng2 = randomLcg taggedSeed :> IRando
        let values1: list<uint32> = [ for _ in 1..100 -> rng1.NextUInt() ]
        let values2: list<uint32> = [ for _ in 1..100 -> rng2.NextUInt() ]
        Assert.Equal<list<uint32>>(values1, values2)
        Assert.Equal(400, rng1.ByteCount)
        Assert.Equal(400, rng2.ByteCount)

    [<Theory>]
    [<InlineData(42)>]
    [<InlineData(123456789)>]
    let ``randomNet is deterministic with same seed`` (seed: int32) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng1 = randomNet taggedSeed :> IRando
        let rng2 = randomNet taggedSeed :> IRando
        let values1: list<uint32> = [ for _ in 1..100 -> rng1.NextUInt() ]
        let values2: list<uint32> = [ for _ in 1..100 -> rng2.NextUInt() ]
        Assert.Equal<list<uint32>>(values1, values2)
        Assert.Equal(400, rng1.ByteCount)
        Assert.Equal(400, rng2.ByteCount)

    [<Theory>]
    [<InlineData(42UL)>]
    [<InlineData(123456789UL)>]
    let ``randomLcg produces uniform distribution for NextIndex`` (seed: uint64) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng = randomLcg taggedSeed :> IRando
        let n = 100000
        let modulus = 10
        let values = [| for _ in 1..n -> rng.NextIndex modulus |]
        let chi2, criticalValue = chiSquaredTest values modulus
        match criticalValue with
        | Some cv -> Assert.True(chi2 < cv, $"Chi-squared value {chi2} exceeds critical value {cv} for uniform distribution")
        | None -> Assert.Fail("No critical value defined for chi-squared test")
        Assert.Equal(n * 4, rng.ByteCount)

    [<Theory>]
    [<InlineData(42)>]
    [<InlineData(123456789)>]
    let ``randomNet produces uniform distribution for NextIndex`` (seed: int32) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng = randomNet taggedSeed :> IRando
        let n = 100000
        let modulus = 10
        let values = [| for _ in 1..n -> rng.NextIndex modulus |]
        let chi2, criticalValue = chiSquaredTest values modulus
        match criticalValue with
        | Some cv -> Assert.True(chi2 < cv, $"Chi-squared value {chi2} exceeds critical value {cv} for uniform distribution")
        | None -> Assert.Fail("No critical value defined for chi-squared test")
        Assert.Equal(n * 4, rng.ByteCount)

    [<Theory>]
    [<InlineData(42UL)>]
    [<InlineData(123456789UL)>]
    let ``randomLcg generates unique GUIDs`` (seed: uint64) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng = randomLcg taggedSeed :> IRando
        let guids = [ for _ in 1..1000 -> rng.NextGuid() ]
        let distinctGuids = guids |> List.distinct
        Assert.Equal(guids.Length, distinctGuids.Length)
        Assert.Equal(1000 * 16, rng.ByteCount)

    [<Theory>]
    [<InlineData(42)>]
    [<InlineData(123456789)>]
    let ``randomNet generates unique GUIDs`` (seed: int32) =
        let taggedSeed = UMX.tag<randomSeed> seed
        let rng = randomNet taggedSeed :> IRando
        let guids = [ for _ in 1..1000 -> rng.NextGuid() ]
        let distinctGuids = guids |> List.distinct
        Assert.Equal(guids.Length, distinctGuids.Length)
        Assert.Equal(1000 * 16, rng.ByteCount)

    [<Fact>]
    let ``randomLcg and randomNet produce different sequences`` () =
        let seed = 42UL
        let lcg = randomLcg (UMX.tag<randomSeed> seed) :> IRando
        let net = randomNet (UMX.tag<randomSeed> 42) :> IRando
        let lcgValues: list<uint32> = [ for _ in 1..100 -> lcg.NextUInt() ]
        let netValues: list<uint32> = [ for _ in 1..100 -> net.NextUInt() ]
        Assert.NotEqual<list<uint32>>(lcgValues, netValues)

    // Test cases
    [<Fact>]
    let ``nextTwo throws exception when maxDex is less than 2`` () =
        let seed = 42UL
        let randy = randomLcg (UMX.tag<randomSeed> seed) :> IRando
        Assert.Throws<exn>(fun () -> Rando.nextTwo 1 randy |> ignore)

    [<Fact>]
    let ``nextTwo returns (0,1) when maxDex equals 2`` () =
        let seed = 42UL
        let randy = randomLcg (UMX.tag<randomSeed> seed) :> IRando
        let result = Rando.nextTwo 2 randy
        result |> should equal (0, 1)

    [<Fact>]
    let ``nextTwo returns distinct indices within range for maxDex greater than 2`` () =
        let seed = 42UL
        let randy = randomLcg (UMX.tag<randomSeed> seed) :> IRando
        let result = Rando.nextTwo 5 randy
        fst result |> should be (greaterThanOrEqualTo 0)
        fst result |> should be (lessThan 5)
        snd result |> should be (greaterThanOrEqualTo 0)
        snd result |> should be (lessThan 5)
        fst result |> should not' (equal (snd result))


    [<Fact>]
    let ``fromGuid produces different outputs for different Guids`` () =
        let guid1 = Guid("123e4567-e89b-12d3-a456-426614174000")
        let guid2 = Guid("987fcdeb-0123-45ab-cdef-0123456789ab")
        let seed1 = fromGuid guid1
        let seed2 = fromGuid guid2
        seed1 |> should not' (equal seed2)

    [<Fact>]
    let ``fromGuid with alternating byte array produces zero seed`` () =
        let bytes = [| 0xAAuy; 0x55uy; 0xAAuy; 0x55uy; 0xAAuy; 0x55uy; 0xAAuy; 0x55uy;
                       0xAAuy; 0x55uy; 0xAAuy; 0x55uy; 0xAAuy; 0x55uy; 0xAAuy; 0x55uy |]
        let guid = Guid(bytes)
        let seed1 = fromGuid guid
        let seed2 = fromGuid guid
        seed1 |> should equal seed2
        UMX.untag<randomSeed> seed1 |> should equal 0UL

    [<Fact>]
    let ``fromGuid with incremental byte array uses all bytes`` () =
        let bytes = [| 0x01uy; 0x02uy; 0x03uy; 0x04uy; 0x05uy; 0x06uy; 0x07uy; 0x08uy;
                       0x09uy; 0x0Auy; 0x0Buy; 0x0Cuy; 0x0Duy; 0x0Euy; 0x0Fuy; 0x10uy |]
        let guid = Guid(bytes)
        let seed = fromGuid guid
        let expected = (uint64 0x01 <<< 0) ^^^ (uint64 0x02 <<< 8) ^^^ (uint64 0x03 <<< 16) ^^^ 
                       (uint64 0x04 <<< 24) ^^^ (uint64 0x05 <<< 32) ^^^ (uint64 0x06 <<< 40) ^^^ 
                       (uint64 0x07 <<< 48) ^^^ (uint64 0x08 <<< 56) ^^^ 
                       (uint64 0x09 <<< 0) ^^^ (uint64 0x0A <<< 8) ^^^ (uint64 0x0B <<< 16) ^^^ 
                       (uint64 0x0C <<< 24) ^^^ (uint64 0x0D <<< 32) ^^^ (uint64 0x0E <<< 40) ^^^ 
                       (uint64 0x0F <<< 48) ^^^ (uint64 0x10 <<< 56)
        UMX.untag<randomSeed> seed |> should equal expected

    [<Fact>]
    let ``fromGuid with single byte change produces different seed`` () =
        let bytes1 = [| 0xFFuy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy;
                        0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy |]
        let bytes2 = [| 0xFFuy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy;
                        0x01uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy; 0x00uy |]
        let guid1 = Guid(bytes1)
        let guid2 = Guid(bytes2)
        let seed1 = fromGuid guid1
        let seed2 = fromGuid guid2
        seed1 |> should not' (equal seed2)




namespace GeneSort.Core.Test

open Xunit
open SysExt
open GeneSort.Core.ByteUtils


type SysExtTests() =

    [<Fact>]
    let ``UInt8 bit manipulation methods`` () =
        let value = 0b01011010uy
        let rot = 0b10100101uy
        Assert.Equal(value, value.rev)
        Assert.Equal(4, value.count)
        Assert.Equal(4, value.count_dense)
        Assert.Equal(0b01011000uy, value.diff 0b00000010uy)
        Assert.True((value.subset 0b01011011uy))
        Assert.False((value.propersubset value))
        Assert.Equal(rot, value.rotateLeft 4)
        Assert.Equal(rot, value.rotateRight 4)
        Assert.Equal(rot, value.rotate 4)
        Assert.Equal(0b01000000uy, value.leftmost_one)
        Assert.Equal(0b10000000uy, value.leftmost_zero)
        Assert.Equal(0b00000010uy, value.rightmost_one)
        Assert.Equal(0b00000001uy, value.rightmost_zero)
        Assert.Equal(1, value.rightmost_index)
        Assert.Equal(6, value.leftmost_index)

    [<Fact>]
    let ``UInt16 bit manipulation methods`` () =
        let value = 0b0101101010101010us
        Assert.Equal(0b0101010101011010us, value.rev)
        Assert.Equal(8, value.count)
        Assert.Equal(8, value.count_dense)
        Assert.Equal(0b0101101000000000us, value.diff 0b0000000010101010us)
        Assert.True((value.subset 0b1111101010101010us))
        Assert.False((value.propersubset 0b0101101010101010us))
        //let leLeft = (value.rotateLeft 4) |> uint16ToBinaryString
        Assert.Equal(0b1010101010100101us, value.rotateLeft 4)
        let leRight = (value.rotateRight 4) |> uint16ToBinaryString
        Assert.Equal(0b1010010110101010us, value.rotateRight 4)
        Assert.Equal(0b1010101010100101us, value.rotate 4)
        Assert.Equal(0b1010010110101010us, value.rotate -4)
        Assert.Equal(0b0100000000000000us, value.leftmost_one)
        Assert.Equal(0b1000000000000000us, value.leftmost_zero)
        Assert.Equal(0b0000000000000010us, value.rightmost_one)
        Assert.Equal(0b0000000000000001us, value.rightmost_zero)
        Assert.Equal(1, value.rightmost_index)
        Assert.Equal(14, value.leftmost_index)

    [<Fact>]
    let ``UInt32 bit manipulation methods`` () =
        let value = 0b01011010010110100101101010101010u
        Assert.Equal(0b01010101010110100101101001011010u, value.rev)
        Assert.Equal(16, value.count)
        Assert.Equal(16, value.count_dense)
        Assert.Equal(0b01010000010110100101000000001010u, value.diff 0b00001010000001011010101010100000u)
        Assert.False((value.subset 0b11111010101011111000000011110000u))
        Assert.True((value.subset 0b11111010110111111101101011111010u))
        Assert.False((value.propersubset value))
        Assert.Equal(0b10100101101001011010101010100101u, value.rotateLeft 4)
        Assert.Equal(0b10100101101001011010010110101010u, value.rotateRight 4)
        Assert.Equal(0b10100101101001011010101010100101u, value.rotate 4)
        Assert.Equal(0b10100101101001011010010110101010u, value.rotate -4)
        Assert.Equal(0b01000000000000000000000000000000u, value.leftmost_one)
        Assert.Equal(0b10000000000000000000000000000000u, value.leftmost_zero)
        Assert.Equal(0b00000000000000000000000000000010u, value.rightmost_one)
        Assert.Equal(0b00000000000000000000000000000001u, value.rightmost_zero)
        Assert.Equal(1, value.rightmost_index)
        Assert.Equal(30, value.leftmost_index)

    [<Fact>]
    let ``UInt64 bit manipulation methods`` () =
        let value = 0b0101010110101010001100111100110000001111111100001111000011110000UL
        Assert.Equal(0b0000111100001111000011111111000000110011110011000101010110101010UL, value.rev)
        Assert.Equal(32UL, value.count)
        Assert.Equal(32UL, value.count_dense)
        Assert.Equal(0b0101010110101010001100111100110000000000000000000000000000000000UL, value.diff 0b0000000000000000000000000000000000001111111100001111000011110000UL)
        Assert.True((value.subset 0b1111010110101010001100111100110000001111111100001111000011110000UL))
        Assert.False((value.propersubset 0b0101010110101010001100111100110000001111111100001111000011110000UL))
        Assert.Equal(0b1010110101010001100111100110000001111111100001111000011110000010UL, value.rotateLeft 3)
        Assert.Equal(0b0000101010110101010001100111100110000001111111100001111000011110UL, value.rotateRight 3)
        Assert.Equal(0b1010110101010001100111100110000001111111100001111000011110000010UL, value.rotate 3)
        Assert.Equal(0b0100000000000000000000000000000000000000000000000000000000000000UL, value.leftmost_one)
        Assert.Equal(0b1000000000000000000000000000000000000000000000000000000000000000UL, value.leftmost_zero)
        Assert.Equal(0b0000000000000000000000000000000000000000000000000000000000010000UL, value.rightmost_one)
        Assert.Equal(0b0000000000000000000000000000000000000000000000000000000000000001UL, value.rightmost_zero)
        Assert.Equal(4, value.rightmost_index)
        Assert.Equal(62, value.leftmost_index)
namespace EvoMergeSort.Core.Tests

open System
open Xunit

type Tests() =

    [<Fact>]
    let ``My test`` () =
        Assert.True(true)
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Model")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd0ecb4b7b45c20f3de2591024c41fde4f7aea3a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Model")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Model")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace GeneSort.Model.Sorter.Ce

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Model.Sorter

[<Struct; CustomEquality; NoComparison>]
type Msce = 
    private 
        { id: Guid<sorterModelID>
          sortingWidth: int<sortingWidth>
          ceCodes: int array } 
    with
    static member create 
            (id: Guid<sorterModelID>) 
            (sortingWidth: int<sortingWidth>)
            (ceCodes: int array) : Msce =
        if ceCodes.Length < 1 then
            failwith "Must be at least 1 Ce"
        else if %sortingWidth < 1 then
            failwith "SortingWidth must be at least 1"
        else
            { id = id; sortingWidth = sortingWidth; ceCodes = ceCodes }

    member this.Id with get () = this.id
    member this.SortingWidth with get () = this.sortingWidth
    member this.CeCodes with get () = this.ceCodes
    member this.CeCount with get () = (this.ceCodes.Length |> UMX.tag<ceCount>)
    member this.toString() =
        sprintf "msce(Id=%A, SortingWidth=%d, SorterLength=%d)" 
                (%this.Id) 
                (%this.SortingWidth)
                (this.CeCodes.Length)

    override this.Equals(obj) = 
        match obj with
        | :? Msce as other -> 
            this.id = other.id && 
            this.sortingWidth = other.sortingWidth &&
            this.ceCodes = other.ceCodes
        | _ -> false

    override this.GetHashCode() = 
        hash (this.GetType(), this.id, this.sortingWidth, this.ceCodes)

    interface IEquatable<Msce> with
        member this.Equals(other) = 
            this.id = other.id && 
            this.sortingWidth = other.sortingWidth &&
            this.ceCodes = other.ceCodes

    interface ISorterModel with
        member this.Id = this.id 
        member this.MakeSorter() = 
            let sw = %this.sortingWidth
            let ces = this.CeCodes |> Array.map (fun code -> Ce.create code sw)
            Sorter.create (%this.Id |> UMX.tag<sorterId>) this.SortingWidth ces


module Msce =

    let toString (msce: Msce) : string =
        sprintf "msce(Id=%A, SortingWidth=%d, SorterLength=%d)" 
                (%msce.Id) 
                (%msce.SortingWidth)
                (msce.CeCodes.Length)
namespace GeneSort.Model.Sorter.Ce

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter

[<Struct; CustomEquality; NoComparison>]
type MsceRandGen = 
    private 
        { 
          id : Guid<sorterModelMakerID>
          rngType: rngType
          sortingWidth: int<sortingWidth>
          excludeSelfCe: bool
          ceCount: int<ceCount> } 
    with
    static member create 
            (rngType: rngType) 
            (sortingWidth: int<sortingWidth>) 
            (excludeSelfCe: bool) 
            (ceCount: int<ceCount>) : MsceRandGen =
        if %ceCount < 1 then
            failwith "ceCount length must be at least 1"
        else if %sortingWidth < 1 then
            failwith "Width must be at least 1"
        else
            let id =
                [
                    rngType :> obj
                    sortingWidth :> obj
                    excludeSelfCe :> obj
                    %ceCount :> obj
                ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

            { id = id;
              rngType = rngType; 
              sortingWidth = sortingWidth; 
              excludeSelfCe = excludeSelfCe; 
              ceCount = ceCount }
    

    member this.Id with get () = this.id
    member this.RngType with get () = this.rngType
    member this.SortingWidth with get () = this.sortingWidth
    member this.ExcludeSelfCe with get () = this.excludeSelfCe
    member this.CeCount with get () = this.ceCount

    override this.Equals(obj) = 
        match obj with
        | :? MsceRandGen as other -> 
            this.rngType = other.rngType && 
            this.sortingWidth = other.sortingWidth && 
            this.excludeSelfCe = other.excludeSelfCe && 
            this.ceCount = other.ceCount
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.sortingWidth, this.excludeSelfCe, this.ceCount)

    interface IEquatable<MsceRandGen> with
        member this.Equals(other) = 
            this.rngType = other.rngType && 
            this.sortingWidth = other.sortingWidth && 
            this.excludeSelfCe = other.excludeSelfCe && 
            this.ceCount = other.ceCount


    interface ISorterModelMaker with
        member this.Id = this.id
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rando = rngFactory this.RngType %id
            let ceCodes = 
                if this.ExcludeSelfCe then
                    Ce.generateCeCodesExcludeSelf (rando.NextIndex) %this.SortingWidth
                    |> Seq.take %this.sortingWidth
                    |> Seq.toArray
                else
                    Ce.generateCeCodes (rando.NextIndex) %this.SortingWidth
                    |> Seq.take %this.CeCount
                    |> Seq.toArray

            Msce.create
                id 
                this.SortingWidth
                ceCodes




module MsceRandGen =

    let toString (msceRandGen: MsceRandGen) : string =
        sprintf "Model_CeGen(rngType=%A, Width=%d, Length=[%d])" 
                    (msceRandGen.RngType) (%msceRandGen.SortingWidth) (%msceRandGen.CeCount)

         
namespace GeneSort.Model.Sorter.Ce

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter

[<Struct; CustomEquality; NoComparison>]
type MsceRandMutate = 
    private 
        { 
          id : Guid<sorterModelMakerID>
          msce : Msce
          rngType: rngType
          indelRatesArray: IndelRatesArray
          excludeSelfCe: bool }
    static member create 
            (rngType: rngType)
            (indelRatesArray: IndelRatesArray)
            (excludeSelfCe: bool) 
            (msce : Msce): MsceRandMutate = 
        if %msce.CeCount <> indelRatesArray.Length then failwith "CeCount must match indelRatesArray.Length"
        let id =
            [
                msce :> obj
                rngType :> obj
                indelRatesArray :> obj
                excludeSelfCe :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

        {
            id = id
            msce = msce
            rngType = rngType
            indelRatesArray = indelRatesArray
            excludeSelfCe = excludeSelfCe
        }
        
    member this.Id with get () = this.id
    member this.Msce with get () = this.msce
    member this.RngType with get () = this.rngType
    member this.CeCount with get () = this.msce.CeCount
    member this.IndelRatesArray with get () = this.indelRatesArray
    member this.ExcludeSelfCe with get () = this.excludeSelfCe

    override this.Equals(obj) = 
        match obj with
        | :? MsceRandMutate as other -> 
            this.Id = other.Id

        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.indelRatesArray, this.excludeSelfCe, this.msce)

    interface IEquatable<MsceRandMutate> with
        member this.Equals(other) = 
            this.Id = other.Id

    interface ISorterModelMaker with
        member this.Id = this.id

        /// Mutates an Msce by applying ChromosomeRates.mutate to its ceCodes array.
        /// Generates a new Msce with a new ID, the same sortingWidth, and a mutated ceCodes array.
        /// The ceCodes array is modified using the provided indelRatesArray, with insertions and mutations
        /// generated via Ce.generateCeCode, and deletions handled to maintain the ceCount length.
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) 
                    : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let excludeSelfCe = this.ExcludeSelfCe
            let sortingWidth = %this.msce.SortingWidth
            let ceCodeInserter = fun () -> Ce.generateCeCode excludeSelfCe sortingWidth (rng.NextIndex)
            let ceCodeMutator = fun ce -> Ce.generateCeCode excludeSelfCe sortingWidth (rng.NextIndex)
            let ceCodes = IndelRatesArray.mutate 
                            this.IndelRatesArray 
                            ceCodeInserter 
                            ceCodeMutator 
                            (rng.NextFloat) 
                            this.msce.CeCodes
            Msce.create id this.msce.SortingWidth ceCodes


module MsceRandMutate =

    /// Returns a string representation of the MsceRandMutate instance.
    let toString (msceMutate: MsceRandMutate) : string = 
        sprintf "MsceRandMutate(%s, %d, %s, %b)"
            (msceMutate.RngType.ToString())
            (%msceMutate.CeCount)
            (msceMutate.IndelRatesArray.toString())
            msceMutate.ExcludeSelfCe
namespace GeneSort.Model.Sorter.Rs

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter

/// Represents a rank-swap-based sorting model composed of an array of Perm_Rs instances.
[<Struct; CustomEquality; NoComparison>]
type Msrs = 
    private 
        { id: Guid<sorterModelID>
          sortingWidth: int<sortingWidth>
          perm_Rss: Perm_Rs array } 
    with
    /// Creates an Msrs instance with the specified ID, width, and Perm_Rs array.
    /// Throws an exception if the Perm_Rs array is empty, width is less than 1, or any Perm_Rs has a mismatched width.
    static member create 
            (id: Guid<sorterModelID>) 
            (width: int<sortingWidth>) 
            (perm_Rss: Perm_Rs array) : Msrs =

        if perm_Rss.Length < 1 then
            failwith $"Must have at least 1 Perm_Rs, got %d{perm_Rss.Length}"
        else if %width < 1 then
            failwith $"Width must be at least 1, got {%width}"
        else if perm_Rss |> Array.exists (fun prs -> %prs.Order <> %width) then
            failwith $"All Perm_Rs must have width {%width}"
        else
            { id = id; sortingWidth = width; perm_Rss = perm_Rss }

    member this.Id with get () = this.id
    member this.StageCount with get () = this.perm_Rss.Length |> UMX.tag<stageCount>
    member this.SortingWidth with get () = this.sortingWidth
    member this.Perm_Rss with get () = this.perm_Rss
    member this.toString() =
        sprintf "msrs(Id=%A, Width=%d, Perm_Rs_count=%d)" 
                (%this.Id) 
                (%this.SortingWidth) 
                (this.Perm_Rss.Length)

    override this.Equals(obj) = 
        match obj with
        | :? Msrs as other -> 
            this.id = other.id
        | _ -> false

    override this.GetHashCode() = 
        hash (this.GetType(), this.id)

    interface IEquatable<Msrs> with
        member this.Equals(other) = 
            this.id = other.id

    interface ISorterModel with
        member this.Id = this.id 
        member this.MakeSorter() = 
            let ces = 
                this.Perm_Rss
                |> Array.collect (fun prs -> 
                    prs.Perm_Si 
                    |> Perm_Si.getTwoOrbits
                    |> Array.map (fun tbit -> Ce.create tbit.First tbit.Second))
            Sorter.create (%this.Id |> UMX.tag<sorterId>) this.SortingWidth ces


module Msrs =

    /// Returns a string representation of the Msrs instance.
    let toString (msrs: Msrs) : string =
        sprintf "Msrs(Id=%A, Width=%d, Perm_Rs_count=%d)" 
                (%msrs.Id) 
                (%msrs.SortingWidth) 
                msrs.Perm_Rss.Length 

    /// Returns the number of Perm_Rs instances in the Msrs.
    let getLength (msrs: Msrs) : int =
        msrs.Perm_Rss.Length

    /// Converts an Msrs instance to a Sorter by mapping each Perm_Rs to comparison elements (Ce) via TwoOrbits.
    /// <param name="msrs">The Msrs instance to convert.</param>
    /// <returns>A Sorter instance with the same width and derived comparison elements.</returns>
    let makeSorter (msrs: Msrs) : Sorter =
        let ces = 
            msrs.Perm_Rss
            |> Array.collect (fun prs -> 
                prs.Perm_Si 
                |> Perm_Si.getTwoOrbits
                |> Array.map (fun tbit -> Ce.create tbit.First tbit.Second))
        Sorter.create (%msrs.Id |> UMX.tag<sorterId>) msrs.SortingWidth ces
namespace GeneSort.Model.Sorter.Rs

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Core.Perm_RsOps
open GeneSort.Sorter
open GeneSort.Model.Sorter

/// Represents a configuration for generating random Msrs instances with specified mutation rates.
/// Combines random generation and mutation probabilities for Perm_Rs instances.
[<Struct; CustomEquality; NoComparison>]
type MsrsRandGen = 
    private 
        { 
              id : Guid<sorterModelMakerID>
              rngType: rngType
              opsGenRatesArray: OpsGenRatesArray
              sortingWidth: int<sortingWidth> 
        } 
    static member create 
            (rngType: rngType)
            (sortingWidth: int<sortingWidth>)
            (opActionRatesArray: OpsGenRatesArray)
            : MsrsRandGen =

        if %sortingWidth < 2 then
            failwith $"SortingWidth must be at least 2, got {%sortingWidth}"
        let id =
            [
                rngType :> obj
                sortingWidth :> obj
                opActionRatesArray :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

        {
            id = id
            sortingWidth = sortingWidth
            opsGenRatesArray = opActionRatesArray
            rngType = rngType
        }
        
    member this.Id with get () = this.id
    member this.RngType with get () = this.rngType
    member this.OpsGenRatesArray with get () = this.opsGenRatesArray
    member this.SortingWidth with get () = this.sortingWidth
    member this.StageCount with get () = this.opsGenRatesArray.Length

    override this.Equals(obj) = 
        match obj with
        | :? MsrsRandGen as other -> 
            this.id = other.id
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.opsGenRatesArray, this.sortingWidth)

    interface IEquatable<MsrsRandGen> with
        member this.Equals(other) = 
            this.Id = other.Id

    interface ISorterModelMaker with

        member this.Id = this.id
        
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) 
                    : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let genRatesArray = this.OpsGenRatesArray
            let stageCount = %this.StageCount
            let sortingWidth = %this.SortingWidth
            let perm_Rss =
                [| for dex in 0 .. (stageCount - 1) ->
                    Perm_RsOps.makeRandomPerm_Rs
                        (rng.NextIndex)
                        (rng.NextFloat)
                        (genRatesArray.[dex])
                        (sortingWidth) |]

            Msrs.create id this.SortingWidth perm_Rss


module MsrsRandGen =

    /// Returns a string representation of the MsrsRandGen configuration.
    let toString (msrsGen: MsrsRandGen) : string =
        sprintf "MsrsRandGen(RngType=%A, Width=%d, StageCount=%d, OpActionRatesArray=%s)" 
                msrsGen.RngType (%msrsGen.SortingWidth) (%msrsGen.StageCount) (msrsGen.OpsGenRatesArray.toString())
namespace GeneSort.Model.Sorter.Si

open FSharp.UMX
open GeneSort.Core
open System
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Rs

      
/// Represents a configuration for mutating Msrs instances with specified mutation probabilities.
[<Struct; CustomEquality; NoComparison>]
type MsrsRandMutate = 
    private 
        { 
          id : Guid<sorterModelMakerID>
          msrs : Msrs
          rngType: rngType
          opsActionRatesArray: OpsActionRatesArray
        } 
    static member create 
            (rngType: rngType)
            (msrs: Msrs)
            (opsActionRatesArray: OpsActionRatesArray)
             : MsrsRandMutate =
        
        if %msrs.Perm_Rss.Length <> opsActionRatesArray.Length then failwith "Perm_Rss length must match opsActionRatesArray.Length"

        let id =
            [
                rngType :> obj
                msrs :> obj
                opsActionRatesArray :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

        {
            id = id
            msrs = msrs
            rngType = rngType
            opsActionRatesArray = opsActionRatesArray
        }

    member this.Id with get () = this.id
    member this.Msrs with get () = this.msrs
    member this.RngType with get () = this.rngType
    member this.StageCount with get () = this.msrs.StageCount 
    member this.OpsActionRates with get () = this.opsActionRatesArray

    override this.Equals(obj) = 
        match obj with
        | :? MsrsRandMutate as other -> 
            this.Id = other.Id
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.msrs, this.opsActionRatesArray)

    interface IEquatable<MsrsRandMutate> with
        member this.Equals(other) = 
            this.Id = other.Id


    interface ISorterModelMaker with
        member this.Id = this.id

        /// Mutates an Msce by applying ChromosomeRates.mutate to its ceCodes array.
        /// Generates a new Msce with a new ID, the same sortingWidth, and a mutated ceCodes array.
        /// The ceCodes array is modified using the provided chromosomeRates, with insertions and mutations
        /// generated via Ce.generateCeCode, and deletions handled to maintain the ceCount length.
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) 
                        : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let orthoMutator = fun psi ->   Perm_RsOps.mutatePerm_Rs (rng.NextIndex) OpsActionMode.Ortho psi 
            let paraMutator = fun psi ->    Perm_RsOps.mutatePerm_Rs (rng.NextIndex) OpsActionMode.Para psi 
            let selfSymMutator = fun psi -> Perm_RsOps.mutatePerm_Rs  (rng.NextIndex) OpsActionMode.SelfRefl psi 
            let mutated = OpsActionRatesArray.mutate 
                            this.OpsActionRates 
                            orthoMutator 
                            paraMutator 
                            selfSymMutator
                            (rng.NextFloat) 
                            this.Msrs.Perm_Rss

            Msrs.create id this.Msrs.SortingWidth mutated



            
module MsrsRandMutate =

    let toString (msrsRandMutate: MsrsRandMutate) : string =
        let actionRates = msrsRandMutate.OpsActionRates.toString()
        sprintf "MsrsRandMutate(RngType=%A, Msrs=%s, OpsActionRates=%s)" 
                msrsRandMutate.RngType 
                (%msrsRandMutate.Msrs.toString())
                actionRates
namespace GeneSort.Model.Sorter.Si

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter
 
[<Struct; CustomEquality; NoComparison>]
type Mssi = 
    private 
        { id: Guid<sorterModelID>
          sortingWidth: int<sortingWidth>
          perm_Sis: Perm_Si array } 
    with
    static member create 
            (id: Guid<sorterModelID>) 
            (sortingWidth: int<sortingWidth>) 
            (perm_Sis: Perm_Si array) : Mssi =
        if perm_Sis.Length < 1 then
            failwith "Must have at least 1 Perm_Si"
        else if %sortingWidth < 1 then
            failwith "Width must be at least 1"
        else
            { id = id; sortingWidth = sortingWidth; perm_Sis = perm_Sis }

    member this.Id with get () = this.id
    member this.SortingWidth with get () = this.sortingWidth
    member this.StageCount with get () = this.perm_Sis.Length |> UMX.tag<stageCount>
    member this.Perm_Sis with get () = this.perm_Sis
    member this.toString() =
        sprintf "mssi(Id=%A, SortingWidth=%d, StageCount=%d)" 
                (%this.Id) 
                (%this.SortingWidth)
                (this.StageCount)

    override this.Equals(obj) = 
        match obj with
        | :? Mssi as other -> 
            this.id = other.id && 
            this.sortingWidth = other.sortingWidth && 
            this.perm_Sis = other.perm_Sis
        | _ -> false

    override this.GetHashCode() = 
        hash (this.GetType(), this.id, this.sortingWidth, this.perm_Sis)

    interface IEquatable<Mssi> with
        member this.Equals(other) = 
            this.id = other.id &&  
            this.sortingWidth = other.sortingWidth && 
            this.perm_Sis = other.perm_Sis

    interface ISorterModel with
        member this.Id = this.id 
        member this.MakeSorter() = 
            let ces = this.perm_Sis
                        |> Array.map (fun psi -> psi |> Perm_Si.getTwoOrbits)
                        |> Array.collect(id)
                        |> Array.map(fun tbit -> Ce.create tbit.First tbit.Second)
            Sorter.create (%this.Id |> UMX.tag<sorterId>) this.SortingWidth ces




module Mssi =

    let toString (mssi: Mssi) : string =
        sprintf "Mssi(Id=%A, Width=%d, StageCount=%d)" 
                (%mssi.Id) 
                (%mssi.SortingWidth) 
                mssi.StageCount

    let makeSorter (mssi: Mssi) : Sorter =
        let ces = mssi.perm_Sis
                    |> Array.map (fun psi -> psi |> Perm_Si.getTwoOrbits)
                    |> Array.collect(id)
                    |> Array.map(fun tbit -> Ce.create tbit.First tbit.Second)
        Sorter.create (%mssi.Id |> UMX.tag<sorterId>) mssi.SortingWidth ces
         
namespace GeneSort.Model.Sorter.Si

open FSharp.UMX
open GeneSort.Core
open System
open GeneSort.Sorter
open GeneSort.Model.Sorter

/// Represents a configuration for generating random Mssi instances with specified width and stage count.
[<Struct; CustomEquality; NoComparison>]
type MssiRandGen = 
    private 
        { 
          id : Guid<sorterModelMakerID>
          rngType: rngType
          sortingWidth: int<sortingWidth>
          stageCount: int<stageCount> 
        } 
    with

    static member create 
            (rngType: rngType) 
            (sortingWidth: int<sortingWidth>)
            (stageCount: int<stageCount>) 
                : MssiRandGen =
        if %sortingWidth < 2 then
            failwith $"SortingWidth must be at least 2, got {%sortingWidth}"
        else if %stageCount < 1 then
            failwith $"StageCount must be at least 1, got {%stageCount}"
        else
            let id =
                [
                    rngType :> obj
                    sortingWidth :> obj
                    %stageCount :> obj
                ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

            { 
                id = id; 
                rngType = rngType; 
                sortingWidth = sortingWidth; 
                stageCount = stageCount 
            }

    member this.Id with get () = this.id
    member this.RngType with get () = this.rngType
    member this.SortingWidth with get () = this.sortingWidth
    member this.StageCount with get () = this.stageCount

    override this.Equals(obj) = 
        match obj with
        | :? MssiRandGen as other -> 
            this.rngType = other.rngType && 
            this.sortingWidth = other.sortingWidth &&
            this.stageCount = other.stageCount
        | _ -> false

    override this.GetHashCode() = 
        hash (this.GetType(), this.rngType, this.sortingWidth, this.stageCount)

    interface IEquatable<MssiRandGen> with
        member this.Equals(other) = 
            this.rngType = other.rngType && 
            this.sortingWidth = other.sortingWidth &&
            this.stageCount = other.stageCount

    interface ISorterModelMaker with
        member this.Id = this.id
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) 
                (index: int) : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rando = rngFactory this.RngType %id
            let perm_Sis = Perm_Si.makeRandoms (rando.NextIndex) (%this.SortingWidth) 
                           |> Seq.take (%this.StageCount)
                           |> Seq.toArray
            Mssi.create id this.SortingWidth perm_Sis



module MssiRandGen =

    /// Returns a string representation of the MssiRandGen.
    let toString (mssiRandGen: MssiRandGen) : string =
        sprintf "MssiRandGen(RngType=%A, Width=%d, StageCount=%d)" 
                mssiRandGen.RngType (%mssiRandGen.SortingWidth) (%mssiRandGen.StageCount)
namespace GeneSort.Model.Sorter.Si

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Core.Perm_Si
open GeneSort.Model.Sorter


/// Represents a configuration for mutating Mssi instances with specified mutation probabilities.
[<Struct; CustomEquality; NoComparison>]
type MssiRandMutate = 
    private 
        { 
              id : Guid<sorterModelMakerID>
              mssi : Mssi
              rngType: rngType
              opActionRates: OpActionRatesArray
        } 
    static member create 
            (rngType: rngType)
            (mssi: Mssi)
            (opActionRatesArray: OpActionRatesArray)
            : MssiRandMutate =
        
        if %mssi.Perm_Sis.Length <> opActionRatesArray.Length then failwith "Perm_Sis length must match opActionRatesArray.Length"

        let id =
            [
                rngType :> obj
                mssi :> obj
                opActionRatesArray :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

        {
            id = id
            mssi = mssi
            opActionRates = opActionRatesArray
            rngType = rngType
        }
        
    member this.Id with get () = this.id
    member this.Mssi with get () = this.mssi
    member this.RngType with get () = this.rngType
    member this.StageCount with get () = this.opActionRates.Length
    member this.OpActionRates with get () = this.opActionRates

    override this.Equals(obj) = 
        match obj with
        | :? MssiRandMutate as other -> 
            this.id = other.id
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.mssi, this.opActionRates)

    interface IEquatable<MssiRandMutate> with
        member this.Equals(other) = 
            this.Id = other.Id

    interface ISorterModelMaker with
        member this.Id = this.id

        /// Mutates an Msce by applying ChromosomeRates.mutate to its ceCodes array.
        /// Generates a new Msce with a new ID, the same sortingWidth, and a mutated ceCodes array.
        /// The ceCodes array is modified using the provided chromosomeRates, with insertions and mutations
        /// generated via Ce.generateCeCode, and deletions handled to maintain the ceCount length.
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let orthoMutator = fun psi ->  Perm_Si.mutate (rng.NextIndex) MutationMode.Ortho psi 
            let paraMutator = fun psi ->   Perm_Si.mutate (rng.NextIndex) MutationMode.Para psi 
            let mutated = OpActionRatesArray.mutate 
                            this.OpActionRates 
                            orthoMutator 
                            paraMutator 
                            (rng.NextFloat) 
                            this.Mssi.Perm_Sis
            Mssi.create id this.Mssi.SortingWidth mutated



module MssiRandMutate =

    let toString (mssiRandMutate: MssiRandMutate) : string = 
        sprintf "MssiRandMutate(RngType=%A, Width=%d, StageCount=%d, OpActionRates=%s)" 
                mssiRandMutate.RngType 
                (%mssiRandMutate.Mssi.SortingWidth) 
                (mssiRandMutate.StageCount)
                (mssiRandMutate.OpActionRates.ToString())
namespace GeneSort.Model.Sorter.Uf4

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core
open GeneSort.Model.Sorter

/// Represents a collection of TwoOrbitUnfolder4 instances with a consistent sorting width.
[<Struct; CustomEquality; NoComparison>]
type Msuf4 = 
    private 
        { id: Guid<sorterModelID>
          sortingWidth: int<sortingWidth>
          twoOrbitUnfolder4s: TwoOrbitUf4 array } 
    with
    /// Creates an Msuf4 instance with the specified ID, sorting width, and array of TwoOrbitUnfolder4 instances.
    /// Throws an exception if the array is empty, width is less than 1, or any TwoOrbitUnfolder4 has a mismatched order.
    static member create 
            (id: Guid<sorterModelID>) 
            (sortingWidth: int<sortingWidth>) 
            (twoOrbitUnfolder4s: TwoOrbitUf4 array) : Msuf4 =
        if twoOrbitUnfolder4s.Length < 1 then
            failwith $"Must have at least 1 TwoOrbitUnfolder4, got %d{twoOrbitUnfolder4s.Length}"
        else if %sortingWidth < 1 then
            failwith $"SortingWidth must be at least 1, got {%sortingWidth}"
        else if twoOrbitUnfolder4s |> Array.exists (fun tou -> tou.Order <> %sortingWidth) then
            failwith $"All TwoOrbitUnfolder4 must have order {%sortingWidth}"
        else
            { id = id; sortingWidth = sortingWidth; twoOrbitUnfolder4s = twoOrbitUnfolder4s }

    member this.Id with get () = this.id
    member this.SortingWidth with get () = this.sortingWidth
    member this.TwoOrbitUnfolder4s with get () = this.twoOrbitUnfolder4s
    member this.StageCount with get () = (this.twoOrbitUnfolder4s.Length |> UMX.tag<stageCount>)
    member this.toString() =
        sprintf "msuf4(Id=%A, SortingWidth=%d, TwoOrbitUnfolder4Count=%d)" 
                (%this.Id) 
                (%this.SortingWidth) 
                (this.TwoOrbitUnfolder4s.Length)

    override this.Equals(obj) = 
        match obj with
        | :? Msuf4 as other -> 
            this.id = other.id
        | _ -> false

    override this.GetHashCode() = 
        hash (this.GetType(), this.id)

    interface IEquatable<Msuf4> with
        member this.Equals(other) = 
            this.id = other.id

    interface ISorterModel with
        member this.Id = this.id 
        member this.MakeSorter() = 
            let ces = 
                this.TwoOrbitUnfolder4s
                |> Array.collect (fun tou ->
                    tou.MakePerm_Si
                    |> Perm_Si.getTwoOrbits
                    |> Array.map Ce.fromTwoOrbit)
            Sorter.create (%this.Id |> UMX.tag<sorterId>) this.SortingWidth ces



module Msuf4 =

    /// Returns a string representation of the Msuf4 instance.
    let toString (msuf4: Msuf4) : string =
        sprintf "Msuf4(Id=%A, SortingWidth=%d, TwoOrbitUnfolder4Count=%d)" 
                (%msuf4.Id) 
                (%msuf4.SortingWidth) 
                msuf4.StageCount
namespace GeneSort.Model.Sorter.Uf4
open System
open FSharp.UMX
open GeneSort.Model.Sorter
open GeneSort.Core
open GeneSort.Sorter
open MathUtils

[<Struct; CustomEquality; NoComparison>]
type Msuf4RandGen = 
    private 
        { 
          id: Guid<sorterModelMakerID>
          rngType: rngType
          sortingWidth: int<sortingWidth>
          stageCount: int<stageCount> 
          genRates: Uf4GenRatesArray } 
    with
    /// Creates an Msuf4RandGen with the specified parameters.
    /// Throws an exception if rngType is invalid, width is not a power of 2, stageCount is less than 1, 
    /// or genRates array length does not match stageCount or contains invalid entries.
    /// <param name="rngType">The type of random number generator to use.</param>
    /// <param name="sortingWidth">The sorting width for the Msuf4 instance (must be a power of 2).</param>
    /// <param name="stageCount">The number of TwoOrbitUnfolder4 instances in the Msuf4 instance.</param>
    /// <param name="genRates">Array of generation rates for each TwoOrbitUnfolder4.</param>
    static member create 
            (rngType: rngType) 
            (sortingWidth: int<sortingWidth>)
            (stageCount: int<stageCount>) 
            (genRates: Uf4GenRatesArray) 
            : Msuf4RandGen =
        if %sortingWidth < 1 then
            failwith $"SortingWidth must be at least 1, got {%sortingWidth}"
        else if (%sortingWidth - 1) &&& %sortingWidth <> 0 then
            failwith $"SortingWidth must be a power of 2, got {%sortingWidth}"
        else if %stageCount < 1 then
            failwith $"StageCount must be at least 1, got {%stageCount}"
        else if genRates.Length <> %stageCount then
            failwith $"genRates array length (%d{genRates.Length}) must equal stageCount ({%stageCount})"
        else if genRates.RatesArray |> Array.exists (fun gr -> gr.order <> %sortingWidth) then
            failwith $"All genRates must have order {%sortingWidth}"
        else if genRates.RatesArray |> Array.exists (fun gr -> gr.opsGenRatesList.Length <> exactLog2(gr.order / 4)) then
            failwith "twoOrbitTypeGenRatesList length must equal log2(order/4)"
        else
            let id =
                [
                    rngType :> obj
                    sortingWidth :> obj
                    stageCount :> obj
                    genRates :> obj
                ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

            { id = id
              rngType = rngType
              sortingWidth = sortingWidth
              stageCount = stageCount
              genRates = genRates }

    member this.RngType with get () = this.rngType
    member this.SortingWidth with get () = this.sortingWidth
    member this.StageCount with get () = this.stageCount
    member this.GenRates with get () = this.genRates

    override this.Equals(obj) = 
        match obj with
        | :? Msuf4RandGen as other -> 
            this.rngType = other.rngType && 
            this.sortingWidth = other.sortingWidth &&
            this.stageCount = other.stageCount &&
            this.genRates.Equals(other.genRates)
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.sortingWidth, this.stageCount, this.genRates)

    interface IEquatable<Msuf4RandGen> with
        member this.Equals(other) = 
            this.rngType = other.rngType && 
            this.sortingWidth = other.sortingWidth &&
            this.stageCount = other.stageCount &&
            this.genRates.Equals(other.genRates)

    interface ISorterModelMaker with
        member this.Id = this.id

        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rando = rngFactory this.RngType %id
            let sc = %this.StageCount
            let genRts = this.GenRates
            let twoOrbitUnfolder4s =
                    [| for dex in 0 .. (sc - 1) ->
                        UnfolderOps4.makeTwoOrbitUf4 rando.NextFloat (genRts.Item(dex)) |]
            Msuf4.create id this.SortingWidth twoOrbitUnfolder4s



module Msuf4RandGen =

    /// Generates a unique ID for an Msuf4 instance based on the Msuf4RandGen configuration and an index.
    let makeId (msuf4RandGen: Msuf4RandGen) (index: int) : Guid<sorterModelID> =
        [ 
            msuf4RandGen.RngType :> obj
            %msuf4RandGen.SortingWidth :> obj
            %msuf4RandGen.StageCount :> obj
            msuf4RandGen.GenRates.RatesArray :> obj
            index :> obj
        ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelID>

    /// Returns a string representation of the Msuf4RandGen configuration.
    let toString (msuf4Gen: Msuf4RandGen) : string =
        let genRatesStr = 
            msuf4Gen.GenRates.RatesArray 
            |> Array.mapi (fun i gr -> 
                sprintf "[%d: Ortho=%f, Para=%f, SelfRefl=%f]" 
                    i gr.seedOpsGenRates.OrthoRate gr.seedOpsGenRates.ParaRate gr.seedOpsGenRates.SelfReflRate)
            |> String.concat ", "
        sprintf "Msuf4RandGen(RngType=%A, Width=%d, StageCount=%d, GenRates=%s)" 
                msuf4Gen.RngType 
                (%msuf4Gen.SortingWidth) 
                (%msuf4Gen.StageCount)
                genRatesStr
namespace GeneSort.Model.Sorter.Uf4
open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Model.Sorter


[<Struct; CustomEquality; NoComparison>]
type Msuf4RandMutate = 
    private 
        {
          id : Guid<sorterModelMakerID>
          msuf4 : Msuf4
          rngType: rngType
          uf4MutationRatesArray: Uf4MutationRatesArray } 
    static member create 
            (rngType: rngType)
            (msuf4 : Msuf4)
            (uf4MutationRatesArray: Uf4MutationRatesArray) 
            : Msuf4RandMutate =
        if rngType = Unchecked.defaultof<rngType> then
            failwith "rngType must be specified"
        else if uf4MutationRatesArray.Length <> %msuf4.StageCount then
            failwith $"mutationRates array length (%d{uf4MutationRatesArray.Length}) must equal stageCount ({%msuf4.StageCount})"

        let id =
            [
                rngType :> obj
                msuf4 :> obj
                uf4MutationRatesArray :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

        {
            id = id
            rngType = rngType
            msuf4 = msuf4
            uf4MutationRatesArray = uf4MutationRatesArray
        }

    static member createFromSingleRate
            (rngType: rngType)
            (msuf4 : Msuf4)
            (rates: Uf4MutationRates) 
            : Msuf4RandMutate =
        let mutationRates = Uf4MutationRatesArray.create (Array.create (%msuf4.StageCount) rates)
        Msuf4RandMutate.create rngType msuf4 mutationRates

    member this.Id with get () = this.id
    member this.Msuf4 with get () = this.msuf4
    member this.RngType with get () = this.rngType
    member this.StageCount with get () = this.msuf4.StageCount
    member this.Uf4MutationRatesArray with get () = this.uf4MutationRatesArray

    override this.Equals(obj) = 
        match obj with
        | :? Msuf4RandMutate as other -> 
            this.rngType = other.rngType && 
            this.msuf4 = other.msuf4 &&
            this.uf4MutationRatesArray.Equals(other.uf4MutationRatesArray)
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.msuf4, this.uf4MutationRatesArray)

    interface IEquatable<Msuf4RandMutate> with
        member this.Equals(other) = 
            this.Id = other.Id

    interface ISorterModelMaker with
        member this.Id = this.id

        /// Mutates an Msce by applying ChromosomeRates.mutate to its ceCodes array.
        /// Generates a new Msce with a new ID, the same sortingWidth, and a mutated ceCodes array.
        /// The ceCodes array is modified using the provided chromosomeRates, with insertions and mutations
        /// generated via Ce.generateCeCode, and deletions handled to maintain the ceCount length.
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) 
                        : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            if %this.StageCount <> this.Uf4MutationRatesArray.Length then
                failwith $"Stage count of Msuf4 {%this.StageCount} must match Msuf4RandMutate length {this.Uf4MutationRatesArray.Length}"
            //else if msuf4RandMutate.MutationRates.RatesArray |> Array.exists (fun rates -> rates.twoOrbitPairOpsTransitionRates.Length <> exactLog2(%msuf4.SortingWidth / 4)) then
            //    failwith $"All mutationRates must have twoOrbitPairOpsTransitionRates length equal to log2(sortingWidth/4)"
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let mutatedUnfolders = 
                Array.zip this.msuf4.TwoOrbitUnfolder4s this.Uf4MutationRatesArray.RatesArray
                |> Array.map (fun (unfolder, mutationRates) ->
                    UnfolderOps4.mutateTwoOrbitUf4 rng.NextFloat mutationRates unfolder)
            Msuf4.create id this.msuf4.SortingWidth mutatedUnfolders



module Msuf4RandMutate =

    /// Returns a string representation of the Msuf4RandMutate configuration.
    let toString (msuf4RandMutate: Msuf4RandMutate) : string =
        let ratesStr = 
            msuf4RandMutate.Uf4MutationRatesArray.RatesArray
            |> Array.mapi (fun i rates -> 
                sprintf "[%d: OrthoToPara=%f, OrthoToSelfRefl=%f, ParaToOrtho=%f, ParaToSelfRefl=%f, SelfReflToOrtho=%f, SelfReflToPara=%f]" 
                    i 
                    rates.seedOpsTransitionRates.OrthoRates.ParaRate
                    rates.seedOpsTransitionRates.OrthoRates.SelfReflRate
                    rates.seedOpsTransitionRates.ParaRates.OrthoRate
                    rates.seedOpsTransitionRates.ParaRates.SelfReflRate
                    rates.seedOpsTransitionRates.SelfReflRates.OrthoRate
                    rates.seedOpsTransitionRates.SelfReflRates.ParaRate)
            |> String.concat ", "
        sprintf "Msuf4RandMutate(RngType=%A, StageCount=%d, MutationRates=%s)" 
                msuf4RandMutate.RngType 
                (%msuf4RandMutate.StageCount)
                ratesStr
namespace GeneSort.Model.Sorter.Uf6

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core
open GeneSort.Model.Sorter

/// Represents a collection of TwoOrbitUnfolder4 instances with a consistent sorting width.
[<Struct; CustomEquality; NoComparison>]
type Msuf6 = 
    private 
        { id: Guid<sorterModelID>
          sortingWidth: int<sortingWidth>
          twoOrbitUnfolder6s: TwoOrbitUf6 array } 
    with
    /// Creates an Msuf6 instance with the specified ID, sorting width, and array of TwoOrbitUnfolder4 instances.
    /// Throws an exception if the array is empty, width is less than 1, or any TwoOrbitUnfolder4 has a mismatched order.
    static member create 
            (id: Guid<sorterModelID>) 
            (sortingWidth: int<sortingWidth>) 
            (twoOrbitUnfolder6s: TwoOrbitUf6 array) : Msuf6 =
        if twoOrbitUnfolder6s.Length < 1 then
            failwith $"Must have at least 1 TwoOrbitUnfolder6, got %d{twoOrbitUnfolder6s.Length}"
        else if %sortingWidth < 1 then
            failwith $"SortingWidth must be at least 1, got {%sortingWidth}"
        else if twoOrbitUnfolder6s |> Array.exists (fun tou -> tou.Order <> %sortingWidth) then
            failwith $"All TwoOrbitUnfolder6 must have order {%sortingWidth}"
        else
            { id = id; sortingWidth = sortingWidth; twoOrbitUnfolder6s = twoOrbitUnfolder6s }

    member this.Id with get () = this.id
    member this.SortingWidth with get () = this.sortingWidth
    member this.TwoOrbitUnfolder6s with get () = this.twoOrbitUnfolder6s
    member this.StageCount with get () = (this.twoOrbitUnfolder6s.Length |> UMX.tag<stageCount>)
    member this.toString() =
        sprintf "msuf6(Id=%A, SortingWidth=%d, TwoOrbitUnfolder6Count=%d)" 
                (%this.Id) 
                (%this.SortingWidth) 
                (this.TwoOrbitUnfolder6s.Length)

    override this.Equals(obj) = 
        match obj with
        | :? Msuf6 as other -> 
            this.id = other.id
        | _ -> false

    override this.GetHashCode() = 
        hash (this.GetType(), this.id)

    interface IEquatable<Msuf6> with
        member this.Equals(other) = 
            this.id = other.id

    interface ISorterModel with
        member this.Id = this.id 
        member this.MakeSorter() = 
            let ces = 
                this.TwoOrbitUnfolder6s
                |> Array.collect (fun tou ->
                    tou.MakePerm_Si
                    |> Perm_Si.getTwoOrbits
                    |> Array.map Ce.fromTwoOrbit)
            Sorter.create (%this.Id |> UMX.tag<sorterId>) this.SortingWidth ces





module Msuf6 =

    /// Returns a string representation of the Msuf6 instance.
    let toString (msuf6: Msuf6) : string =
        sprintf "Msuf6(Id=%A, SortingWidth=%d, TwoOrbitUnfolder6Count=%d)" 
                (%msuf6.Id) 
                (%msuf6.SortingWidth) 
                msuf6.StageCount
namespace GeneSort.Model.Sorter.Uf6
open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core
open GeneSort.Model.Sorter

[<Struct; CustomEquality; NoComparison>]
type Msuf6RandGen = 
    private 
        { id: Guid<sorterModelMakerID>
          rngType: rngType
          sortingWidth: int<sortingWidth>
          stageCount: int<stageCount> 
          genRates: Uf6GenRatesArray }

    static member create 
            (rngType: rngType) 
            (sortingWidth: int<sortingWidth>) 
            (stageCount: int<stageCount>) 
            (genRates: Uf6GenRatesArray) : Msuf6RandGen =
        if %sortingWidth < 6 || %sortingWidth % 2 <> 0 then
            failwith $"SortingWidth must be at least 6 and even, got {%sortingWidth}"
        if %stageCount < 1 then
            failwith $"StageCount must be at least 1, got {%stageCount}"
        if genRates.Length <> %stageCount then
            failwith $"Uf6GenRatesArray length (%d{genRates.Length}) must equal stageCount (%d{%stageCount})"
        if genRates.RatesArray |> Array.exists (fun r -> r.order <> %sortingWidth) then
            failwith $"All Uf6GenRates in genRates must have order {%sortingWidth}"
        let id =
            [
                rngType :> obj
                sortingWidth :> obj
                stageCount :> obj
                genRates :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>
        { id = id
          rngType = rngType
          sortingWidth = sortingWidth
          stageCount = stageCount
          genRates = genRates }

    member this.Id with get() = this.id
    member this.RngType with get() = this.rngType
    member this.SortingWidth with get() = this.sortingWidth
    member this.StageCount with get() = this.stageCount
    member this.GenRates with get() = this.genRates

    member this.toString() =
        sprintf "Msuf6RandGen(Id=%A, RngType=%A, SortingWidth=%d, StageCount=%d, GenRates=%s)"
                (%this.id)
                this.rngType
                (%this.sortingWidth)
                (%this.stageCount)
                (this.genRates.toString())

    override this.Equals(obj) =
        match obj with
        | :? Msuf6RandGen as other ->
            this.id = other.id
        | _ -> false

    override this.GetHashCode() =
        hash (this.id)

    interface IEquatable<Msuf6RandGen> with
        member this.Equals(other) =
            this.id = other.id

    interface ISorterModelMaker with
        member this.Id = this.id

        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let genRatesArray = this.GenRates
            let stageCount = %this.StageCount
            let sortingWidth = %this.SortingWidth
            let twoOrbitUnfolder6s =
                [| for dex in 0 .. (stageCount - 1) ->
                    UnfolderOps6.makeTwoOrbitUf6
                        rng.NextFloat
                        (genRatesArray.Item(dex)) |]
            Msuf6.create id this.SortingWidth twoOrbitUnfolder6s :> ISorterModel

module Msuf6RandGen =

    let toString (msuf6RandGen: Msuf6RandGen) : string =
        sprintf "Msuf6RandGen(Id=%A, RngType=%A, SortingWidth=%d, StageCount=%d, GenRates=%s)"
                (%msuf6RandGen.Id)
                msuf6RandGen.RngType
                (%msuf6RandGen.SortingWidth)
                (%msuf6RandGen.StageCount)
                (msuf6RandGen.GenRates.toString())
namespace GeneSort.Model.Sorter.Uf6
open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf6


[<Struct; CustomEquality; NoComparison>]
type Msuf6RandMutate = 
    private 
        {
          id : Guid<sorterModelMakerID>
          msuf6 : Msuf6
          rngType: rngType
          uf6MutationRatesArray: Uf6MutationRatesArray } 
    static member create 
            (rngType: rngType)
            (msuf6 : Msuf6)
            (uf6MutationRatesArray: Uf6MutationRatesArray) 
            : Msuf6RandMutate =
        if rngType = Unchecked.defaultof<rngType> then
            failwith "rngType must be specified"
        else if uf6MutationRatesArray.Length <> %msuf6.StageCount then
            failwith $"mutationRates array length (%d{uf6MutationRatesArray.Length}) must equal stageCount ({%msuf6.StageCount})"

        let id =
            [
                rngType :> obj
                msuf6 :> obj
                uf6MutationRatesArray :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelMakerID>

        {
            id = id
            rngType = rngType
            msuf6 = msuf6
            uf6MutationRatesArray = uf6MutationRatesArray
        }

    static member createFromSingleRate
            (rngType: rngType)
            (msuf6 : Msuf6)
            (rates: Uf6MutationRates) 
            : Msuf6RandMutate =
        let mutationRates = Uf6MutationRatesArray.create (Array.create (%msuf6.StageCount) rates)
        Msuf6RandMutate.create rngType msuf6 mutationRates

    member this.Id with get () = this.id
    member this.Msuf6 with get () = this.msuf6
    member this.RngType with get () = this.rngType
    member this.StageCount with get () = this.msuf6.StageCount
    member this.Uf6MutationRatesArray with get () = this.uf6MutationRatesArray

    override this.Equals(obj) = 
        match obj with
        | :? Msuf6RandMutate as other -> 
            this.rngType = other.rngType && 
            this.msuf6 = other.msuf6 &&
            this.uf6MutationRatesArray.Equals(other.uf6MutationRatesArray)
        | _ -> false

    override this.GetHashCode() = 
        hash (this.rngType, this.msuf6, this.uf6MutationRatesArray)

    interface IEquatable<Msuf6RandMutate> with
        member this.Equals(other) = 
            this.Id = other.Id

    interface ISorterModelMaker with
        member this.Id = this.id

        /// Mutates an Msce by applying ChromosomeRates.mutate to its ceCodes array.
        /// Generates a new Msce with a new ID, the same sortingWidth, and a mutated ceCodes array.
        /// The ceCodes array is modified using the provided chromosomeRates, with insertions and mutations
        /// generated via Ce.generateCeCode, and deletions handled to maintain the ceCount length.
        member this.MakeSorterModel (rngFactory: rngType -> Guid -> IRando) (index: int) 
                        : ISorterModel =
            let id = SorterModelMaker.makeSorterModelId this index
            if %this.StageCount <> this.Uf6MutationRatesArray.Length then
                failwith $"Stage count of Msuf6 {%this.StageCount} must match Msuf6RandMutate length {this.Uf6MutationRatesArray.Length}"
            //else if msuf6RandMutate.MutationRates.RatesArray |> Array.exists (fun rates -> rates.twoOrbitPairOpsTransitionRates.Length <> exactLog2(%msuf6.SortingWidth / 4)) then
            //    failwith $"All mutationRates must have twoOrbitPairOpsTransitionRates length equal to log2(sortingWidth/4)"
            let id = SorterModelMaker.makeSorterModelId this index
            let rng = rngFactory this.RngType %id
            let mutatedUnfolders = 
                Array.zip this.msuf6.TwoOrbitUnfolder6s this.Uf6MutationRatesArray.RatesArray
                |> Array.map (fun (unfolder, mutationRates) ->
                    UnfolderOps6.mutateTwoOrbitUf6 rng.NextFloat mutationRates unfolder)
            Msuf6.create id this.msuf6.SortingWidth mutatedUnfolders



module Msuf6RandMutate =

    /// Returns a string representation of the Msuf6RandMutate configuration.
    let toString (msuf6RandMutate: Msuf6RandMutate) : string =
        let ratesStr = 
            msuf6RandMutate.Uf6MutationRatesArray.RatesArray
            |> Array.mapi (fun i rates -> 
                sprintf "[%d: OrthoToPara=%f, OrthoToSelfRefl=%f, ParaToOrtho=%f, ParaToSelfRefl=%f, SelfReflToOrtho=%f, SelfReflToPara=%f]" 
                    i 
                    rates.seed6TransitionRates.Ortho1Rates.Ortho2Rate
                    rates.seed6TransitionRates.Ortho2Rates.SelfReflRate
                    rates.seed6TransitionRates.Para1Rates.Ortho1Rate
                    rates.seed6TransitionRates.Para2Rates.SelfReflRate
                    rates.seed6TransitionRates.SelfReflRates.Ortho1Rate
                    rates.seed6TransitionRates.SelfReflRates.Para1Rate)
            |> String.concat ", "
        sprintf "Msuf6RandMutate(RngType=%A, StageCount=%d, MutationRates=%s)" 
                msuf6RandMutate.RngType 
                (%msuf6RandMutate.StageCount)
                ratesStr
namespace GeneSort.Model.Sorter

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core


[<Measure>] type sorterModelID
[<Measure>] type sorterModelSetID
[<Measure>] type sorterModelMakerID
[<Measure>] type sorterModelSetMakerID

type ISorterModel =
    abstract member Id : Guid<sorterModelID>
    abstract member MakeSorter : unit -> Sorter

type ISorterModelMaker =
    abstract member Id : Guid<sorterModelMakerID>
    abstract member MakeSorterModel : (rngType -> Guid -> IRando) -> int -> ISorterModel


module SorterModelMaker =
    let makeSorterModelId (sorterModelMaker: ISorterModelMaker) (index:int) =
        [
            %sorterModelMaker.Id  :> obj
            index :> obj
        ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelID>
namespace GeneSort.Model.Sorter

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6


type SorterModel =
     | MsceRandGen of Msce
     | MssiRandGen of Mssi
     | MsrsRandGen of Msrs
     | Msuf4RandGen of Msuf4
     | Msuf6RandGen of Msuf6

namespace GeneSort.Model.Sorter

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6


type SorterModelMaker =
     | MsceRandGen of MsceRandGen
     | MsceRandMutate of MsceRandMutate
     | MssiRandGen of MssiRandGen
     | MssiRandMutate of MssiRandMutate
     | MsrsRandGen of MsrsRandGen
     | MsrsRandMutate of MsrsRandMutate
     | Msuf4RandGen of Msuf4RandGen
     | Msuf4RandMutate of Msuf4RandMutate
     | Msuf6RandGen of Msuf6RandGen
     | Msuf6RandMutate of Msuf6RandMutate
namespace GeneSort.Model.Sorter

open FSharp.UMX
open GeneSort.Sorter

type SorterModelSet =
    { Id : Guid<sorterModelSetID>
      SorterModels : ISorterModel[] }

module SorterModelSet =

    let makeSorterSet (modelSet: SorterModelSet) : SorterSet =
        let sorters = modelSet.SorterModels |> Array.map (fun sm -> sm.MakeSorter())
        SorterSet.create (%modelSet.Id |> UMX.tag<sorterSetId>) sorters
namespace GeneSort.Model.Sorter

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Core

type SorterModelSetMaker =
    private
        { 
          Id : Guid<sorterModelSetMakerID>
          SorterModelMaker : ISorterModelMaker
          firstIndex : int
          count : int 
        }
    with
    static member create 
                (sorterModelMaker: ISorterModelMaker) 
                (firstIndex: int) 
                (count: int) : SorterModelSetMaker =
        let id = 
            [ 
              sorterModelMaker.Id :> obj
              firstIndex :> obj
              count :> obj
            ] |> GuidUtils.guidFromObjs |> UMX.tag<sorterModelSetMakerID>

        if count < 1 then
            failwith "Count must be at least 1"

        else
            { Id = id; SorterModelMaker = sorterModelMaker; firstIndex = firstIndex; count = count }


module SorterModelSetMaker =

    let makeSorterModelSet 
                (randoGen: rngType -> Guid -> IRando)
                (sorterModelSetMaker: SorterModelSetMaker) 
          : SorterModelSet =
          {
            Id = %sorterModelSetMaker.Id |> UMX.tag<sorterModelSetID>
            SorterModels =
                Array.init sorterModelSetMaker.count (fun i ->
                    let index = i + sorterModelSetMaker.firstIndex
                    sorterModelSetMaker.SorterModelMaker.MakeSorterModel (randoGen) index)
         }

    let makeSorterSet 
                (randoGen: rngType -> Guid -> IRando)
                (sorterModelSetMaker: SorterModelSetMaker) 
          : SorterSet =
        makeSorterModelSet randoGen sorterModelSetMaker |> SorterModelSet.makeSorterSet
// For more information see https://aka.ms/fsharp-console-apps
printfn "Hello from F#"
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Model.MessagePack")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Model.MessagePack")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Model.MessagePack")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Model.Mp")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd0ecb4b7b45c20f3de2591024c41fde4f7aea3a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Model.Mp")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Model.Mp")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()

namespace GeneSort.Model.Mp.Sorter.Ce

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Model.Sorter.Ce

open MessagePack
open GeneSort.Model.Sorter

[<MessagePackObject; Struct>]
type MsceDTO =
    { [<Key(0)>] Id: Guid
      [<Key(1)>] SortingWidth: int
      [<Key(2)>] CeCodes: int array }
    
    static member Create(id: Guid, sortingWidth: int, ceCodes: int array) : MsceDTO =
        if isNull ceCodes || ceCodes.Length < 1 then
            invalidArg "ceCodes" "Must be at least 1 Ce"
        if sortingWidth < 1 then
            invalidArg "sortingWidth" "SortingWidth must be at least 1"
        
        { Id = id; SortingWidth = sortingWidth; CeCodes = ceCodes }
    
    member this.CeCount = this.CeCodes.Length


module MsceDTO =
    type MsceDTOError =
        | InvalidCeCodesLength of string
        | InvalidSortingWidth of string

    let toMsceDTO (msce: Msce) : MsceDTO =
        { Id = %msce.Id
          SortingWidth = %msce.SortingWidth
          CeCodes = msce.CeCodes }

    let toMsce (msceDTO: MsceDTO) : Result<Msce, MsceDTOError> =
        try
            let msce = GeneSort.Model.Sorter.Ce.Msce.create
                            (UMX.tag<sorterModelID> msceDTO.Id)
                            (UMX.tag<sortingWidth> msceDTO.SortingWidth)
                            msceDTO.CeCodes
            Ok msce
        with
        | :? ArgumentException as ex when ex.Message.Contains("Ce") ->
            Error (InvalidCeCodesLength ex.Message)
        | :? ArgumentException as ex when ex.Message.Contains("SortingWidth") ->
            Error (InvalidSortingWidth ex.Message)
        | ex ->
            Error (InvalidCeCodesLength ex.Message) // Fallback for unexpected errors

namespace GeneSort.Model.Mp.Sorter.Ce

open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Model.Sorter.Ce

open MessagePack
open GeneSort.Model.Sorter



[<MessagePackObject>]
type MsceRandGenDto = 
    { [<Key("sortingWidth")>] SortingWidth: int
      [<Key("ceCount")>] CeCount: int
      [<Key("excludeSelfCe")>] ExcludeSelfCe: bool }

module MsceRandGenDto =

    let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)

    let toMsceRandGenDto (msceRandGen: MsceRandGen) : MsceRandGenDto =
        { SortingWidth = %msceRandGen.SortingWidth
          CeCount = %msceRandGen.CeCount
          ExcludeSelfCe = msceRandGen.ExcludeSelfCe }

    let fromMsceRandGenDto (dto: MsceRandGenDto) : MsceRandGen =
        if dto.SortingWidth < 1 then
            failwith "SortingWidth must be at least 1"
        if dto.CeCount < 1 then
            failwith "CeCount must be at least 1"
        if dto.ExcludeSelfCe && dto.SortingWidth < 2 then
            failwith "SortingWidth must be at least 2 when ExcludeSelfCe is true"
        { SortingWidth = UMX.tag<sortingWidth> dto.SortingWidth
          CeCount = UMX.tag<ceCount> dto.CeCount
          ExcludeSelfCe = dto.ExcludeSelfCe }


namespace GeneSort.Model.Mp.Sorter.Rs
open System
open FSharp.UMX
open GeneSort.Sorter
open GeneSort.Model.Sorter.Rs
open MessagePack
open GeneSort.Core.Mp
open GeneSort.Model.Sorter

[<MessagePackObject; Struct>]
type MsrsDTO =
    { [<Key(0)>] Id: Guid
      [<Key(1)>] Width: int
      [<Key(2)>] Perm_Rss: Perm_RsDTO array }
    
    static member Create(id: Guid, width: int, permRss: Perm_RsDTO array) : Result<MsrsDTO, string> =
        if isNull permRss then
            Error "Perm_Rss array cannot be null"
        else if permRss.Length < 1 then
            Error $"Must have at least 1 Perm_Rs, got {permRss.Length}"
        else if width < 1 then
            Error $"Width must be at least 1, got {width}"
        else if permRss |> Array.exists (fun prs -> prs.Perm_Si.Permutation.Array.Length <> width) then
            Error $"All Perm_Rs must have order equal to width {width}"
        else
            Ok { Id = id
                 Width = width
                 Perm_Rss = permRss }

module MsrsDTO =

    type MsrsDTOError =
        | NullPermRssArray of string
        | EmptyPermRssArray of string
        | InvalidWidth of string
        | MismatchedPermRsOrder of string
        | PermRsConversionError of Perm_RsDTO.Perm_RsDTOError

    let toMsrsDTO (msrs: Msrs) : MsrsDTO =
        { Id = %msrs.Id
          Width = %msrs.SortingWidth
          Perm_Rss = msrs.Perm_Rss |> Array.map Perm_RsDTO.toPerm_RsDTO }

    let toMsrs (dto: MsrsDTO) : Result<Msrs, MsrsDTOError> =
        let permRssResult = 
            dto.Perm_Rss 
            |> Array.map Perm_RsDTO.toPerm_Rs
            |> Array.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok permRs -> Ok (Array.append arr [|permRs|])
                | Ok _, Error e -> Error (PermRsConversionError e)
                | Error e, _ -> Error e
            ) (Ok [||])
        
        match permRssResult with
        | Error e -> Error e
        | Ok permRss ->
            try
                let msrs = Msrs.create
                                (UMX.tag<sorterModelID> dto.Id)
                                (UMX.tag<sortingWidth> dto.Width)
                                permRss
                Ok msrs
            with
            | :? ArgumentException as ex when ex.Message.Contains("Perm_Rs") && ex.Message.Contains("at least 1") ->
                Error (EmptyPermRssArray ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("Width") ->
                Error (InvalidWidth ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("order") ->
                Error (MismatchedPermRsOrder ex.Message)
            | ex ->
                Error (InvalidWidth ex.Message) // Fallback for unexpected errors
namespace GeneSort.Model.Mp.Sorter.Si

open System
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Si
open MessagePack

[<MessagePackObject; Struct>]
type MssiDTO =
    { [<Key(0)>] Id: Guid
      [<Key(1)>] Width: int
      [<Key(2)>] Perm_Sis: Perm_Si array }
    
    static member Create(id: Guid, width: int, perm_Sis: Perm_Si array) : Result<MssiDTO, string> =
        if isNull perm_Sis || perm_Sis.Length < 1 then
            Error "Must have at least 1 Perm_Si"
        else if width < 1 then
            Error "Width must be at least 1"
        else
            Ok { Id = id; Width = width; Perm_Sis = perm_Sis }
    
    member this.StageCount = this.Perm_Sis.Length

module MssiDTO =
    type MssiDTOError =
        | InvalidPermSiCount of string
        | InvalidWidth of string

    let toMssiDTO (mssi: Mssi) : MssiDTO =
        { Id = %mssi.Id
          Width = %mssi.SortingWidth
          Perm_Sis = mssi.Perm_Sis }

    let toMssi (mssiDTO: MssiDTO) : Result<Mssi, MssiDTOError> =
        try
            let mssi = GeneSort.Model.Sorter.Si.Mssi.create
                            (UMX.tag<sorterModelID> mssiDTO.Id)
                            (UMX.tag<sortingWidth> mssiDTO.Width)
                            mssiDTO.Perm_Sis
            Ok mssi
        with
        | :? ArgumentException as ex when ex.Message.Contains("Perm_Si") ->
            Error (InvalidPermSiCount ex.Message)
        | :? ArgumentException as ex when ex.Message.Contains("Width") ->
            Error (InvalidWidth ex.Message)
        | ex ->
            Error (InvalidPermSiCount ex.Message) // Fallback for unexpected errors

namespace GeneSort.Model.Mp.Sorter.Uf4

open System
open FSharp.UMX
open MessagePack
open GeneSort.Sorter
open GeneSort.Core.Mp.TwoOrbitUnfolder
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter

[<MessagePackObject>]
type Msuf4DTO =
    { [<Key(0)>] Id: Guid
      [<Key(1)>] SortingWidth: int
      [<Key(2)>] TwoOrbitUnfolder4s: TwoOrbitUf4DTO array }
    
    static member Create(id: Guid, sortingWidth: int, twoOrbitUnfolder4s: TwoOrbitUf4DTO array) : Result<Msuf4DTO, string> =
        if isNull twoOrbitUnfolder4s then
            Error "TwoOrbitUnfolder4s array cannot be null"
        else if twoOrbitUnfolder4s.Length < 1 then
            Error $"Must have at least 1 TwoOrbitUnfolder4, got {twoOrbitUnfolder4s.Length}"
        else if sortingWidth < 1 then
            Error $"SortingWidth must be at least 1, got {sortingWidth}"
        else
            try
                if twoOrbitUnfolder4s |> Array.exists (fun tou -> (tou |> TwoOrbitUf4DTO.getOrder) <> sortingWidth) then
                    Error $"All TwoOrbitUnfolder4 must have order {sortingWidth}"
                else
                    Ok { Id = id
                         SortingWidth = sortingWidth
                         TwoOrbitUnfolder4s = twoOrbitUnfolder4s }
            with
            | :? ArgumentException as ex ->
                Error ex.Message

module Msuf4DTO =
    type Msuf4DTOError =
        | NullTwoOrbitUnfolder4sArray of string
        | EmptyTwoOrbitUnfolder4sArray of string
        | InvalidSortingWidth of string
        | MismatchedTwoOrbitUnfolder4Order of string
        | TwoOrbitUnfolder4ConversionError of TwoOrbitUf4DTO.TwoOrbitUf4DTOError

    let toMsuf4DTO (msuf4: Msuf4) : Msuf4DTO =
        { Id = %msuf4.Id
          SortingWidth = %msuf4.SortingWidth
          TwoOrbitUnfolder4s = msuf4.TwoOrbitUnfolder4s |> Array.map TwoOrbitUf4DTO.toTwoOrbitUnfolder4DTO }

    let toMsuf4 (dto: Msuf4DTO)   = // : Result<Msuf4, Msuf4DTOError> =
        let twoOrbitUnfolder4sResult = 
            dto.TwoOrbitUnfolder4s 
            |> Array.map TwoOrbitUf4DTO.toTwoOrbitUnfolder4
            |> Array.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok tou -> Ok (Array.append arr [|tou|])
                | Ok _, Error e -> Error (TwoOrbitUnfolder4ConversionError e)
                | Error e, _ -> Error e
            ) (Ok [||])
        match twoOrbitUnfolder4sResult with
        | Error e -> Error e
        | Ok twoOrbitUnfolder4s ->
            try
                let msuf4 = 
                    Msuf4.create
                        (UMX.tag<sorterModelID> dto.Id)
                        (UMX.tag<sortingWidth> dto.SortingWidth)
                        twoOrbitUnfolder4s
                Ok msuf4
            with
            | :? ArgumentException as ex when ex.Message.Contains("TwoOrbitUnfolder4") && ex.Message.Contains("at least 1") ->
                Error (EmptyTwoOrbitUnfolder4sArray ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("SortingWidth") ->
                Error (InvalidSortingWidth ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("order") ->
                Error (MismatchedTwoOrbitUnfolder4Order ex.Message)
            | ex ->
                Error (InvalidSortingWidth ex.Message)

namespace GeneSort.Model.Mp.Sorter.Uf6

open System
open FSharp.UMX
open MessagePack
open GeneSort.Sorter
open GeneSort.Core.Mp.TwoOrbitUnfolder
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sorter

[<MessagePackObject>]
type Msuf6DTO =
    { [<Key(0)>] Id: Guid
      [<Key(1)>] SortingWidth: int
      [<Key(2)>] TwoOrbitUnfolder6s: TwoOrbitUf6DTO array }
    
    static member Create(id: Guid, sortingWidth: int, twoOrbitUnfolder6s: TwoOrbitUf6DTO array) : Result<Msuf6DTO, string> =
        if isNull twoOrbitUnfolder6s then
            Error "TwoOrbitUnfolder6s array cannot be null"
        else if twoOrbitUnfolder6s.Length < 1 then
            Error $"Must have at least 1 TwoOrbitUnfolder6, got {twoOrbitUnfolder6s.Length}"
        else if sortingWidth < 1 then
            Error $"SortingWidth must be at least 1, got {sortingWidth}"
        else
            try
                if twoOrbitUnfolder6s |> Array.exists (fun tou -> (tou |> TwoOrbitUf6DTO.getOrder) <> sortingWidth) then
                    Error $"All TwoOrbitUnfolder6 must have order {sortingWidth}"
                else
                    Ok { Id = id
                         SortingWidth = sortingWidth
                         TwoOrbitUnfolder6s = twoOrbitUnfolder6s }
            with
            | :? ArgumentException as ex ->
                Error ex.Message

module Msuf6DTO =
    type Msuf6DTOError =
        | NullTwoOrbitUnfolder6sArray of string
        | EmptyTwoOrbitUnfolder6sArray of string
        | InvalidSortingWidth of string
        | MismatchedTwoOrbitUnfolder6Order of string
        | TwoOrbitUnfolder6ConversionError of TwoOrbitUf6DTO.TwoOrbitUf6DTOError

    let toMsuf6DTO (msuf6: Msuf6) : Msuf6DTO =
        { Id = %msuf6.Id
          SortingWidth = %msuf6.SortingWidth
          TwoOrbitUnfolder6s = msuf6.TwoOrbitUnfolder6s |> Array.map TwoOrbitUf6DTO.toTwoOrbitUf6DTO }

    let toMsuf6 (dto: Msuf6DTO) : Result<Msuf6, Msuf6DTOError> =
        let twoOrbitUnfolder6sResult = 
            dto.TwoOrbitUnfolder6s 
            |> Array.map TwoOrbitUf6DTO.toTwoOrbitUf6
            |> Array.fold (fun acc res ->
                match acc, res with
                | Ok arr, Ok tou -> Ok (Array.append arr [|tou|])
                | Ok _, Error e -> Error (TwoOrbitUnfolder6ConversionError e)
                | Error e, _ -> Error e
            ) (Ok [||])
        match twoOrbitUnfolder6sResult with
        | Error e -> Error e
        | Ok twoOrbitUnfolder6s ->
            try
                let msuf6 = 
                    Msuf6.create
                        (UMX.tag<sorterModelID> dto.Id)
                        (UMX.tag<sortingWidth> dto.SortingWidth)
                        twoOrbitUnfolder6s
                Ok msuf6
            with
            | :? ArgumentException as ex when ex.Message.Contains("TwoOrbitUnfolder6") && ex.Message.Contains("at least 1") ->
                Error (EmptyTwoOrbitUnfolder6sArray ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("SortingWidth") ->
                Error (InvalidSortingWidth ex.Message)
            | :? ArgumentException as ex when ex.Message.Contains("order") ->
                Error (MismatchedTwoOrbitUnfolder6Order ex.Message)
            | ex ->
                Error (InvalidSortingWidth ex.Message)
// For more information see https://aka.ms/fsharp-console-apps
printfn "Hello from F#"
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Microsoft.Testing.Platform.MSBuild
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.TestingPlatform.Extensions

open System.Runtime.CompilerServices

[<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage>]
[<Extension>]
type SelfRegisteredExtensions() =

    [<Extension>]
    static member AddSelfRegisteredExtensions (builder: Microsoft.Testing.Platform.Builder.ITestApplicationBuilder, args: string[]) =
        Microsoft.Testing.Platform.MSBuild.TestingPlatformBuilderHook.AddExtensions(builder, args)
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Model.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd0ecb4b7b45c20f3de2591024c41fde4f7aea3a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Model.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Model.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+268011982c474b6f88ee9fa28fe8f7f66d9d60cf")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
namespace GeneSort.Model.Test.Sorter.Ce

open System
open Xunit
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter

type MsceRandGenTests() =

    // Helper to create a Model_Ce
    let createModelCe (id: Guid<sorterModelID>) (width: int<sortingWidth>) (ceCodes: int array) : Msce =
        Msce.create id width ceCodes

    // Helper function to create a mock random number generator
    let createMockRando (indices: int list) (floats: float list) =
        fun _ _ -> new MockRando(floats, indices) :> IRando
namespace GeneSort.Model.Test.Sorter.Ce

open System
open Xunit
open FSharp.UMX
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter.Ce
open FsUnit.Xunit
open GeneSort.Model.Sorter


type MsceRandMutateTests() =
    let epsilon = 1e-10 // Tolerance for floating-point comparisons

    // Helper function to create a mock random number generator
    let createMockRando (indices: int list) (floats: float list) =
        fun _ _ -> new MockRando(floats, indices) :> IRando

    let mockRngFactory floatValue indexValue _ _ = MockRando(floatValue, indexValue) :> IRando
    let mockCeCode = 42 // Placeholder valid ceCode
    let newCeCode = 19 // Placeholder for mutated/inserted ceCode
    let sortingWidth = 10 |> UMX.tag<sortingWidth>
    let baseRates = IndelRates.create (0.2, 0.2, 0.2)
    let msceId = Guid.NewGuid() |> UMX.tag<sorterModelID>

    [<Fact>]
    let ``mutate applies Mutation mode correctly`` () =
        let arrayRates = IndelRatesArray.create [| IndelRates.create (1.0, 0.0, 0.0) |] // Always Mutation
        let msce = Msce.create msceId sortingWidth [| mockCeCode |]
        let msceMutate = MsceRandMutate.create (rngType.Lcg) arrayRates false msce :> ISorterModelMaker
        
        let mockRando = createMockRando [newCeCode] [0.9]
        let result = (msceMutate.MakeSorterModel mockRando 0) :?> Msce
        result.CeCodes |> should equal [| newCeCode |]
        result.SortingWidth |> should equal sortingWidth
        result.CeCount |> should equal (1 |> UMX.tag<ceCount>)

    [<Fact>]
    let ``mutate applies Insertion mode and trims to ceCount`` () =
        let arrayRates = IndelRatesArray.create [| IndelRates.create (0.0, 1.0, 0.0); IndelRates.create (0.0, 1.0, 0.0) |] // Insertion; Insertion
        let msce = Msce.create msceId sortingWidth [| mockCeCode; mockCeCode |]
        let msceMutate = MsceRandMutate.create (rngType.Lcg) arrayRates false msce :> ISorterModelMaker
        
        let mockRando = createMockRando [newCeCode; newCeCode] [0.9; 0.9]
        let result = (msceMutate.MakeSorterModel mockRando 0) :?> Msce
        result.CeCodes |> should equal [| newCeCode; mockCeCode; |] // Two insertions, trimmed to ceCount
        result.CeCount |> should equal (2 |> UMX.tag<ceCount>)
        result.SortingWidth |> should equal sortingWidth

    [<Fact>]
    let ``mutate applies Deletion mode and appends insertion`` () =
        let arrayRates = IndelRatesArray.create [| IndelRates.create (0.0, 0.0, 1.0); IndelRates.create (0.0, 1.0, 0.0) |] // Deletion; Insertion
        let msce = Msce.create msceId sortingWidth [| mockCeCode; mockCeCode |]
        let msceMutate = MsceRandMutate.create (rngType.Lcg) arrayRates false msce :> ISorterModelMaker
        
        let mockRando = createMockRando [newCeCode] [0.9; 0.9]
        let result = (msceMutate.MakeSorterModel mockRando 0) :?> Msce
        result.CeCodes |> should equal [| newCeCode; mockCeCode |] // Deletion + Insertion
        result.CeCount |> should equal (2 |> UMX.tag<ceCount>)
        result.SortingWidth |> should equal sortingWidth

    [<Fact>]
    let ``mutate applies NoAction mode correctly`` () =
        let arrayRates = IndelRatesArray.create [| IndelRates.create (0.0, 0.0, 0.0) |] // Always NoAction
        let msce = Msce.create msceId sortingWidth [| mockCeCode |]
        let msceMutate = MsceRandMutate.create (rngType.Lcg) arrayRates false msce :> ISorterModelMaker
        
        let mockRando = createMockRando [0] [0.9]
        let result = (msceMutate.MakeSorterModel mockRando 0) :?> Msce
        result.CeCodes |> should equal [| mockCeCode |] // Unchanged
        result.CeCount |> should equal (1 |> UMX.tag<ceCount>)
        result.SortingWidth |> should equal sortingWidth



namespace GeneSort.Model.Test.Sorter.Rs

open System
open Xunit
open FSharp.UMX
open FsUnit.Xunit
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter

type MsrsRandGenTests() =
    // Helper function to create a mock random number generator
    let createMockRando (indices: int list) (floats: float list) =
        fun _ _ -> new MockRando(floats, indices) :> IRando

    // Helper function to create an MsrsRandGen instance
    let createModelRsGen rngType (width:int) stageCount orthoRate paraRate selfSymRate =
        let rates = OpsGenRates.create (orthoRate, paraRate, selfSymRate)
        let ratesArray = OpsGenRatesArray.create (Array.create stageCount rates)
        MsrsRandGen.create rngType (UMX.tag<sortingWidth> width)  ratesArray

    [<Fact>]
    let ``MakeSorterModel creates correct number of stages`` () =
        let model = createModelRsGen rngType.Lcg 4 3 (1.0/3.0) (1.0/3.0) (1.0/3.0)
        let randoGen = createMockRando [0; 1; 0; 1; 0; 1] [0.2; 0.4; 0.6]
        let modelRs = (model :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        modelRs.Perm_Rss.Length |> should equal 3

    [<Fact>]
    let ``MakeSorterModel creates permutations with correct width`` () =
        let model = createModelRsGen rngType.Lcg 4 2 (1.0/3.0) (1.0/3.0) (1.0/3.0)
        let randoGen = createMockRando [0; 1; 0; 1] [0.2; 0.4]
        let modelRs = (model :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        modelRs.Perm_Rss |> Array.iter (fun perm -> perm.Order |> should equal (UMX.tag<sortingWidth> 4))

    [<Fact>]
    let ``MakeSorterModel throws on odd width`` () =
        let model = createModelRsGen rngType.Lcg 3 2 (1.0/3.0) (1.0/3.0) (1.0/3.0)
        let randoGen = createMockRando [0; 1] [0.2; 0.4]
        (fun () -> (model :> ISorterModelMaker).MakeSorterModel randoGen 0 |> ignore)
        |> should throw typeof<System.Exception>

    [<Fact>]
    let ``MakeSorterModel generates self-inverse permutations`` () =
        let model = createModelRsGen rngType.Lcg 4 2 0.0 0.0 1.0
        let randoGen = createMockRando [0; 1; 0; 0; 1] [0.2; 0.4]
        let modelRs = (model :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        modelRs.Perm_Rss
        |> Array.iter (fun perm ->
            Perm_Si.isReflectionSymmetric perm.Perm_Si |> should equal true)

    [<Fact>]
    let ``MakeSorterModel generates unique IDs`` () =
        let model = createModelRsGen rngType.Lcg 4 2 (1.0/3.0) (1.0/3.0) (1.0/3.0)
        let randoGen = createMockRando [0; 1; 0; 1] [0.2; 0.4]
        let modelRs1 = (model :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        let modelRs2 = (model :> ISorterModelMaker).MakeSorterModel randoGen 1 :?> Msrs
        modelRs1.Id |> should not' (equal modelRs2.Id)
namespace GeneSort.Model.Test.Sorter.Rs

open System
open Xunit
open FSharp.UMX
open FsUnit.Xunit
open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter

type MsrsRandMutateTests() =

    // Helper function to create a Perm_Rs from an array
    let createPermRs (arr: int array) : Perm_Rs =
        Perm_Rs.create arr

    // Helper to create a Model_Rs
    let createModelRs (id: Guid<sorterModelID>) (width: int<sortingWidth>) (permRss: Perm_Rs array) : Msrs =
        Msrs.create id width permRss

    // Helper to check if a permutation is self-inverse
    let isSelfInverse (perm: Perm_Rs) : bool =
        let arr = perm.Array
        arr |> Array.indexed |> Array.forall (fun (i, x) -> arr.[x] = i)

    // Helper function to create a mock random number generator
    let createMockRando (indices: int list) (floats: float list) =
        fun _ _ -> new MockRando(floats, indices) :> IRando

    [<Fact>]
    let ``NoAction mode preserves all Perm_Rss`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 3; 2; 1; 0 |]; [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let modelRs = createModelRs id width permRss
        let opsActionRates = OpsActionRates.create (0.0, 0.0, 0.0) // NoActionRate = 1.0
        let ratesArray = OpsActionRatesArray.create [| opsActionRates; opsActionRates |]
        let modelRsMutate = MsrsRandMutate.create rngType.Lcg modelRs ratesArray

        let randoGen = createMockRando [ 0; 1; 0; 1 ] [ 0.1; 0.1 ] // Should pick NoAction
        let result = (modelRsMutate :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        Assert.Equal(width, result.SortingWidth)
        Assert.Equal(2<stageCount>, result.StageCount)
        Assert.Equal<Perm_Rs array>(permRss, result.Perm_Rss)

    [<Fact>]
    let ``SelfSym mode mutates Perm_Rss correctly`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 1; 0; 3; 2 |]; [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let expectedPermRss = [| [| 3; 2; 1; 0 |]; [| 3; 2; 1; 0 |] |] |> Array.map createPermRs
        let modelRs = createModelRs id width permRss
        let opsActionRates = OpsActionRates.create (0.0, 0.0, 1.0) // SelfSymRate = 1.0
        let ratesArray = OpsActionRatesArray.create [| opsActionRates; opsActionRates |]
        let modelRsMutate = MsrsRandMutate.create rngType.Lcg modelRs ratesArray

        let randoGen = createMockRando [ 0; 1; 0; 1 ] [ 0.1; 0.1 ] // Should pick SelfSym
        let result = (modelRsMutate :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        Assert.Equal(width, result.SortingWidth)
        Assert.Equal(2<stageCount>, result.StageCount)
        Assert.Equal<Perm_Rs array>(expectedPermRss, result.Perm_Rss)
        Assert.True(result.Perm_Rss |> Array.forall isSelfInverse)

    [<Fact>]
    let ``Ortho mode mutates Perm_Rss correctly`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 1; 0; 3; 2 |]; [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let expectedPermRss = [| [| 1; 0; 3; 2 |]; [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let modelRs = createModelRs id width permRss
        let opsActionRates = OpsActionRates.create (1.0, 0.0, 0.0) // OrthoRate = 1.0
        let ratesArray = OpsActionRatesArray.create [| opsActionRates; opsActionRates |]
        let modelRsMutate = MsrsRandMutate.create rngType.Lcg modelRs ratesArray

        let randoGen = createMockRando [ 0; 1; 0; 1 ] [ 0.1; 0.1 ] // Should pick Ortho
        let result = (modelRsMutate :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        Assert.Equal(width, result.SortingWidth)
        Assert.Equal(2<stageCount>, result.StageCount)
        Assert.Equal<Perm_Rs array>(expectedPermRss, result.Perm_Rss)
        Assert.True(result.Perm_Rss |> Array.forall isSelfInverse)

    [<Fact>]
    let ``Para mode mutates Perm_Rss correctly`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 1; 0; 3; 2 |]; [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let expectedPermRss = [| [| 2; 3; 0; 1 |]; [| 2; 3; 0; 1 |] |] |> Array.map createPermRs
        let modelRs = createModelRs id width permRss
        let opsActionRates = OpsActionRates.create (0.0, 1.0, 0.0) // ParaRate = 1.0
        let ratesArray = OpsActionRatesArray.create [| opsActionRates; opsActionRates |]
        let modelRsMutate = MsrsRandMutate.create rngType.Lcg modelRs ratesArray

        let randoGen = createMockRando [ 0; 1; 0; 1 ] [ 0.1; 0.1 ] // Should pick Para
        let result = (modelRsMutate :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        Assert.Equal(width, result.SortingWidth)
        Assert.Equal(2<stageCount>, result.StageCount)
        Assert.Equal<Perm_Rs array>(expectedPermRss, result.Perm_Rss)
        Assert.True(result.Perm_Rss |> Array.forall isSelfInverse)

    [<Fact>]
    let ``Mixed mutation modes with varying probabilities`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 1; 0; 3; 2 |]; [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let modelRs = createModelRs id width permRss
        let opsActionRates1 = OpsActionRates.create (0.0, 0.0, 1.0) // SelfSymRate = 1.0
        let opsActionRates2 = OpsActionRates.create (0.0, 1.0, 0.0) // ParaRate = 1.0
        let ratesArray = OpsActionRatesArray.create [| opsActionRates1; opsActionRates2 |]
        let modelRsMutate = MsrsRandMutate.create rngType.Lcg modelRs ratesArray

        let randoGen = createMockRando [ 0; 1; 0; 1 ] [ 0.1; 0.1 ] // Picks SelfSym for first, Para for second
        let result = (modelRsMutate :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        let expectedPermRss = [| [| 3; 2; 1; 0 |]; [| 2; 3; 0; 1 |] |] |> Array.map createPermRs
        Assert.Equal(width, result.SortingWidth)
        Assert.Equal(2<stageCount>, result.StageCount)
        Assert.Equal<Perm_Rs array>(expectedPermRss, result.Perm_Rss)
        Assert.True(result.Perm_Rss |> Array.forall isSelfInverse)

    [<Fact>]
    let ``Throws on mismatched stage count`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 1; 0; 3; 2 |] |] |> Array.map createPermRs // StageCount = 1
        let modelRs = createModelRs id width permRss
        let opsActionRates = OpsActionRates.create (0.0, 0.0, 0.0)
        let ratesArray = OpsActionRatesArray.create [| opsActionRates; opsActionRates |] // Length = 2
        Assert.ThrowsAny<exn>(fun () ->
            MsrsRandMutate.create rngType.Lcg modelRs ratesArray|> ignore
        )

    [<Fact>]
    let ``Generates new unique ID`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let permRss = [| [| 1; 0; 3; 2 |] |] |> Array.map createPermRs
        let modelRs = createModelRs id width permRss
        let opsActionRates = OpsActionRates.create (0.0, 0.0, 0.0) // NoActionRate = 1.0
        let ratesArray = OpsActionRatesArray.create [| opsActionRates |]
        let modelRsMutate = MsrsRandMutate.create rngType.Lcg modelRs ratesArray

        let randoGen = createMockRando [ 0; 1 ] [ 0.9 ]
        let result = (modelRsMutate :> ISorterModelMaker).MakeSorterModel randoGen 0 :?> Msrs
        Assert.NotEqual(%id, %result.Id)
        Assert.NotEqual(Guid.Empty, %result.Id)
namespace GeneSort.Model.Test.Sorter.Si


open System
open Xunit
open FSharp.UMX
open FsUnit.Xunit
open GeneSort.Sorter
open GeneSort.Core
open GeneSort.Core.Perm_Si
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Si

type MssiRandMutateTests() =

    // Helper to create a Model_Si
    let createModelSi (id: Guid<sorterModelID>) (width: int<sortingWidth>) (permSis: Perm_Si array) : Mssi =
        Mssi.create id width permSis

    let randoGen 
            (nextIndexValues: int list) 
            (pickValues: float list) 
            (rt: rngType) 
            (id: Guid) : IRando =
        MockRando(pickValues, nextIndexValues) :> IRando

    [<Fact>]
    let ``mutate with NoAction mode does not change permutations`` () =
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi = Perm_Si.create [|1; 0; 2; 3|] // (0 1)
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi|]
        let siMutationRates = OpActionRates.create (0.0, 0.0)
        let arrayToMutate = OpActionRatesArray.create [|siMutationRates|]
        let modelSiMutate = MssiRandMutate.create rngType.Lcg modelSi arrayToMutate

        let mock = randoGen [0; 1] [0.5] // Ensures NoAction (within NoActionRate)
        let result = (modelSiMutate :> ISorterModelMaker).MakeSorterModel mock 0 :?> Mssi
        Assert.Equal<int array>(modelSi.Perm_Sis.[0].Array, result.Perm_Sis.[0].Array)
        Assert.Equal(modelSi.SortingWidth, result.SortingWidth)

    [<Fact>]
    let ``mutate with Ortho mode applies Ortho mutation`` () = 
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi = Perm_Si.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi|]
        let siMutationRates = OpActionRates.create (0.9, 0.0)
        let arrayToMutate = OpActionRatesArray.create [|siMutationRates|]
        let modelSiMutate = MssiRandMutate.create rngType.Lcg modelSi arrayToMutate

        let mock = randoGen [0; 2] [0.0] // Picks indices 0, 2 and Ortho mode
        let result = (modelSiMutate :> ISorterModelMaker).MakeSorterModel mock 0 :?> Mssi
        let expectedArray = [|2; 3; 0; 1|] // Expected: (0 2)(1 3)
        Assert.Equal<int array>(expectedArray, result.Perm_Sis.[0].Array)
        Assert.True(Permutation.isSelfInverse result.Perm_Sis.[0].Permutation)
        Assert.Equal(modelSi.SortingWidth, result.SortingWidth)

    [<Fact>]
    let ``mutate with Para mode applies Para mutation`` () =
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi = Perm_Si.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi|]
        let siMutationRates = OpActionRates.create (0.0, 1.0)
        let arrayToMutate = OpActionRatesArray.create [|siMutationRates|]
        let modelSiMutate = MssiRandMutate.create rngType.Lcg modelSi arrayToMutate

        let mock = randoGen [0; 2] [0.5] // Picks indices 0, 2 and Para mode
        let result = (modelSiMutate :> ISorterModelMaker).MakeSorterModel mock 0 :?> Mssi
        let expectedArray = [|3; 2; 1; 0|] // Expected: (0 3)(1 2)
        Assert.Equal<int array>(expectedArray, result.Perm_Sis.[0].Array)
        Assert.True(Permutation.isSelfInverse result.Perm_Sis.[0].Permutation)
        Assert.Equal(modelSi.SortingWidth, result.SortingWidth)

    [<Fact>]
    let ``mutate preserves width and number of permutations`` () =
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi1 = Perm_Si.create [|1; 0; 3; 2|]
        let permSi2 = Perm_Si.create [|3; 2; 1; 0|]
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi1; permSi2|]
        let siMutationRates = OpActionRates.create (0.5, 0.5)
        let arrayToMutate = OpActionRatesArray.create [|siMutationRates; siMutationRates|]
        let modelSiMutate = MssiRandMutate.create rngType.Lcg modelSi arrayToMutate

        let mock = randoGen [0; 2; 0; 2] [0.0; 0.0] // Ortho mode
        let result = (modelSiMutate :> ISorterModelMaker).MakeSorterModel mock 0 :?> Mssi
        Assert.Equal(UMX.tag<sortingWidth> 4, result.SortingWidth)
        Assert.Equal(2, result.Perm_Sis.Length)

    [<Fact>]
    let ``mutate generates new unique ID`` () =
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi = Perm_Si.create [|1; 0; 2; 3|]
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi|]
        let siMutationRates = OpActionRates.create (0.0, 0.0)
        let arrayToMutate = OpActionRatesArray.create [|siMutationRates|]
        let modelSiMutate = MssiRandMutate.create rngType.Lcg modelSi arrayToMutate

        let mock = randoGen [0; 1] [0.5]
        let result = (modelSiMutate :> ISorterModelMaker).MakeSorterModel mock 0 :?> Mssi
        Assert.NotEqual(%id, %result.Id)
        Assert.NotEqual(Guid.Empty, %result.Id)

    [<Fact>]
    let ``mutate applies mutation to all permutations in array`` () =
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi1 = Perm_Si.create [|1; 0; 3; 2|] // (0 1)(2 3)
        let permSi2 = Perm_Si.create [|3; 2; 1; 0|] // (0 3)(1 2)
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi1; permSi2|]
        let siMutationRates = OpActionRates.create (1.0, 0.0)
        let arrayToMutate = OpActionRatesArray.create [|siMutationRates; siMutationRates|]
        let modelSiMutate = MssiRandMutate.create rngType.Lcg modelSi arrayToMutate

        let mock = randoGen [0; 2; 0; 2] [0.0; 0.0] // Ortho mode, indices 0, 2
        let result = (modelSiMutate :> ISorterModelMaker).MakeSorterModel mock 0 :?> Mssi
        let expectedArray1 = [|2; 3; 0; 1|] // (0 2)(1 3)
        let expectedArray2 = [|1; 0; 3; 2|] // (0 1)(2 3)
        Assert.Equal<int array>(expectedArray1, result.Perm_Sis.[0].Array)
        Assert.Equal<int array>(expectedArray2, result.Perm_Sis.[1].Array)
        Assert.True(Permutation.isSelfInverse result.Perm_Sis.[0].Permutation)
        Assert.True(Permutation.isSelfInverse result.Perm_Sis.[1].Permutation)

    [<Fact>]
    let ``create fails when Perm_Sis length does not match arrayRates length`` () =
        let id = UMX.tag<sorterModelID> (Guid.NewGuid())
        let permSi = Perm_Si.create [|1; 0; 2; 3|]
        let modelSi = createModelSi id (UMX.tag<sortingWidth> 4) [|permSi|]
        let siMutationRates = OpActionRates.create (0.0, 0.0)
        let array = OpActionRatesArray.create [|siMutationRates; siMutationRates|] // Length 2
        Assert.Throws<exn>(fun () -> MssiRandMutate.create rngType.Lcg modelSi array |> ignore)
namespace GeneSort.Model.Test.Sorter.Uf


open System
open FSharp.UMX
open Xunit
open EvoMergeSort.Core
open EvoMergeSort.Core.Uf4Seeds
open EvoMergeSort.Sorter
open GeneSort.Model.Sorter.Uf4
open MathUtils

type Msuf4RandGenTests() =

    // Helper function to create a mock random number generator
    let createMockRando (indices: int list) (floats: float list) =
        fun _ _ -> new MockRando(floats, indices) :> IRando

    // Helper function to create uniform TwoOrbitUnfolder4GenRates
    let createTestGenRates (order: int) =
        Uf4GenRates.makeUniform order

    // Helper function to create non-uniform TwoOrbitUnfolder4GenRates
    let createBiasedGenRates (order: int) (twoOrbitType:TwoOrbitType) (baseAmt:float) (biasAmt:float) =
        Uf4GenRates.biasTowards order twoOrbitType baseAmt biasAmt

    // Helper function to create a valid Msuf4RandGen
    let createTestMsuf4RandGen (rngType: rngType) (sortingWidth: int<sortingWidth>) (stageCount: int<stageCount>) =
        let genRates = Array.init (%stageCount) (fun _ -> createTestGenRates (%sortingWidth))
        Msuf4RandGenOld.create rngType sortingWidth stageCount genRates

    [<Fact>]
    let ``create succeeds with valid input`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 2<stageCount>
        let genRates = [| createTestGenRates 4; createTestGenRates 4 |]
        let msuf4Gen = Msuf4RandGenOld.create rngType width stageCount genRates
        Assert.Equal(rngType, msuf4Gen.RngType)
        Assert.Equal(width, msuf4Gen.SortingWidth)
        Assert.Equal(stageCount, msuf4Gen.StageCount)
        Assert.Equal<Uf4GenRates array>(genRates, msuf4Gen.GenRates)

    [<Fact>]
    let ``create fails with stageCount less than 1`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 0<stageCount>
        let genRates = [||]
        let ex = Assert.Throws<Exception>(fun () -> Msuf4RandGenOld.create rngType width stageCount genRates |> ignore)
        Assert.Equal("StageCount must be at least 1, got 0", ex.Message)

    [<Fact>]
    let ``create fails with mismatched genRates length`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 2<stageCount>
        let genRates = [| createTestGenRates 4 |] // Length 1, should be 2
        let ex = Assert.Throws<Exception>(fun () -> Msuf4RandGenOld.create rngType width stageCount genRates |> ignore)
        Assert.Equal("genRates array length (1) must equal stageCount (2)", ex.Message)

    [<Fact>]
    let ``create fails with genRates order mismatch`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 1<stageCount>
        let genRates = [| createTestGenRates 8 |] // Order 8, should be 4
        let ex = Assert.Throws<Exception>(fun () -> Msuf4RandGenOld.create rngType width stageCount genRates |> ignore)
        Assert.Equal("All genRates must have order 4", ex.Message)

    [<Fact>]
    let ``create fails with invalid seedGenRates sum`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 1<stageCount>
        let invalidGenRates = 
            { Uf4GenRates.order = 4
              seedGenRatesUf4 = { Ortho = 0.5; Para = 0.5; SelfRefl = 0.5 } // Sum = 1.5
              opsGenRatesList = [ TwoOrbitPairGenRates.makeUniform() ] }
        let genRates = [| invalidGenRates |]
        let ex = Assert.Throws<Exception>(fun () -> Msuf4RandGenOld.create rngType width stageCount genRates |> ignore)
        Assert.Equal("Sum of seedGenRates must not exceed 1.0", ex.Message)

    [<Fact>]
    let ``equality based on all fields`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 2<stageCount>
        let genRates = [| createTestGenRates 4; createTestGenRates 4 |]
        let msuf4Gen1 = Msuf4RandGenOld.create rngType width stageCount genRates
        let msuf4Gen2 = Msuf4RandGenOld.create rngType width stageCount genRates
        Assert.Equal(msuf4Gen1, msuf4Gen2)
        Assert.Equal(msuf4Gen1.GetHashCode(), msuf4Gen2.GetHashCode())

    [<Fact>]
    let ``inequality with different fields`` () =
        let rngType1 = rngType.Lcg
        let rngType2 = rngType.Net
        let width = 8<sortingWidth>
        let stageCount = 1<stageCount>
        let genRates1 = [| createTestGenRates 8 |]
        let genRates2 = [| Uf4GenRates.biasTowards 8 TwoOrbitType.Para (1.0/ 3.0)  0.1 |]
        let msuf4Gen1 = Msuf4RandGenOld.create rngType1 width stageCount genRates1
        let msuf4Gen2 = Msuf4RandGenOld.create rngType2 width stageCount genRates1
        let msuf4Gen3 = Msuf4RandGenOld.create rngType1 width stageCount genRates2
        Assert.NotEqual(msuf4Gen1, msuf4Gen2)
        Assert.NotEqual(msuf4Gen1, msuf4Gen3)
        Assert.NotEqual(msuf4Gen1.GetHashCode(), msuf4Gen2.GetHashCode())
        Assert.NotEqual(msuf4Gen1.GetHashCode(), msuf4Gen3.GetHashCode())


    [<Fact>]
    let ``makeId generates unique IDs`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 1<stageCount>
        let genRates = [| createTestGenRates 4 |]
        let msuf4Gen = Msuf4RandGenOld.create rngType width stageCount genRates
        let id1 = Msuf4RandGenOld.makeId msuf4Gen 0
        let id2 = Msuf4RandGenOld.makeId msuf4Gen 1
        Assert.NotEqual(id1, id2)

    [<Fact>]
    let ``makeModelUniform produces Msuf4 with correct properties`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 2<stageCount>
        let genRates = [| createTestGenRates 4; createTestGenRates 4 |]
        let msuf4Gen = Msuf4RandGenOld.create rngType width stageCount genRates
        let mockRando = createMockRando [0] [0.5; 0.5]
        let msuf4 = Msuf4RandGenOld.makeModel msuf4Gen mockRando 0
        Assert.Equal(%msuf4.Id |> UMX.tag<sorterId>, Msuf4.makeSorter(msuf4).SorterId)
        Assert.Equal(width, msuf4.SortingWidth)
        Assert.Equal(%stageCount, msuf4.StageCount)
        Assert.Equal(2, msuf4.TwoOrbitUnfolder4s.Length)
        let rSorter = Msuf4.makeSorter(msuf4)
        // With NextFloat = 0.5 and uniform rates (1/3 each), SeedType.Para is selected ([1/3, 2/3))
        let expectedCes = [| Ce.create 0 2; Ce.create 1 3; Ce.create 0 2; Ce.create 1 3 |]
        Assert.Equal<Ce>(expectedCes, rSorter.Ces)

    [<Fact>]
    let ``makeModelBiased produces Msuf4 with biased last stage`` () =
        let rngType = rngType.Lcg
        let width = 4<sortingWidth>
        let stageCount = 2<stageCount>
        let baseAmt = 1.0 / 3.0
        let biasAmt = 0.1
        let genRates = [| createBiasedGenRates 4 TwoOrbitType.Ortho baseAmt biasAmt; createBiasedGenRates 4 TwoOrbitType.Ortho baseAmt biasAmt;|]
        let msuf4Gen = Msuf4RandGenOld.create rngType width stageCount genRates

        let mockRando = createMockRando [0] [0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5]
        let msuf4 = Msuf4RandGenOld.makeModel msuf4Gen mockRando 0
        Assert.Equal(%msuf4.Id |> UMX.tag<sorterId>, Msuf4.makeSorter(msuf4).SorterId)
        Assert.Equal(width, msuf4.SortingWidth)
        Assert.Equal(%stageCount, msuf4.StageCount)
        Assert.Equal(2, msuf4.TwoOrbitUnfolder4s.Length)
        // First stage: uniform rates, NextFloat = 0.5 -> SeedType.Para ([0;1], [2;3])
        // Last stage: uniform rates, NextFloat = 0.5 -> SeedType.Para ([0;1], [2;3])
        let rSorter = Msuf4.makeSorter(msuf4)
        let expectedCes = [| Ce.create 0 2; Ce.create 1 3; Ce.create 0 2; Ce.create 1 3 |]
        Assert.Equal<Ce>(expectedCes, rSorter.Ces)

    [<Fact>]
    let ``makeModelBiased produces Msuf4 with biased last stage for order 8`` () =
        let rngType = rngType.Lcg
        let width = 8<sortingWidth>
        let stageCount = 1<stageCount>
        let baseAmt = 1.0 / 3.0
        let biasAmt = 0.1
        let genRates = [| createBiasedGenRates 8 TwoOrbitType.Ortho baseAmt biasAmt; |] // createTestGenRates 8; createTestGenRates 8; createTestGenRates 8 |]
        let msuf4Gen = Msuf4RandGenOld.create rngType width stageCount genRates

        let mockRando = createMockRando [0] [0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5] 
        let msuf4 = Msuf4RandGenOld.makeModel msuf4Gen mockRando 0
        let expectedCes = [| Ce.create 0 5; Ce.create 1 4; Ce.create 2 7; Ce.create 3 6 |]
        let rSorter = Msuf4.makeSorter(msuf4)

        Assert.Equal<Ce>(expectedCes, rSorter.Ces)
        Assert.Equal(%msuf4.Id |> UMX.tag<sorterId>, Msuf4.makeSorter(msuf4).SorterId)
        Assert.Equal(width, msuf4.SortingWidth)
        Assert.Equal(%stageCount, msuf4.StageCount)
namespace GeneSort.Model.Test.Sorter.Uf

open System
open FSharp.UMX
open Xunit
open EvoMergeSort.Core
open EvoMergeSort.Sorter
open Uf4Seeds
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter

type Msuf4RandMutateTests() =

    // Helper function to create a mock random number generator
    let createMockRando (indices: int list) (floats: float list) =
        fun _ _ -> new MockRando(floats, indices) :> IRando

    // Helper function to create a valid TwoOrbitUnfolder4
    let createTestTwoOrbitUnfolder4 (order: int) (seedType: SeedTypeUf4) =
        let genRates = Uf4GenRates.makeUniform order
        TwoOrbitUf4Ops.makeTwoOrbitUf4 (fun () -> 0.5) genRates

    // Helper function to create a valid Msuf4
    let createTestMsuf4 (id: Guid<sorterModelID>) (width: int<sortingWidth>) (count: int) (seedType: SeedTypeUf4) =
        let tou = createTestTwoOrbitUnfolder4 (%width) seedType
        let touArray = Array.create count tou
        Msuf4.create id width touArray

    // Helper function to create a valid Msuf4MutationModeProbabilities
    let createTestMutationModeProbabilities (order: int) (otp: float) (ots: float) (pto: float) (pts: float) (sto: float) (stp: float) =
        Msuf4MutationModeProbabilities.create 
            order 
            (otp |> LanguagePrimitives.FloatWithMeasure<uf4OrthoToParaMutationRate>)
            (ots |> LanguagePrimitives.FloatWithMeasure<uf4OrthoToSelfReflMutationRate>)
            (pto |> LanguagePrimitives.FloatWithMeasure<uf4ParaToOrthoMutationRate>)
            (pts |> LanguagePrimitives.FloatWithMeasure<uf4ParaToSelfReflMutationRate>)
            (sto |> LanguagePrimitives.FloatWithMeasure<uf4SelfReflToOrthoMutationRate>)
            (stp |> LanguagePrimitives.FloatWithMeasure<uf4SelfReflToParaMutationRate>)

    // Helper function to create a valid Msuf4RandMutate
    let createTestMsuf4RandMutate (rngType: rngType) (stageCount: int<stageCount>) (order: int) (otp: float) (ots: float) (pto: float) (pts: float) (sto: float) (stp: float) =
        let rates = Array.init (%stageCount) (fun _ -> otp, ots, pto, pts, sto, stp)
        let orthoToParaRates = rates |> Array.map (fun (otp, _, _, _, _, _) -> otp |> LanguagePrimitives.FloatWithMeasure)
        let orthoToSelfReflRates = rates |> Array.map (fun (_, ots, _, _, _, _) -> ots |> LanguagePrimitives.FloatWithMeasure)
        let paraToOrthoRates = rates |> Array.map (fun (_, _, pto, _, _, _) -> pto |> LanguagePrimitives.FloatWithMeasure)
        let paraToSelfReflRates = rates |> Array.map (fun (_, _, _, pts, _, _) -> pts |> LanguagePrimitives.FloatWithMeasure)
        let selfReflToOrthoRates = rates |> Array.map (fun (_, _, _, _, sto, _) -> sto |> LanguagePrimitives.FloatWithMeasure)
        let selfReflToParaRates = rates |> Array.map (fun (_, _, _, _, _, stp) -> stp |> LanguagePrimitives.FloatWithMeasure)
        Msuf4RandMutateOld.create rngType stageCount order orthoToParaRates orthoToSelfReflRates paraToOrthoRates paraToSelfReflRates selfReflToOrthoRates selfReflToParaRates

    [<Fact>]
    let ``create succeeds with valid input`` () =
        let rngType = rngType.Lcg
        let stageCount = 2<stageCount>
        let order = 4
        let otp = 0.2
        let ots = 0.2
        let pto = 0.2
        let pts = 0.2
        let sto = 0.1
        let stp = 0.1
        let probabilities = [| createTestMutationModeProbabilities order otp ots pto pts sto stp; createTestMutationModeProbabilities order otp ots pto pts sto stp |]
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount order otp ots pto pts sto stp
        Assert.Equal(rngType, msuf4Mutate.RngType)
        Assert.Equal(stageCount, msuf4Mutate.StageCount)

    [<Fact>]
    let ``createFromSingleRate succeeds with valid input`` () =
        let rngTyp = rngType.Lcg
        let stageCount = 2<stageCount>
        let order = 4
        let otp = 0.2
        let ots = 0.2
        let pto = 0.2
        let pts = 0.2
        let sto = 0.1
        let stp = 0.1
        let msuf4Mutate = Msuf4RandMutateOld.createFromSingleRate 
                            rngTyp stageCount order 
                            (otp |> LanguagePrimitives.FloatWithMeasure)
                            (ots |> LanguagePrimitives.FloatWithMeasure)
                            (pto |> LanguagePrimitives.FloatWithMeasure)
                            (pts |> LanguagePrimitives.FloatWithMeasure)
                            (sto |> LanguagePrimitives.FloatWithMeasure)
                            (stp |> LanguagePrimitives.FloatWithMeasure)
        Assert.Equal(rngTyp, msuf4Mutate.RngType)
        Assert.Equal(stageCount, msuf4Mutate.StageCount)
        Assert.All(msuf4Mutate.OrthoToParaRates, fun rate -> Assert.Equal(otp, %rate))
        Assert.All(msuf4Mutate.OrthoToSelfReflRates, fun rate -> Assert.Equal(ots, %rate))
        Assert.All(msuf4Mutate.ParaToOrthoRates, fun rate -> Assert.Equal(pto, %rate))
        Assert.All(msuf4Mutate.ParaToSelfReflRates, fun rate -> Assert.Equal(pts, %rate))
        Assert.All(msuf4Mutate.SelfReflToOrthoRates, fun rate -> Assert.Equal(sto, %rate))
        Assert.All(msuf4Mutate.SelfReflToParaRates, fun rate -> Assert.Equal(stp, %rate))


    [<Fact>]
    let ``equality based on all fields`` () =
        let rngType = rngType.Lcg
        let stageCount = 2<stageCount>
        let order = 4
        let otp = 0.2
        let ots = 0.2
        let pto = 0.2
        let pts = 0.2
        let sto = 0.1
        let stp = 0.1
        let msuf4Mutate1 = createTestMsuf4RandMutate rngType stageCount order otp ots pto pts sto stp
        let msuf4Mutate2 = createTestMsuf4RandMutate rngType stageCount order otp ots pto pts sto stp
        Assert.Equal(msuf4Mutate1, msuf4Mutate2)
        Assert.Equal(msuf4Mutate1.GetHashCode(), msuf4Mutate2.GetHashCode())

    [<Fact>]
    let ``inequality with different fields`` () =
        let rngType1 = rngType.Lcg
        let rngType2 = rngType.Net
        let stageCount = 1<stageCount>
        let order = 4
        let otp1 = 0.02
        let ots1 = 0.2
        let pto1 = 0.2
        let pts1 = 0.2
        let sto1 = 0.1
        let stp1 = 0.1
        let otp2 = 0.03
        let ots2 = 0.3
        let pto2 = 0.3
        let pts2 = 0.03
        let sto2 = 0.15
        let stp2 = 0.15
        let msuf4Mutate1 = createTestMsuf4RandMutate rngType1 stageCount order otp1 ots1 pto1 pts1 sto1 stp1
        let msuf4Mutate2 = createTestMsuf4RandMutate rngType2 stageCount order otp1 ots1 pto1 pts1 sto1 stp1
        let msuf4Mutate3 = createTestMsuf4RandMutate rngType1 stageCount order otp2 ots2 pto2 pts2 sto2 stp2
        Assert.NotEqual(msuf4Mutate1, msuf4Mutate2)
        Assert.NotEqual(msuf4Mutate1, msuf4Mutate3)
        Assert.NotEqual(msuf4Mutate1.GetHashCode(), msuf4Mutate2.GetHashCode())
        Assert.NotEqual(msuf4Mutate1.GetHashCode(), msuf4Mutate3.GetHashCode())

    [<Fact>]
    let ``makeId generates unique IDs`` () =
        let rngType = rngType.Lcg
        let stageCount = 1<stageCount>
        let order = 4<sortingWidth>
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount %order 0.2 0.2 0.2 0.2 0.1 0.1
        let msuf4Id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let msuf4 = createTestMsuf4 msuf4Id order 1 SeedTypeUf4.Ortho
        let id1 = Msuf4RandMutateOld.makeId msuf4Mutate msuf4 0
        let id2 = Msuf4RandMutateOld.makeId msuf4Mutate msuf4 1
        Assert.NotEqual(id1, id2)

    [<Fact>]
    let ``mutate produces Msuf4 with correct properties for order 4`` () =
        let rngType = rngType.Lcg
        let stageCount = 2<stageCount>
        let order = 4<sortingWidth>
        let msuf4Id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let msuf4 = createTestMsuf4 msuf4Id order (%stageCount) SeedTypeUf4.Ortho
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount %order 0.1 0.1 0.1 0.1 0.05 0.05 // Sum = 0.5, NoAction = 0.5
        let mockRando = createMockRando [0] [0.6; 0.6; 0.6; 0.6; 0.6; 0.6; 0.6; 0.6] // Selects None (no mutation)
        let mutatedMsuf4 = Msuf4RandMutateOld.mutate mockRando msuf4Mutate msuf4 0
        Assert.Equal(%mutatedMsuf4.Id |> UMX.tag<sorterId>, Msuf4.makeSorter(mutatedMsuf4).SorterId)
        Assert.Equal(order, mutatedMsuf4.SortingWidth)
        Assert.Equal(%stageCount, mutatedMsuf4.StageCount)
        Assert.Equal(2, mutatedMsuf4.TwoOrbitUnfolder4s.Length)
        // SeedType.Ortho ([0;2], [1;3]), picker selects None (0.6 > 0.5) -> no mutation
        let expectedCes = [| Ce.create 0 2; Ce.create 1 3; Ce.create 0 2; Ce.create 1 3 |]
        Assert.Equal<Ce>(expectedCes, Msuf4.makeSorter(mutatedMsuf4).Ces)

    [<Fact>]
    let ``mutate produces Msuf4 with mutated SeedType for order 4`` () =
        let rngType = rngType.Lcg
        let stageCount = 1<stageCount>
        let order = 4<sortingWidth>
        let msuf4Id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let msuf4 = createTestMsuf4 msuf4Id order (%stageCount) SeedTypeUf4.Ortho
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount %order 0.8 0.1 0.0 0.0 0.0 0.0 // Sum = 0.9, NoAction = 0.1
        let mockRando = createMockRando [0] [0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5] // Selects Some (0.5 < 0.9)
        let mutatedMsuf4 = Msuf4RandMutateOld.mutate mockRando msuf4Mutate msuf4 0
        // SeedType.Ortho, mutation rates: OrthoToPara=0.8, OrthoToSelfRefl=0.1, Ortho=0.1
        // NextFloat = 0.5 selects Para ([0.1, 0.9)) -> [0;2], [1;3]
        let expectedCes = [| Ce.create 0 2; Ce.create 1 3 |]
        let rSorter = Msuf4.makeSorter(mutatedMsuf4)
        Assert.Equal<Ce>(expectedCes, rSorter.Ces)
        Assert.Equal(%mutatedMsuf4.Id |> UMX.tag<sorterId>, Msuf4.makeSorter(mutatedMsuf4).SorterId)
        Assert.Equal(order, mutatedMsuf4.SortingWidth)
        Assert.Equal(%stageCount, mutatedMsuf4.StageCount)

    [<Fact>]
    let ``mutate produces Msuf4 with mutated SeedType for order 8`` () =
        let rngType = rngType.Lcg
        let stageCount = 1<stageCount>
        let order = 8<sortingWidth>
        let msuf4Id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let msuf4 = createTestMsuf4 msuf4Id order (%stageCount) SeedTypeUf4.Ortho
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount %order 0.08 0.1 0.0 0.0 0.0 0.0
        let mockRando = createMockRando [0] [0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5] // Selects Some (0.5 < 0.9)
        let mutatedMsuf4 = Msuf4RandMutateOld.mutate mockRando msuf4Mutate msuf4 0
        // SeedType.Ortho, mutation to Para
        let expectedCes = [| Ce.create 0 5; Ce.create 1 4; Ce.create 2 7; Ce.create 3 6 |]
        let rSorter = Msuf4.makeSorter(mutatedMsuf4)
        Assert.Equal<Ce>(expectedCes, rSorter.Ces)
        Assert.Equal(%mutatedMsuf4.Id |> UMX.tag<sorterId>, Msuf4.makeSorter(mutatedMsuf4).SorterId)
        Assert.Equal(order, mutatedMsuf4.SortingWidth)
        Assert.Equal(%stageCount, mutatedMsuf4.StageCount)

    [<Fact>]
    let ``mutate fails with mismatched stageCount`` () =
        let rngType = rngType.Lcg
        let stageCount = 2<stageCount>
        let order = 4<sortingWidth>
        let msuf4Id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let msuf4 = createTestMsuf4 msuf4Id order 1 SeedTypeUf4.Ortho // Count = 1
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount %order 0.2 0.2 0.2 0.2 0.1 0.1
        let mockRando = createMockRando [0] [0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5]
        let ex = Assert.Throws<Exception>(fun () -> Msuf4RandMutateOld.mutate mockRando msuf4Mutate msuf4 0 |> ignore)
        Assert.Equal("Stage count of Msuf4 1 must match Msuf4RandMutate 2", ex.Message)

    [<Fact>]
    let ``mutate fails with mismatched mutationRates order`` () =
        let rngType = rngType.Lcg
        let stageCount = 1<stageCount>
        let order = 4<sortingWidth>
        let msuf4Id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let msuf4 = createTestMsuf4 msuf4Id order (%stageCount) SeedTypeUf4.Ortho
        let msuf4Mutate = createTestMsuf4RandMutate rngType stageCount 8 0.2 0.2 0.2 0.2 0.1 0.1 // Order 8, should be 4
        let mockRando = createMockRando [0] [0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5; 0.5]
        let ex = Assert.Throws<Exception>(fun () -> Msuf4RandMutateOld.mutate mockRando msuf4Mutate msuf4 0 |> ignore)
        Assert.Equal("All mutationRates must have order 4", ex.Message)
namespace GeneSort.Model.Test.Sorter.Uf

open System
open FSharp.UMX
open Xunit
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter
open GeneSort.Core
open GeneSort.Sorter

type Msuf4Tests() =

    // Helper function to convert string to SeedType
    let toTwoOrbitPairType (twoOrbitPairTypeStr: string) : TwoOrbitPairType =
        match twoOrbitPairTypeStr with
        | "Ortho" -> TwoOrbitPairType.Ortho
        | "Para" -> TwoOrbitPairType.Para
        | "SelfRefl" -> TwoOrbitPairType.SelfRefl
        | _ -> failwith $"Invalid TwoOrbitPairType string: {twoOrbitPairTypeStr}"

    // Mock floatPicker for deterministic testing
    let mockFloatPicker () = 0.5

    // Helper function to create a TwoOrbitUf4GenRates for a given order
    let createTestGenRates (order: int) =
        Uf4GenRates.makeUniform order

    // Helper function to create a valid TwoOrbitUnfolder4 for a given order, SeedType, and optional TwoOrbitType override
    let createTestTwoOrbitUnfolder4 
            (order: int) 
            (twoOrbitPairType: TwoOrbitPairType) 
            (twoOrbitPairTypeOverride: TwoOrbitPairType option) 
     : TwoOrbitUf4  =
        let baseGenRates = createTestGenRates order
        let orthoRate = if twoOrbitPairType = TwoOrbitPairType.Ortho then 1.0 else 0.0
        let paraRate = if twoOrbitPairType = TwoOrbitPairType.Para then 1.0 else 0.0
        let selfSyymRate = if twoOrbitPairType = TwoOrbitPairType.SelfRefl then 1.0 else 0.0


        let genRates : Uf4GenRates = 
            { 
              Uf4GenRates.order = baseGenRates.order
              seedOpsGenRates = OpsGenRates.create(orthoRate, paraRate, selfSyymRate)
              opsGenRatesList = 
                  match twoOrbitPairTypeOverride with
                  | Some tot -> 
                      let orthoRate = if twoOrbitPairType = TwoOrbitPairType.Ortho then 1.0 else 0.0
                      let paraRate = if twoOrbitPairType = TwoOrbitPairType.Para then 1.0 else 0.0
                      let selfSyymRate = if twoOrbitPairType = TwoOrbitPairType.SelfRefl then 1.0 else 0.0
                      List.init baseGenRates.opsGenRatesList.Length (
                            fun _ -> OpsGenRates.create(orthoRate, paraRate, selfSyymRate))
                  | None -> baseGenRates.opsGenRatesList }

        UnfolderOps4.makeTwoOrbitUf4 mockFloatPicker genRates

    // Helper function to create a valid Msuf4
    let createTestMsuf4 
                (id: Guid<sorterModelID>) 
                (width: int<sortingWidth>) 
                (count: int)
                (twoOrbitPairType: TwoOrbitPairType) 
                (twoOrbitPairTypeOverride: TwoOrbitPairType option)
                : Msuf4 =
        let tou = createTestTwoOrbitUnfolder4 (%width) twoOrbitPairType twoOrbitPairTypeOverride
        let touArray = Array.create count tou
        Msuf4.create id width touArray

    [<Fact>]
    let ``create succeeds with valid input`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 4 TwoOrbitPairType.Ortho None
        let msuf4 = Msuf4.create id width [| tou |]
        Assert.Equal(id, msuf4.Id)
        Assert.Equal(width, msuf4.SortingWidth)
        Assert.Equal(1, %msuf4.StageCount)
        Assert.Equal<TwoOrbitUf4 array>([| tou |], msuf4.TwoOrbitUnfolder4s)

    [<Fact>]
    let ``create fails with empty TwoOrbitUnfolder4 array`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let ex = Assert.Throws<Exception>(fun () -> Msuf4.create id width [||] |> ignore)
        Assert.Equal("Must have at least 1 TwoOrbitUnfolder4, got 0", ex.Message)

    [<Fact>]
    let ``create fails with invalid width`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 0<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 4 TwoOrbitPairType.Ortho None
        let ex = Assert.Throws<Exception>(fun () -> Msuf4.create id width [| tou |] |> ignore)
        Assert.Equal("SortingWidth must be at least 1, got 0", ex.Message)

    [<Fact>]
    let ``create fails with mismatched TwoOrbitUnfolder4 order`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 8<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 4 TwoOrbitPairType.Ortho None
        let ex = Assert.Throws<Exception>(fun () -> Msuf4.create id width [| tou |] |> ignore)
        Assert.Equal("All TwoOrbitUnfolder4 must have order 8", ex.Message)

    [<Theory>]
    [<InlineData("Ortho", 0, 1, 2, 3)>]
    [<InlineData("Para", 0, 2, 1, 3)>]
    [<InlineData("SelfRefl", 0, 3, 1, 2)>]
    let ``makeSorter produces correct Sorter for order 4`` (seedTypeStr: string) (low1: int) (hi1: int) (low2: int) (hi2: int) =
        let seedType = toTwoOrbitPairType seedTypeStr
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 4 seedType None
        let msuf4 = Msuf4.create id width [| tou |]
        let sorter = (msuf4 :> ISorterModel).MakeSorter()
        Assert.Equal(%id |> UMX.tag<sorterId>, sorter.SorterId)
        Assert.Equal(width, sorter.Width)
        let expectedCes = [| Ce.create low1 hi1; Ce.create low2 hi2 |]
        Assert.Equal<Ce>(expectedCes, sorter.Ces)

    [<Fact>]
    let ``makeSorter handles order 8 correctly with Ortho seed and Para unfolding`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 8<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 8 TwoOrbitPairType.Ortho (Some TwoOrbitPairType.Para)
        let msuf4 = Msuf4.create id width [| tou |]
        let sorter = (msuf4 :> ISorterModel).MakeSorter()
        let expectedCes = [| Ce.create 0 6; Ce.create 1 7; Ce.create 2 4; Ce.create 3 5 |]
        Assert.Equal<Ce>(expectedCes, sorter.Ces)
        Assert.Equal(%id |> UMX.tag<sorterId>, sorter.SorterId)
        Assert.Equal(width, sorter.Width)

    [<Fact>]
    let ``makeSorter handles order 8 correctly with Ortho seed and Ortho unfolding`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 8<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 8 TwoOrbitPairType.Ortho (Some TwoOrbitPairType.Ortho)
        let msuf4 = Msuf4.create id width [| tou |]
        let sorter = (msuf4 :> ISorterModel).MakeSorter()
        let expectedCes = [| Ce.create 0 1; Ce.create 2 3; Ce.create 4 5; Ce.create 6 7 |]
        Assert.Equal<Ce>(expectedCes, sorter.Ces)
        Assert.Equal(%id |> UMX.tag<sorterId>, sorter.SorterId)
        Assert.Equal(width, sorter.Width)

    [<Fact>]
    let ``makeSorter handles order 8 correctly with Ortho seed and SelfRefl unfolding`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 8<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 8 TwoOrbitPairType.Ortho (Some TwoOrbitPairType.SelfRefl)
        let msuf4 = Msuf4.create id width [| tou |]
        let sorter = (msuf4 :> ISorterModel).MakeSorter()
        let expectedCes = [| Ce.create 0 7; Ce.create 1 6; Ce.create 2 5; Ce.create 3 4 |]
        Assert.Equal<Ce>(expectedCes, sorter.Ces)
        Assert.Equal(%id |> UMX.tag<sorterId>, sorter.SorterId)
        Assert.Equal(width, sorter.Width)

    [<Fact>]
    let ``makeSorter handles order 16 correctly with Ortho seed and Para unfolding`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 16<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 16 TwoOrbitPairType.Ortho (Some TwoOrbitPairType.Para)
        let msuf4 = Msuf4.create id width [| tou |]
        let sorter = (msuf4 :> ISorterModel).MakeSorter()
        let expectedCes = [| Ce.create 0 9; Ce.create 1 8; Ce.create 2 11; Ce.create 3 10
                             Ce.create 4 13; Ce.create 5 12; Ce.create 6 15; Ce.create 7 14 |]
        Assert.Equal<Ce>(expectedCes, sorter.Ces)
        Assert.Equal(%id |> UMX.tag<sorterId>, sorter.SorterId)
        Assert.Equal(width, sorter.Width)

    [<Fact>]
    let ``equality based on id`` () =
        let id = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let tou1 = createTestTwoOrbitUnfolder4 4 TwoOrbitPairType.Ortho None
        let tou2 = createTestTwoOrbitUnfolder4 4 TwoOrbitPairType.Para None
        let msuf4_1 = Msuf4.create id width [| tou1 |]
        let msuf4_2 = Msuf4.create id width [| tou1; tou2 |]
        Assert.Equal(msuf4_1, msuf4_2)
        Assert.Equal(msuf4_1.GetHashCode(), msuf4_2.GetHashCode())

    [<Fact>]
    let ``inequality with different ids`` () =
        let id1 = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let id2 = Guid.NewGuid() |> UMX.tag<sorterModelID>
        let width = 4<sortingWidth>
        let tou = createTestTwoOrbitUnfolder4 4 TwoOrbitPairType.Ortho None
        let msuf4_1 = Msuf4.create id1 width [| tou |]
        let msuf4_2 = Msuf4.create id2 width [| tou |]
        Assert.NotEqual(msuf4_1, msuf4_2)
        Assert.NotEqual(msuf4_1.GetHashCode(), msuf4_2.GetHashCode())
module Program

//[<EntryPoint>]
//let main _ = 0
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Project")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0341568e6de31d96807f09cf8255cb26c1320b13")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Project")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Project")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()

namespace GeneSort.Project


open MessagePack
open MessagePack.FSharp
open MessagePack.Resolvers
open System
open System.IO
open System.Threading
open System.Threading.Tasks


module Exp1 =
    
    let parameterSet = 
        [ ("SorterType", ["Mcse"; "Mssi"; "Msrs"; "Msuf6"])
          ("SortingWidth", ["8"; "16"; "32"; "64"]) ]

    //let makeRandGenModel (paramMap: Map<string, string>) : RandGenModel =
    //    { RandGenModel.Width = width
    //      RandGenModel.Seed = 42 // Fixed seed for reproducibility
    //      RandGenModel.Count = 1000 // Number of random elements to generate
    //      RandGenModel.MaxValue = 1000 } // Maximum value for random elements
// For more information see https://aka.ms/fsharp-console-apps
printfn "Hello from F#"

namespace GeneSort.Project


open MessagePack
open MessagePack.FSharp
open MessagePack.Resolvers
open System
open System.IO
open System.Threading
open System.Threading.Tasks


[<MessagePackObject>]
type RunDTO = 
    { 
      [<Key("index")>] Index: int
      [<Key("parameters")>] Properties: Map<string, string>
    }

// Event type for Run completion
type RunCompletedEventArgs = { Index: int }

// Run type
type Run = 
    { Index: int
      Parameters: Map<string, string> }

module Run =
    // MessagePack options for serialization
    let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)
    // Convert Run to a DTO for serialization
    let toRunDTO (run: Run) : RunDTO =
        { Index = run.Index
          Properties = run.Parameters }

    let fromDto (dto: RunDTO) : Run =
        { Index = dto.Index
          Parameters = dto.Properties }

namespace GeneSort.Project

open System
open FSharp.UMX
open GeneSort.Sorter
open MessagePack
open MessagePack.FSharp
open MessagePack.Resolvers
open System.IO
open GeneSort.Core.Combinatorics
open System.Threading.Tasks



[<MessagePackObject>]
type WorkspaceDTO = 
    { 
        [<MessagePack.Key("Name")>] Name: string
        [<MessagePack.Key("Description")>]  Description: string
        [<MessagePack.Key("RootDirectory")>] RootDirectory: string
        [<MessagePack.Key("ParameterSets")>] ParameterSets: list<string * list<string>>
    }

// Workspace type
type Workspace = 
    { 
      Name: string
      Description: string
      RootDirectory: string
      ParameterSets: list<string * list<string>>
    }


module Workspace =  
    /// Options for MessagePack serialization, using FSharpResolver and StandardResolver.
    let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)
    let toWorkspaceDTO (workspace: Workspace) : WorkspaceDTO =
        { Name = workspace.Name
          Description = workspace.Description
          RootDirectory = workspace.RootDirectory
          ParameterSets = workspace.ParameterSets }

    let fromWorkspaceDTO (dto: WorkspaceDTO) : Workspace =
        { Workspace.Name = dto.Name
          Description = dto.Description
          RootDirectory = dto.RootDirectory
          ParameterSets = dto.ParameterSets }

    let getWorkspaceFolder (workspace:Workspace) (folderName:string) : string =
        Path.Combine(workspace.RootDirectory, workspace.Name, folderName)

    /// Returns the file path for a Run, using the Runs folder and Run_<index>.msgpack naming
    let getRunFileName (workspace: Workspace) (run: Run) : string =
        let folder = getWorkspaceFolder workspace "Runs"
        let fileName = sprintf "Run_%d.msgpack" run.Index
        Path.Combine(folder, fileName)


    /// Returns a sequence of Runs made from all possible parameter combinations
    let getRuns (workspace: Workspace) : Run seq = 
        workspace.ParameterSets
        |> cartesianProductMaps
        |> Seq.mapi (fun i paramsMap -> { Index = i; Parameters = paramsMap })


    /// Executes async computations in parallel, limited to maxDegreeOfParallelism at a time
    let private ParallelWithThrottle (maxDegreeOfParallelism: int) (computations: seq<Async<unit>>) : Async<unit> =
        async {
            use semaphore = new System.Threading.SemaphoreSlim(maxDegreeOfParallelism)
            let tasks =
                computations
                |> Seq.map (fun comp ->
                    async {
                        try
                            do! Async.AwaitTask (semaphore.WaitAsync())
                            do! comp
                        finally
                            semaphore.Release() |> ignore
                    }
                    |> Async.StartAsTask : Task<unit>)
                |> Seq.toArray
            let! _ = Async.AwaitTask (Task.WhenAll(tasks))
            return ()
        }


    /// Executes all runs from the workspace, running up to atTheSameTime runs concurrently
    /// Skips runs if their output file already exists; saves runs to .msgpack files after execution
    let executeWorkspace (workspace: Workspace) (maxDegreeOfParallelism: int) (executor: Workspace -> Run -> unit) : unit =
        let runs = getRuns workspace
        let executeRun run = async {
            let filePath = getRunFileName workspace run
            if File.Exists filePath then
                () // Skip if file exists
            else
                try
                    executor workspace run
                    let runDto = Run.toRunDTO run
                    let directory = Path.GetDirectoryName filePath
                    Directory.CreateDirectory directory |> ignore
                    use stream = new FileStream(filePath, FileMode.Create, FileAccess.Write)
                    do! Async.AwaitTask (MessagePackSerializer.SerializeAsync(stream, runDto, options))
                with e ->
                    printfn "Error processing Run %d: %s" run.Index e.Message
        }
        let limitedParallel =
            runs
            |> Seq.map executeRun
            |> ParallelWithThrottle maxDegreeOfParallelism
        Async.RunSynchronously limitedParallel
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Microsoft.Testing.Platform.MSBuild
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.TestingPlatform.Extensions

open System.Runtime.CompilerServices

[<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage>]
[<Extension>]
type SelfRegisteredExtensions() =

    [<Extension>]
    static member AddSelfRegisteredExtensions (builder: Microsoft.Testing.Platform.Builder.ITestApplicationBuilder, args: string[]) =
        Microsoft.Testing.Platform.MSBuild.TestingPlatformBuilderHook.AddExtensions(builder, args)
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Project.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0341568e6de31d96807f09cf8255cb26c1320b13")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Project.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Project.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
module Program

//[<EntryPoint>]
//let main _ = 0
let main () =
    printfn "GeneSort Project Test Program"
    // Here you can add code to test the functionality of your project
    // For example, you could create a Workspace, Run, or Msuf4Set and perform operations on them
    // This is just a placeholder for demonstration purposes
namespace GeneSort.Project.Test

open System
open FSharp.UMX
open Xunit
open MessagePack.Resolvers
open MessagePack
open MessagePack.FSharp
open System.IO
open GeneSort.Project
open System.Threading

type WorkspaceTests() =

    let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)

    // Helper to create a temporary directory for tests
    let createTempDir () =
        let tempPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString())
        Directory.CreateDirectory tempPath |> ignore
        tempPath

    // Helper to clean up temporary directory with retries
    let cleanupTempDir (path: string) =
        if Directory.Exists path then
            let maxRetries = 5
            let retryDelayMs = 100
            let rec tryDelete retries =
                try
                    Directory.Delete(path, true)
                with
                | :? IOException when retries > 0 ->
                    Thread.Sleep retryDelayMs
                    tryDelete (retries - 1)
                | ex when retries = 0 ->
                    printfn "Failed to delete directory %s after %d retries: %s" path maxRetries ex.Message
            tryDelete maxRetries


    // Helper to create a sample workspace
    let createWorkspace (rootDir: string) (parameterSets: list<string * list<string>>) =
        { Workspace.Name = "TestWorkspace"
          Description = "Test Description"
          RootDirectory = rootDir
          ParameterSets = parameterSets }

    [<Fact>]
    let ``getRuns generates correct number of runs`` () =
        let workspace = createWorkspace (createTempDir ()) [("algorithm", ["quick"; "merge"]); ("size", ["small"; "large"])]
        let runs = Workspace.getRuns workspace |> Seq.toList
        Assert.Equal(4, runs.Length) // 2 algorithms * 2 sizes = 4 combinations
        let indices = runs |> List.map (fun r -> r.Index)
        Assert.Equal<int>([0; 1; 2; 3], indices)
        let parameters = runs |> List.map (fun r -> r.Parameters)
        let expectedParams = [
            Map.ofList [("algorithm", "quick"); ("size", "small")]
            Map.ofList [("algorithm", "quick"); ("size", "large")]
            Map.ofList [("algorithm", "merge"); ("size", "small")]
            Map.ofList [("algorithm", "merge"); ("size", "large")]
        ]
        Assert.All(List.zip parameters expectedParams, fun (actual, expected) -> 
                Assert.Equal<Map<string, string>>(expected, actual))
        cleanupTempDir workspace.RootDirectory

    [<Fact>]
    let ``getRunFileName produces correct file path`` () =
        let tempDir = createTempDir ()
        let workspace = createWorkspace tempDir []
        let run = { Index = 3; Parameters = Map.ofList [("algorithm", "quick")] }
        let filePath = Workspace.getRunFileName workspace run
        let expectedPath = Path.Combine(tempDir, "TestWorkspace", "Runs", "Run_3.msgpack")
        Assert.Equal(expectedPath, filePath)
        cleanupTempDir tempDir


    [<Fact>]
    let ``executeWorkspace executes runs and saves files`` () =
        let tempDir = createTempDir ()
        let workspace = createWorkspace tempDir [("algorithm", ["quick"; "merge"; "fonzy"; "ralph"; "quick1"; "merge1"; "fonzy1"; "ralph1"; "quick2"; "merge2"; "fonzy2"; "ralph2"])]
        // Clear Runs folder to ensure no existing files
        let runsFolder = Workspace.getWorkspaceFolder workspace "Runs"
        if Directory.Exists runsFolder then
            Directory.Delete(runsFolder, true)
        // Log existing files for debugging
        let runs = Workspace.getRuns workspace |> Seq.toList
        for run in runs do
            let filePath = Workspace.getRunFileName workspace run
            if File.Exists filePath then
                printfn "File already exists for Run %d: %s" run.Index filePath
        let mutable executedRuns = []

        let lockObj = obj() // Lock object for thread safety
        let executor _ (run: Run) =
            printfn "Executing Run %d" run.Index
            lock lockObj (fun () ->
                executedRuns <- run.Index :: executedRuns)

        Workspace.executeWorkspace workspace 2 executor
        Assert.Equal(12, runs.Length) // 12 algorithms
        for run in runs do
            let filePath = Workspace.getRunFileName workspace run
            Assert.True(File.Exists filePath)
            use stream = new FileStream(filePath, FileMode.Open, FileAccess.Read)
            let runDto = MessagePackSerializer.Deserialize<RunDTO>(stream, options)
            let expectedDto = Run.toRunDTO run
            Assert.Equal(expectedDto.Index, runDto.Index)
            Assert.Equal<Map<string,string>>(expectedDto.Properties, runDto.Properties)
        cleanupTempDir tempDir
        Assert.Equal(12, executedRuns.Length)
        Assert.Contains(1, executedRuns)
        Assert.Contains(2, executedRuns)
        Assert.Contains(3, executedRuns)


    [<Fact>]
    let ``executeWorkspace skips existing run files`` () =
        let tempDir = createTempDir ()
        let workspace = createWorkspace tempDir [("algorithm", ["quick"])]
        let run = { Index = 0; Parameters = Map.ofList [("algorithm", "quick")] }
        let filePath = Workspace.getRunFileName workspace run
        Directory.CreateDirectory (Path.GetDirectoryName filePath) |> ignore
        use stream = new FileStream(filePath, FileMode.Create, FileAccess.Write)
        MessagePackSerializer.Serialize(stream, Run.toRunDTO run, options)
        let mutable executedCount = 0
        let executor _ _ = executedCount <- executedCount + 1
        Workspace.executeWorkspace workspace 2 executor
        Assert.Equal(0, executedCount) // Run should be skipped
        cleanupTempDir tempDir

    [<Fact>]
    let ``executeWorkspace handles executor errors`` () =
        let tempDir = createTempDir ()
        let workspace = createWorkspace tempDir [("algorithm", ["quick"])]
        let executor _ (run: Run) = raise (Exception $"Error in Run {run.Index}")
        Workspace.executeWorkspace workspace 2 executor
        let run = { Index = 0; Parameters = Map.ofList [("algorithm", "quick")] }
        let filePath = Workspace.getRunFileName workspace run
        Assert.False(File.Exists filePath) // File not created due to error
        cleanupTempDir tempDir
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Sorter")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Sorter")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Sorter")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Sorter")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0341568e6de31d96807f09cf8255cb26c1320b13")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Sorter")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Sorter")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Sorter")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Release")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+c0cdc112d9c5b01145f143569ebe9e98ebe2e8d2")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Sorter")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Sorter")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace GeneSort.Sorter

open System
open FSharp.UMX
open GeneSort.Core

// Type definitions
[<Struct; CustomEquality; NoComparison>]
type Ce = private { low: int; hi: int } with

    static member create (lv: int) (hv: int) : Ce =
        if lv < 0 || hv < 0 then
            failwith "Indices must be non-negative"
        else if lv < hv then
            { low = lv; hi = hv }
        else
            { low = hv; hi = lv }

    /// Gets the first TwoOrbit.
    member this.Low with get () = this.low

    /// Gets the second TwoOrbit (if present).
    member this.Hi with get () = this.hi

    override this.Equals(obj) = 
        match obj with
        | :? Ce as other -> this.low = other.low && this.hi = other.hi
        | _ -> false
    override this.GetHashCode() = 
        hash (this.low, this.hi)
    interface IEquatable<Ce> with
        member this.Equals(other) = 
            this.low = other.low && this.hi = other.hi

// Core module for Ce operations
module Ce =

    let toString (ce: Ce) : string =
        sprintf "(%d, %d)" ce.Low ce.Hi

    let maxIndexForWdith (width: int) : int =
        width*(width - 1) / 2

    let toIndex (ce: Ce) : int =
        let i = ce.Low
        let j = ce.Hi
        (j * (j + 1)) / 2 + i

    let fromIndex (dex:int) = 
        if dex < 0 then
            failwith "Index must be non-negative"
        else
        let indexFlt = (dex |> float) + 1.0
        let p = (sqrt (1.0 + 8.0 * indexFlt) - 1.0) / 2.0
        let pfloor = int p
        if (p = pfloor) then 
            Ce.create (pfloor - 1) (pfloor - 1)
        else
            let lo = (float dex) - (float (pfloor * (pfloor + 1))) / 2.0 |> int
            let hi = (int pfloor)
            Ce.create (lo) (hi)

    let reflect 
            (sortingWidth: int<sortingWidth>) 
            (ce: Ce) 
        : Ce =
        Ce.create 
                (ce.Hi |> GeneSort.Core.Combinatorics.reflect %sortingWidth) 
                (ce.Low |>  GeneSort.Core.Combinatorics.reflect %sortingWidth)


    let generateCeCode (excludeSelfCe:bool)
                       (width:int) 
                       (indexPicker: int -> int) : int =
        if width < 1 then
            failwith "Width must be at least 1"
        let ww = if excludeSelfCe then width else width + 1
        let indexMax = maxIndexForWdith ww
        let dex = indexPicker indexMax
        if excludeSelfCe then
            let ceTemp = fromIndex dex
            Ce.create (ceTemp.Low) (ceTemp.Hi + 1) |> toIndex
        else
            dex


    /// returns random Ce's to make Sorters, including Ce's where low=hi
    /// <param name="width">The Sorter width</param>
    let generateCeCodes (indexPicker: int -> int) 
                        (width:int) : int seq =
        if width < 1 then
            failwith "Width must be at least 1"
        let indexMax = maxIndexForWdith width
        seq {
            while true do
                indexPicker indexMax
        }


    /// returns random Ce's to make Sorters, excluding Ce's where low=hi
    /// <param name="width">The Sorter width</param>
    let generateCeCodesExcludeSelf 
                    (indexPicker: int -> int) 
                    (width:int) : int seq =
        if width < 2 then
            failwith "Width must be at least 2"
        let indexMax = maxIndexForWdith (width - 1)
        seq {
            while true do
                let ceTemp = indexPicker indexMax |> fromIndex
                Ce.create (ceTemp.Low) (ceTemp.Hi + 1) |> toIndex
        }


    /// returns random Ce's to make Sorters, including Ce's where low=hi
    /// <param name="width">The Sorter width</param>
    let generateCes (indexPicker: int -> int) 
                    (width:int) : Ce seq =
        generateCeCodes indexPicker width |> Seq.map(fromIndex)


    /// returns random Ce's to make Sorters, excluding Ce's where low=hi
    /// <param name="width">The Sorter width</param>
    let generateCesExcludeSelf 
                    (indexPicker: int -> int) 
                    (width:int) : Ce seq =
        generateCeCodesExcludeSelf indexPicker width |> Seq.map(fromIndex)


    let fromTwoOrbit (twoOrbit:TwoOrbit) :Ce = 
            Ce.create (twoOrbit.First) (twoOrbit.Second)
open GeneSort.Sorter

let yab () = 
    let sortingWidth = 10
    let ceCount = 100000000
    for i in 0 .. ceCount - 1 do
        let ce = Ce.fromIndex i
        if Ce.toIndex ce <> i then
            printfn " *********************  Error at index %d: expected %d, got %d" i i (Ce.toIndex ce)  
        //printfn "Ce %d: %s  %d" i (GeneSort.Sorter.Ce.toString ce)  (Ce.toIndex ce)

    printfn "done"
// For more information see https://aka.ms/fsharp-console-apps
(yab())
namespace GeneSort.Sorter

open System


type sortableInts =
    private
        { values: int[]
          sortingWidth: int<sortingWidth>
          symbolSetSize: int }


type sortableBools =
    private { values: bool[]; order: int<sortingWidth> }


module SortableInts = ()


module SortableBools = ()
namespace GeneSort.Sorter

open System
open FSharp.UMX


type Sorter =
        { SorterId: Guid<sorterId>
          Width: int<sortingWidth>
          Ces: Ce array }


// Core module for Sorter operations
module Sorter =

    let create (sorterId: Guid<sorterId>) (width: int<sortingWidth>) (ces: Ce array) : Sorter =
        if %sorterId = Guid.Empty then
            failwith "Sorter ID must not be empty"
        else if %width < 1 then
            failwith "Width must be at least 1"
        else
            { SorterId = sorterId; Width = width; Ces = ces }

    let createWithNewId (width: int<sortingWidth>) (ces: Ce array) : Sorter =
        create (UMX.tag<sorterId> (Guid.NewGuid())) width ces

    let toString (sorter: Sorter) : string =
        let cesStr = sorter.Ces |> Array.map Ce.toString |> String.concat "; "
        sprintf "Sorter(Id=%A, Width=%d, Ces=[%s])" (%sorter.SorterId) (%sorter.Width) cesStr


namespace GeneSort.Sorter

open System
open FSharp.UMX

type SorterSet =
        { SorterSetId: Guid<sorterSetId>
          Sorters: Sorter array }


module SorterSet =

    let create (sorterSetId: Guid<sorterSetId>) (sorters: Sorter array) : SorterSet =
        if %sorterSetId = Guid.Empty then
            failwith "SorterSet ID must not be empty"
        else if Array.isEmpty sorters then
            failwith "Sorter set must contain at least one sorter"
        else
            { SorterSetId = sorterSetId; Sorters = sorters }


    let createWithNewId (sorters: Sorter array) : SorterSet =
        create (UMX.tag<sorterSetId> (Guid.NewGuid())) sorters

    let toString (sorterSet: SorterSet) : string =
        let sortersStr = sorterSet.Sorters |> Array.map Sorter.toString |> String.concat "; "
        sprintf "SorterSet(Id=%A, Sorters=[%s])" (%sorterSet.SorterSetId) sortersStr
namespace GeneSort.Sorter

open FSharp.UMX

[<Measure>] type sorterLength
[<Measure>] type sortingWidth
[<Measure>] type sorterCount
[<Measure>] type sorterId
[<Measure>] type stageCount
[<Measure>] type ceCount







[<Measure>] type sorterParentId
[<Measure>] type sortableCount
[<Measure>] type sortableSetId
[<Measure>] type sortableSetCount
[<Measure>] type setOfSortableSetId
[<Measure>] type sorterSetConcatMapId
[<Measure>] type sorterSetParentMapId
[<Measure>] type sorterSetMutatorId
[<Measure>] type sorterSpeedBinSetId
[<Measure>] type sorterSetId
[<Measure>] type stageWindowSize
[<Measure>] type switchFrequency



module CeCount =
    
    let toStageCount (sortingWidth:int<sortingWidth>) (ceCount: int<ceCount>) 
            : int<stageCount> =
        if %ceCount < 1 then
            failwith "CeCount must be at least 1"
        else
            ((%ceCount * 2) / %sortingWidth) |> UMX.tag<stageCount> 

module StageCount =

    let toCeCount (sortingWidth:int<sortingWidth>) (stageCount: int<stageCount>) 
            : int<ceCount> =
        if %stageCount < 1 then
            failwith "StageCount must be at least 1"
        else
            ((%stageCount * %sortingWidth) / 2) |> UMX.tag<ceCount> 

namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Microsoft.Testing.Platform.MSBuild
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.TestingPlatform.Extensions

open System.Runtime.CompilerServices

[<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage>]
[<Extension>]
type SelfRegisteredExtensions() =

    [<Extension>]
    static member AddSelfRegisteredExtensions (builder: Microsoft.Testing.Platform.Builder.ITestApplicationBuilder, args: string[]) =
        Microsoft.Testing.Platform.MSBuild.TestingPlatformBuilderHook.AddExtensions(builder, args)
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+58a6ada8ed61c90ab3bfdb93bcb921d31249e16a")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("GeneSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0341568e6de31d96807f09cf8255cb26c1320b13")>]
[<assembly: System.Reflection.AssemblyProductAttribute("GeneSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("GeneSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyMetadata("Microsoft.Testing.Platform.Application", "True")>]
do()
namespace Microsoft.BuildSettings
                [<System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")>]
                do ()
// <auto-generated>
//     Generated by the FSharp WriteCodeFragment class.
// </auto-generated>
namespace FSharp

open System
open System.Reflection


[<assembly: System.Reflection.AssemblyCompanyAttribute("EvoMergeSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyConfigurationAttribute("Release")>]
[<assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")>]
[<assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+c0cdc112d9c5b01145f143569ebe9e98ebe2e8d2")>]
[<assembly: System.Reflection.AssemblyProductAttribute("EvoMergeSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyTitleAttribute("EvoMergeSort.Sorter.Test")>]
[<assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")>]
do()
namespace GeneSort.Sorter.Tests

open System
open Xunit
open FSharp.UMX
open GeneSort.Core.Combinatorics
open GeneSort.Sorter
open FsUnit.Xunit

type CeTests() =

    [<Fact>]
    let ``generateCeCode with excludeSelfCe false returns indexPicker value`` () =
        let width = 4
        let indices = [|0 .. 20|] // Corresponds to Ces: (0,1), (0,2), (1,2), (0,3), (1,3), (2,3)
        let picker = indexPicker indices
        let result = Ce.generateCeCode false  width picker
        result |> should equal 0 // First index from picker
        let maxIndex = Ce.maxIndexForWdith width
        result |> should be (lessThanOrEqualTo maxIndex)

    [<Fact>]
    let ``generateCeCode with excludeSelfCe true shifts hi index`` () =
        let width = 4
        let indices = [|0; 1; 2|] // Corresponds to Ces: (0,1), (0,2), (1,2)
        let picker = indexPicker indices
        let result = Ce.generateCeCode true width picker
        let expectedCe = Ce.create 0 1 // index 0 maps to (0,0), shifted to (0,1)
        let expectedIndex = Ce.toIndex expectedCe
        result |> should equal expectedIndex
        let ce = Ce.fromIndex result
        ce.Low |> should not' (equal ce.Hi)

    [<Fact>]
    let ``generateCeCode with excludeSelfCe true produces valid Ce within width`` () =
        let width = 5
        let indices = [|0; 1; 2; 3; 4; 5|]
        let picker = indexPicker indices
        let results = [ for _ in 1..6 -> Ce.generateCeCode true width picker]
        results |> List.iter (fun idx ->
            let ce = Ce.fromIndex idx
            ce.Low |> should be (lessThanOrEqualTo (width - 1))
            ce.Hi |> should be (lessThanOrEqualTo (width - 1))
            ce.Low |> should not' (equal ce.Hi))

    [<Fact>]
    let ``generateCeCode throws for width less than 1`` () =
        let picker = indexPicker [|0; 1; 2|]
        (fun () -> Ce.generateCeCode false 0 picker |> ignore) 
        |> should throw typeof<Exception>

    [<Fact>]
    let ``generateCeCode with excludeSelfCe true handles edge case width 2`` () =
        let width = 2
        let indices = [|0|] // Maps to (0,1) when excludeSelfCe is true
        let picker = indexPicker indices
        let result = Ce.generateCeCode true width picker
        let ce = Ce.fromIndex result
        ce |> should equal (Ce.create 0 1)
        ce.Low |> should not' (equal ce.Hi)


    [<Fact>]
    let ``toIndex and fromIndex round-trip for valid Ce including Low = Hi``() =
        let ces = [ 
                Ce.create 0 0; Ce.create 0 1; Ce.create 0 2; Ce.create 0 3; Ce.create 0 4; Ce.create 0 5; 
                Ce.create 1 1; Ce.create 1 2; Ce.create 1 3; Ce.create 1 4; Ce.create 1 5; Ce.create 1 6; 
                Ce.create 2 2; Ce.create 2 3; Ce.create 2 4; Ce.create 2 5; Ce.create 2 6; Ce.create 2 7; 
                Ce.create 3 3; Ce.create 3 4; Ce.create 3 5; Ce.create 3 6; Ce.create 3 7; Ce.create 3 8; 
                Ce.create 4 4; Ce.create 4 5; Ce.create 4 6; Ce.create 4 7; Ce.create 4 8; Ce.create 4 9; 
                Ce.create 5 5; Ce.create 5 6; Ce.create 5 7; Ce.create 5 8; Ce.create 5 9; Ce.create 5 10; 
            ]

        for ce in ces do
            let index = Ce.toIndex ce
            let ce' = Ce.fromIndex index
            Assert.Equal(ce, ce')

    [<Theory>]
    [<InlineData(-1, 0, "Indices must be non-negative")>]
    [<InlineData(0, -1, "Indices must be non-negative")>]
    [<InlineData(-1, -1, "Indices must be non-negative")>]
    let ``Ce.create rejects negative indices`` (low: int, hi: int, expectedMsg: string) =
        let ex = Assert.Throws<Exception>(fun () -> Ce.create low hi |> ignore)
        Assert.Equal(expectedMsg, ex.Message)

    [<Theory>]
    [<InlineData(-1, "Index must be non-negative")>]
    [<InlineData(-2, "Index must be non-negative")>]
    let ``fromIndex handles invalid index`` (index: int, expectedMsg: string) =
        let ex = Assert.Throws<Exception>(fun () -> Ce.fromIndex index |> ignore)
        Assert.Equal(expectedMsg, ex.Message)

    [<Fact>]
    let ``generateCes produces valid Ces within width`` () =
        let width = 4
        let indices = [|0; 1; 2; 3; 4; 5|] // Corresponds to Ces: (0,1), (0,2), (1,2), (0,3), (1,3), (2,3)
        let picker = indexPicker indices
        let ces = Ce.generateCes picker width |> Seq.take 6 |> Seq.toList
        let expected = [
            Ce.create 0 0
            Ce.create 0 1
            Ce.create 1 1
            Ce.create 0 2
            Ce.create 1 2
            Ce.create 2 2
        ]
        ces |> should equal expected
        ces |> List.iter (fun ce -> 
            ce.Low |> should be (lessThanOrEqualTo (width - 1))
            ce.Hi |> should be (lessThanOrEqualTo (width - 1)))

    [<Fact>]
    let ``generateCes includes low equals hi when index maps to it`` () =
        let width = 3
        let indices = [|0; 3; 6|] // Indices that could map to low=hi in larger context
        let picker = indexPicker indices
        let ces = Ce.generateCes picker width |> Seq.take 3 |> Seq.toList
        let expected = [
            Ce.create 0 0
            Ce.create 0 2
            Ce.create 0 3
        ]
        ces |> should equal expected

    [<Fact>]
    let ``generateCes throws for invalid width`` () =
        let picker = indexPicker [|0; 1; 2|]
        (fun () -> Ce.generateCes picker 0 |> Seq.take 1 |> ignore) 
        |> should throw typeof<Exception>

    [<Fact>]
    let ``generateCesExcludeSelf produces valid Ces excluding low equals hi`` () =
        let width = 4
        let indices = [|0; 1; 2; 3|] // Corresponds to Ces: (0,1), (0,2), (1,2), (0,3) after offset
        let picker = indexPicker indices
        let ces = Ce.generateCesExcludeSelf picker width |> Seq.take 4 |> Seq.toList
        let expected = [
            Ce.create 0 1
            Ce.create 0 2
            Ce.create 1 2
            Ce.create 0 3
        ]
        ces |> should equal expected
        ces |> List.iter (fun ce -> 
            ce.Low |> should not' (equal ce.Hi)
            ce.Low |> should be (lessThanOrEqualTo (width - 1))
            ce.Hi |> should be (lessThanOrEqualTo (width - 1)))

    [<Fact>]
    let ``generateCesExcludeSelf throws for width less than 2`` () =
        let picker = indexPicker [|0; 1; 2|]
        (fun () -> Ce.generateCesExcludeSelf picker 1 |> Seq.take 1 |> ignore) 
        |> should throw typeof<Exception>

    [<Fact>]
    let ``generateCesExcludeSelf produces distinct Ces for different indices`` () =
        let width = 5
        let indices = [|0; 1; 2; 3; 4; 5|]
        let picker = indexPicker indices
        let ces = Ce.generateCesExcludeSelf picker width |> Seq.take 6 |> Seq.toList
        let distinctCes = ces |> List.distinct
        distinctCes.Length |> should equal ces.Length
        ces |> List.iter (fun ce -> ce.Low |> should not' (equal ce.Hi))


module Program

//[<EntryPoint>]
//let main _ = 0
namespace GeneSort.Sorter.Tests

open System
open Xunit
open FSharp.UMX
open GeneSort.Sorter

type SorterSetTests() =

    [<Fact>]
    let ``SorterSet.create creates valid SorterSet``() =
        let createSorter ces =
            Sorter.createWithNewId (UMX.tag<sortingWidth> 4) ces
        
        let ces1 = [| Ce.create 0 1; Ce.create 1 1 |]
        let ces2 = [| Ce.create 0 2; Ce.create 1 2 |]
        let sorters = [| createSorter ces1; createSorter ces2 |]
        
        let sorterSet = SorterSet.createWithNewId sorters
        Assert.NotEqual(Guid.Empty, %sorterSet.SorterSetId)
        Assert.Equal(2, (%sorterSet.Sorters.Length * 1<sorterCount>))
        Assert.Equal(ces1 |> Array.toList, sorterSet.Sorters.[0].Ces)
        Assert.Equal(ces2 |> Array.toList, sorterSet.Sorters.[1].Ces)
        Assert.Equal(4, %sorterSet.Sorters.[0].Width)
        Assert.Equal(4, %sorterSet.Sorters.[1].Width)
namespace GeneSort.Sorter.Tests

open System
open Xunit
open FSharp.UMX
open FsUnit.Xunit
open GeneSort.Sorter


type SorterTests() =

    [<Fact>]
    let ``Sorter.create allows Low = Hi within width``() =
        let ces = [| Ce.create 0 1; Ce.create 1 1 |]
        let sorter = Sorter.createWithNewId (UMX.tag<sortingWidth> 4) ces
        Assert.Equal(2, sorter.Ces.Length)

    [<Fact>]
    let ``Sorter.create rejects empty SorterId``() =
        let ces = [| Ce.create 0 1 |]
        let ex = Assert.Throws<Exception>(fun () -> 
            Sorter.create (UMX.tag<sorterId> Guid.Empty) (UMX.tag<sortingWidth> 4) ces |> ignore)
        Assert.Equal("Sorter ID must not be empty", ex.Message)

    [<Fact>]
    let ``Sorter.create rejects invalid width``() =
        let ces = [| Ce.create 0 1 |]
        let ex = Assert.Throws<Exception>(fun () -> 
            Sorter.createWithNewId (UMX.tag<sortingWidth> 0) ces |> ignore)
        Assert.Equal("Width must be at least 1", ex.Message)
