namespace GeneSort.Project

open System

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorting
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter.Uf6
open System.Threading
open GeneSort.Runs
open GeneSort.Db
open ProjectOps


module RandomSorters =
    
    // Progress reporter that prints to console
    let progress = 
        { new IProgress<string> with
            member _.Report(msg) = printfn "%s" msg }


    let projectName = "RandomSorters"  |> UMX.tag<projectName>
    let projectFolder = "RandomSorters" |> UMX.tag<projectFolder>
    let projectDesc = "RandomSorters, generated by Msce, Mssi, Msrs, and Msuf"

    // Fixed parameters:
    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>


    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth:int<sortingWidth> option)
            (sorterModelType:sorterModelType option)
            (outputDataType: outputDataType) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> SortingWidth.toString); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            outputDataType



    // Parameter spans:
    
    //let sortingWidthValues = 
    //    [4; 6; 8; 12; 16; 24; 32; 48; 64] |> List.map(fun d -> d.ToString())
    let sortingWidthValues = 
        [4; 6; 8; 16; 24; 32; 48; 64; ] |> List.map(fun d -> d.ToString())


    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let sorterModelTypeValues () : string list =
        [ sorterModelType.Mcse; 
          sorterModelType.Mssi;
          sorterModelType.Msrs; 
          sorterModelType.Msuf4; 
          sorterModelType.Msuf6; ]      |> List.map(SorterModelType.toString)

    let sorterModelTypes () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelTypeValues() )


    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (50 * factor) |> UMX.tag<sorterCount>
        | 24 -> (50 * factor) |> UMX.tag<sorterCount>
        | 32 -> (50 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getCeLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<ceLength> =
        match %sortingWidth with
        | 4 -> 300 |> UMX.tag<ceLength>
        | 6 -> 600 |> UMX.tag<ceLength>
        | 8 -> 16 |> UMX.tag<ceLength>
        | 12 -> 24 |> UMX.tag<ceLength>
        | 16 -> 32 |> UMX.tag<ceLength>
        | 24 -> 48 |> UMX.tag<ceLength>
        | 32 -> 64 |> UMX.tag<ceLength>
        | 48 -> 96 |> UMX.tag<ceLength>
        | 64 -> 128 |> UMX.tag<ceLength>
        | 96 -> 192 |> UMX.tag<ceLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 5 |> UMX.tag<stageLength>
        | 6 -> 10 |> UMX.tag<stageLength>
        | 8 -> 20 |> UMX.tag<stageLength>
        | 12 -> 30 |> UMX.tag<stageLength>
        | 16 -> 100 |> UMX.tag<stageLength>
        | 24 -> 150 |> UMX.tag<stageLength>
        | 32 -> 200 |> UMX.tag<stageLength>
        | 48 -> 300 |> UMX.tag<stageLength>
        | 64 -> 400 |> UMX.tag<stageLength>
        | 96 -> 600 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

     
     // --- Filters ---

    let mergeDimensionDividesSortingWidth (rp: runParameters) =
        let sw = rp.GetSortingWidth().Value
        let md = rp.GetMergeDimension().Value
        if (%sw % %md = 0) then Some rp else None


    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Mcse -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth


    // --- Project Refinement ---

    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor

            rp.WithProjectName(Some projectName)
              .WithRunFinished(Some false)
              .WithCeLength(Some ceLength)
              .WithStageLength(Some stageLength)
              .WithSorterCount(Some sorterCount)
              .WithId (Some qp.Id)


        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let outputDataTypes = 
            [|
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]

    let parameterSpans = 
        [ sortingWidths(); sorterModelTypes() ]

    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup & ID Extraction
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) %runId %repl)

                // 2. Safe Parameter Extraction
                let! (sorterModelType, sortingWidth, stageLength, ceLength, sorterCount) = 
                    maybe {
                        let! smk = runParameters.GetSorterModelType()
                        let! sw = runParameters.GetSortingWidth()
                        let! sl = runParameters.GetStageLength()
                        let! cl = runParameters.GetCeLength()
                        let! sc = runParameters.GetSorterCount()
                        return (smk, sw, sl, cl, sc)
                    } |> Result.ofOption (sprintf "Run %s: Missing required parameters" %runId) |> asAsync

                // 3. Sorter Model Logic (Pure Computation)
                let sorterModelMaker =
                    match sorterModelType with
                    | sorterModelType.Mcse -> 
                        MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength 
                        |> sorterModelMaker.SmmMsceRandGen
                    | sorterModelType.Mssi -> 
                        MssiRandGen.create randomType sortingWidth stageLength 
                        |> sorterModelMaker.SmmMssiRandGen
                    | sorterModelType.Msrs -> 
                        let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                        msrsRandGen.create randomType sortingWidth opsGenRatesArray 
                        |> sorterModelMaker.SmmMsrsRandGen
                    | sorterModelType.Msuf4 -> 
                        let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                        msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray 
                        |> sorterModelMaker.SmmMsuf4RandGen
                    | sorterModelType.Msuf6 -> 
                        let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                        msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray 
                        |> sorterModelMaker.SmmMsuf6RandGen

                let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
                let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
                let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
                let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

                let! _ = checkCancellation cts.Token

                // 4. Sequential Saves
                let qpSorterSet = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSet "") 
                let! _ = db.saveAsync projectFolder qpSorterSet (sorterSet |> outputData.SorterSet) allowOverwrite
            
                progress |> Option.iter (fun p -> 
                    p.Report(sprintf "Saved sorterSet %s for run: %s" (%sorterSet.Id.ToString()) %runId))

                let qpMaker = makeQueryParamsFromRunParams runParameters (outputDataType.SorterModelSetMaker "") 
                let! _ = db.saveAsync projectFolder qpMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker) allowOverwrite
            
                progress |> Option.iter (fun p -> 
                    p.Report(sprintf "Saved SorterModelSetMaker %s for run: %s" (%sorterModelSetMaker.Id.ToString()) %runId))

                // 5. Final Return
                return runParameters.WithRunFinished (Some true)

            with e -> 
                let runId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Unexpected error in run %s: %s" runId e.Message
                return! async { return Error msg }
        }