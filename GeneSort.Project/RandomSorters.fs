namespace GeneSort.Project

open System

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorting
open GeneSort.Model.Sorting.Sorter.Ce
open GeneSort.Model.Sorting.Sorter.Si
open GeneSort.Model.Sorting.Sorter.Uf4
open GeneSort.Model.Sorting.Sorter.Rs
open GeneSort.Model.Sorting.Sorter.Uf6
open System.Threading
open GeneSort.Runs
open GeneSort.Db
open ProjectOps
open GeneSort.Model.Sorting
open GeneSort.Model.Sorting.ModelParams


module RandomSorters =
    
    // Progress reporter that prints to console
    let progress = 
        { new IProgress<string> with
            member _.Report(msg) = printfn "%s" msg }


    let projectName = "RandomSorters"  |> UMX.tag<projectName>
    let projectFolder = "RandomSorters" |> UMX.tag<projectFolder>
    let projectDesc = "RandomSorters, generated by Msce, Mssi, Msrs, and Msuf"

    // Fixed parameters:
    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>


    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth:int<sortingWidth> option)
            (sorterModelType:sorterModelType option)
            (outputDataType: outputDataType) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> SortingWidth.toString); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            outputDataType



    // Parameter spans:
    
    let sortingWidths() : string*string list =
       // let values = [4; 6; 8; 12; 16; 18; 20; 22; 24; 32; 36; 48; 64; 72; 96; 128; 144; 192; 256] |> List.map(fun d -> d.ToString())
       // let values = [4; 6; 8; 12; 16; 18; 20; 22; 24; 32; 64; 128; 256] |> List.map(fun d -> d.ToString())
        let values = [4; 6; 8; 12; 16; 18; 20; 22; 24; 32; 64;] |> List.map(fun d -> d.ToString())
        (runParameters.sortingWidthKey, values)


    let sorterModelTypes () : string*string list =
        let values =         
            [ sorterModelType.Msce; 
              sorterModelType.Mssi;
              sorterModelType.Msrs; 
              sorterModelType.Msuf4; 
              //sorterModelType.Msuf6; 
              ]  |> List.map(SorterModelType.toString)
        (runParameters.sorterModelTypeKey, values )


    let getStageLengthForSortingWidth0 (isMuf4:bool) (sortingWidth: int<sortingWidth>) : int<stageLength> =
        if isMuf4 then
            match %sortingWidth with
            | 4 -> 10 |> UMX.tag<stageLength>
            | 8 -> 50 |> UMX.tag<stageLength>
            | 16 -> 200 |> UMX.tag<stageLength>
            | 32 -> 600 |> UMX.tag<stageLength>
            | 64 -> 2000 |> UMX.tag<stageLength>
            | 128 -> 5000 |> UMX.tag<stageLength>
            | 256 -> 18000 |> UMX.tag<stageLength>
            | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        else
            match %sortingWidth with
            | 4 -> 5 |> UMX.tag<stageLength>
            | 6 -> 20 |> UMX.tag<stageLength>
            | 8 -> 40 |> UMX.tag<stageLength>
            | 12 -> 80 |> UMX.tag<stageLength>
            | 16 -> 100 |> UMX.tag<stageLength>
            | 18 -> 120 |> UMX.tag<stageLength>
            | 20 -> 130 |> UMX.tag<stageLength>
            | 22 -> 140 |> UMX.tag<stageLength>
            | 24 -> 200 |> UMX.tag<stageLength>
            | 32 -> 300 |> UMX.tag<stageLength>
            | 36 -> 340 |> UMX.tag<stageLength>
            | 48 -> 700 |> UMX.tag<stageLength>
            | 64 -> 1200 |> UMX.tag<stageLength>
            | 72 -> 500 |> UMX.tag<stageLength>
            | 96 -> 1800 |> UMX.tag<stageLength>
            | 128 -> 3000 |> UMX.tag<stageLength>
            | 144 -> 4000 |> UMX.tag<stageLength>
            | 192 -> 6000 |> UMX.tag<stageLength>
            | 256 -> 8000 |> UMX.tag<stageLength>
            | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)





    let getStageLengthForSortingWidth 
                        (smt:sorterModelType) 
                        (sortingWidth: int<sortingWidth>) : int<stageLength> =
            match %sortingWidth with
            | 4 -> 5 |> UMX.tag<stageLength>
            | 6 -> 20 |> UMX.tag<stageLength>
            | 8 -> 40 |> UMX.tag<stageLength>
            | 12 -> 80 |> UMX.tag<stageLength>
            | 16 -> 100 |> UMX.tag<stageLength>
            | 18 -> 120 |> UMX.tag<stageLength>
            | 20 -> 130 |> UMX.tag<stageLength>
            | 22 -> 140 |> UMX.tag<stageLength>
            | 24 -> 200 |> UMX.tag<stageLength>
            | 32 ->  match smt with
                        | sorterModelType.Msce -> 300 |> UMX.tag<stageLength>
                        | sorterModelType.Mssi -> 300 |> UMX.tag<stageLength>
                        | sorterModelType.Msrs -> 300 |> UMX.tag<stageLength>
                        | sorterModelType.Msuf4 -> 600 |> UMX.tag<stageLength>
                        | _ -> failwithf "Unsupported sorter model type: %A" smt

            | 64 -> match smt with
                        | sorterModelType.Msce -> 600 |> UMX.tag<stageLength>
                        | sorterModelType.Mssi -> 600 |> UMX.tag<stageLength>
                        | sorterModelType.Msrs -> 800 |> UMX.tag<stageLength>
                        | sorterModelType.Msuf4 -> 2000 |> UMX.tag<stageLength>
                        | _ -> failwithf "Unsupported sorter model type: %A" smt

            | 128 -> match smt with
                        | sorterModelType.Msce -> 1200 |> UMX.tag<stageLength>
                        | sorterModelType.Mssi -> 1500 |> UMX.tag<stageLength>
                        | sorterModelType.Msrs -> 1800 |> UMX.tag<stageLength>
                        | sorterModelType.Msuf4 -> 4000 |> UMX.tag<stageLength>
                        | _ -> failwithf "Unsupported sorter model type: %A" smt

            | 256 -> match smt with
                        | sorterModelType.Msce -> 3000 |> UMX.tag<stageLength>
                        | sorterModelType.Mssi -> 3000 |> UMX.tag<stageLength>
                        | sorterModelType.Msrs -> 4000 |> UMX.tag<stageLength>
                        | sorterModelType.Msuf4 -> 6000 |> UMX.tag<stageLength>
                        | _ -> failwithf "Unsupported sorter model type: %A" smt
            | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)




     
     // --- Filters ---

    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Msce -> 
                Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> 
                if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth


    // --- Project Refinement ---

    let enhancer (rp : runParameters) : runParameters =
        let sortingWidth = rp.GetSortingWidth().Value
        let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
        let stageLength = getStageLengthForSortingWidth (rp.GetSorterModelType().Value) sortingWidth
        let ceLength = stageLength |> StageLength.toCeLength sortingWidth
        let sorterCount = 150 |> UMX.tag<sorterCount>

        rp.WithProjectName(Some projectName)
            .WithRunFinished(Some false)
            .WithCeLength(Some ceLength)
            .WithStageLength(Some stageLength)
            .WithSorterCount(Some sorterCount)
            .WithId (Some qp.Id)


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let outputDataTypes = 
            [|
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]

    let parameterSpans = 
        [ sortingWidths(); sorterModelTypes() ]

    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup & ID Extraction
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) %runId %repl)

                // 2. Safe Parameter Extraction
                let! (sorterModelType, sortingWidth, stageLength, ceLength, sorterCount) = 
                    maybe {
                        let! smk = runParameters.GetSorterModelType()
                        let! sw = runParameters.GetSortingWidth()
                        let! sl = runParameters.GetStageLength()
                        let! cl = runParameters.GetCeLength()
                        let! sc = runParameters.GetSorterCount()
                        return (smk, sw, sl, cl, sc)
                    } |> Result.ofOption (sprintf "Run %s: Missing required parameters" %runId) |> asAsync

                // 3. Sorter Model Logic (Pure Computation)
                let sorterModelMaker =
                    match sorterModelType with
                    | sorterModelType.Msce -> 
                        msceRandGen.create randomType sortingWidth excludeSelfCe ceLength 
                        |> sorterModelMaker.SmmMsceRandGen
                    | sorterModelType.Mssi -> 
                        mssiRandGen.create randomType sortingWidth stageLength 
                        |> sorterModelMaker.SmmMssiRandGen
                    | sorterModelType.Msrs -> 
                        let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                        msrsRandGen.create randomType sortingWidth opsGenRatesArray 
                        |> sorterModelMaker.SmmMsrsRandGen
                    | sorterModelType.Msuf4 -> 
                        let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                        msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray 
                        |> sorterModelMaker.SmmMsuf4RandGen
                    | sorterModelType.Msuf6 -> 
                        let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                        msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray 
                        |> sorterModelMaker.SmmMsuf6RandGen

                let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
                let sorterModelSetMaker = sortingModelSetMaker.create 
                                            (sorterModelMaker |> sortingModelMaker.Single)
                                            firstIndex 
                                            sorterCount
                let sortingModelSet = sorterModelSetMaker.MakeSortingModelSet (Rando.create)

                // 4. Saves
                let qpSortingModelSet = makeQueryParamsFromRunParams runParameters (outputDataType.SortingModelSet "") 
                let! _ = db.saveAsync projectFolder qpSortingModelSet (sortingModelSet |> outputData.SortingModelSet) allowOverwrite
            
                progress |> Option.iter (fun p -> 
                    p.Report(sprintf "Saved SortingModelSet %s for run: %s" (%qpSortingModelSet.Id.ToString()) %runId))

                // 5. Final Return
                return runParameters.WithRunFinished (Some true)

            with e -> 
                let runId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Unexpected error in run %s: %s" runId e.Message
                return! async { return Error msg }
        }