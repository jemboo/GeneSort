namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Runs
open GeneSort.Db
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sortable
open GeneSort.SortingOps


module MergeIntEvals =

    let projectName = "MergeIntEvals4"  |> UMX.tag<projectName>
    let projectDesc = "MergeIntEvals4 on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth:int<sortingWidth> option)
            (sorterModelType:sorterModelType option)
            (outputDataType: outputDataType) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> SortingWidth.toString); 
                (runParameters.sorterModelTypeKey, sorterModelType |> SorterModelType.toString);
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            outputDataType



    
    //let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
    //    match %sortingWidth with
    //    | 4 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 6 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 8 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 12 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 16 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 24 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 32 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 48 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 64 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 96 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 128 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 192 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 256 -> (2 * factor) |> UMX.tag<sorterCount>
    //    | 384 -> (2 * factor) |> UMX.tag<sorterCount>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

        
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (10 * factor) |> UMX.tag<sorterCount>
        | 384 -> (4 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 4 -> 6 |> UMX.tag<stageLength>
    //    | 6 -> 8 |> UMX.tag<stageLength>
    //    | 8 -> 20 |> UMX.tag<stageLength>
    //    | 12 -> 35 |> UMX.tag<stageLength>
    //    | 16 -> 80 |> UMX.tag<stageLength>
    //    | 24 -> 180 |> UMX.tag<stageLength>
    //    | 32 -> 300 |> UMX.tag<stageLength>
    //    | 48 -> 800 |> UMX.tag<stageLength>
    //    | 64 -> 1200 |> UMX.tag<stageLength>
    //    | 96 -> 5000 |> UMX.tag<stageLength>
    //    | 128 -> 6000 |> UMX.tag<stageLength>
    //    | 192 -> 15000 |> UMX.tag<stageLength>
    //    | 256 -> 30000 |> UMX.tag<stageLength>
    //    | 384 -> 60000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        

    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 4 -> 6 |> UMX.tag<stageLength>
    //    | 6 -> 8 |> UMX.tag<stageLength>
    //    | 8 -> 20 |> UMX.tag<stageLength>
    //    | 12 -> 35 |> UMX.tag<stageLength>
    //    | 16 -> 80 |> UMX.tag<stageLength>
    //    | 24 -> 180 |> UMX.tag<stageLength>
    //    | 32 -> 300 |> UMX.tag<stageLength>
    //    | 48 -> 800 |> UMX.tag<stageLength>
    //    | 64 -> 1000 |> UMX.tag<stageLength>
    //    | 96 -> 2000 |> UMX.tag<stageLength>
    //    | 128 -> 2500 |> UMX.tag<stageLength>
    //    | 192 -> 4000 |> UMX.tag<stageLength>
    //    | 256 -> 6000 |> UMX.tag<stageLength>
    //    | 384 -> 10000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        
    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 12 -> 300 |> UMX.tag<stageLength>
    //    | 24 -> 1500 |> UMX.tag<stageLength>
    //    | 48 -> 10000 |> UMX.tag<stageLength>
    //    | 96 -> 30000 |> UMX.tag<stageLength>
    //    | 192 -> 15000 |> UMX.tag<stageLength>
    //    | 384 -> 40000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 16 -> 400 |> UMX.tag<stageLength>
        | 24 -> 1800 |> UMX.tag<stageLength>
        | 32 -> 10000 |> UMX.tag<stageLength>
        | 48 -> 15000 |> UMX.tag<stageLength>
        | 64 -> 25000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let sortableArrayDataTypeKeyValues = 
            [ 
                Some sortableDataType.Ints; 
                Some sortableDataType.Bools ] |> List.map(SortableDataType.toString)
  
    let sortableArrayDataTypeKeys () : string*string list =
        (runParameters.sortableDataTypeKey, sortableArrayDataTypeKeyValues )

  
    let sortingWidthValues = 
        [16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      //[4; 6; 8; 12; 16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      // [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())
      //[12; 24; 48; 96;] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let mergeDimensionValues = 
        [2; 4; ] |> List.map(fun d -> d.ToString())


    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)

    let mergeFillTypeValues = 
         [mergeFillType.VanVoorhis;] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)


    let sorterModelKeyValues () : string list =
        [ Some sorterModelType.Mcse;]      |> List.map(SorterModelType.toString)



    //let sorterModelKeyValues () : string list =
    //    [ Some sorterModelKey.Mcse; 
    //      Some sorterModelKey.Mssi;
    //      Some sorterModelKey.Msrs; 
    //      Some sorterModelKey.Msuf4; 
    //      Some sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)


    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let paramMapFilter (runParameters: runParameters) = 
        let sorterModelKey = runParameters.GetSorterModelType().Value
        let sortingWidth = %runParameters.GetSortingWidth().Value
        let has3factor = (sortingWidth % 3 = 0)

        match sorterModelKey with
        | sorterModelType.Mcse -> Some runParameters
        | sorterModelType.Mssi -> Some runParameters
        | sorterModelType.Msrs -> Some runParameters
        | sorterModelType.Msuf4 ->
                if has3factor then None else
                Some runParameters
        | sorterModelType.Msuf6 -> 
                if has3factor then Some runParameters else
                None



    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 


        let enhancer (runParameters : runParameters) : runParameters =
            let queryParams = makeQueryParamsFromRunParams runParameters (outputDataType.RunParameters)
            runParameters.SetId ((queryParams.Id.ToString()) |> UMX.tag<idValue>)

            runParameters.SetRunFinished false
            runParameters.SetProjectName projectName

            let repl = runParameters.GetRepl().Value
            let sortingWidth = runParameters.GetSortingWidth().Value

            let stageLength = getStageLengthForSortingWidth sortingWidth
            runParameters.SetStageLength stageLength

            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            runParameters.SetCeLength ceLength

            let replFactor = 1 // if (%repl = 0) then 10 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor
            runParameters.SetSorterCount sorterCount
            runParameters

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let parameterSpans = 
        [
            sortingWidths(); 
            sorterModelKeys(); 
            sortableArrayDataTypeKeys(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [| 
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker None;
                outputDataType.SorterSet None;
                outputDataType.SorterSetEval None;
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<unit> =

        async {

            let index = runParameters.GetId().Value  
            let repl = runParameters.GetRepl().Value
            let sorterModelKey = runParameters.GetSorterModelType().Value
            let sortingWidth = runParameters.GetSortingWidth().Value
            let stageLength = runParameters.GetStageLength().Value
            let ceLength = runParameters.GetCeLength().Value
            let sorterCount = runParameters.GetSorterCount().Value
            let mergeDimension = runParameters.GetMergeDimension().Value
            let mergeFillType = runParameters.GetMergeFillType().Value
            let sortableDataType = runParameters.GetSortableDataType().Value


            match progress with
            | Some p -> p.Report(sprintf "Executing Run %s_%d  %s" %index %repl (runParameters.toString()))
            | None -> ()
        
            // Check cancellation before starting expensive operations
            cts.Token.ThrowIfCancellationRequested()

            // Create sorter model maker
            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelType.Mcse -> 
                    (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) 
                    |> sorterModelMaker.SmmMsceRandGen
                | sorterModelType.Mssi -> 
                    (MssiRandGen.create randomType sortingWidth stageLength) 
                    |> sorterModelMaker.SmmMssiRandGen
                | sorterModelType.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) 
                    |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelType.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelType.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf6RandGen
        
            match progress with
            | Some p -> p.Report(sprintf "Run %s_%d: Creating sorter set" %index %repl)
            | None -> ()
        
            // Check cancellation before generating sorters
            cts.Token.ThrowIfCancellationRequested()
        
            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet
            let sortableTestModel = msasM.create sortingWidth mergeDimension mergeFillType |> sortableTestModel.MsasMi
            let sortableTests = SortableTestModel.makeSortableTests sortableTestModel sortableDataType

        
            match progress with
            | Some p -> p.Report(sprintf "Run %s_%d: Evaluating sorter set" %index %repl)
            | None -> ()


            let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTests

            cts.Token.ThrowIfCancellationRequested()
            match progress with
            | Some p -> p.Report(sprintf "Run %s_%d: Saving sorterSet test results" %index %repl)
            | None -> ()

            // Save sorter set
            let queryParamsForSorterSet = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSet None) 
            do! db.saveAsync queryParamsForSorterSet (sorterSet |> outputData.SorterSet) allowOverwrite

            // Save sorterSetEval
            let queryParamsForSorterSetEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval None)
            do! db.saveAsync queryParamsForSorterSetEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite

            // Save sorterModelSetMaker
            let queryParamsForSorterModelSetMaker = makeQueryParamsFromRunParams runParameters (outputDataType.SorterModelSetMaker None)
            do! db.saveAsync queryParamsForSorterModelSetMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker) allowOverwrite

            // Mark run as finished
            runParameters.SetRunFinished true
        }