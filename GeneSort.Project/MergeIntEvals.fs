
namespace GeneSort.Project

open System
open System.IO

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Runs.Params
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Rs


open GeneSort.Model.Sorter
open GeneSort.Model.Sortable
open GeneSort.SortingOps
open GeneSort.SortingResults
open GeneSort.SortingOps.Mp
open GeneSort.Model.Sorter.Uf6
open System.Threading
open OutputData
open GeneSort.Runs

module MergeIntEvals = 

    let rootDir = "c:\Projects"
    let getProjectFolder (projectName:string) = 
            Path.Combine(rootDir, projectName) 

    let experimentName = "MergeIntEvals"
    let experimentDesc = "MergeIntEvals on RandomSorters with SortingWidth from 4 to 16 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true

    
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (2 * factor) |> UMX.tag<sorterCount>
        | 384 -> (2 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 7 |> UMX.tag<stageLength>
        | 6 -> 10 |> UMX.tag<stageLength>
        | 8 -> 25 |> UMX.tag<stageLength>
        | 12 -> 40 |> UMX.tag<stageLength>
        | 16 -> 100 |> UMX.tag<stageLength>
        | 24 -> 200 |> UMX.tag<stageLength>
        | 32 -> 400 |> UMX.tag<stageLength>
        | 48 -> 1000 |> UMX.tag<stageLength>
        | 64 -> 2000 |> UMX.tag<stageLength>
        | 96 -> 5000 |> UMX.tag<stageLength>
        | 128 -> 6000 |> UMX.tag<stageLength>
        | 192 -> 15000 |> UMX.tag<stageLength>
        | 256 -> 30000 |> UMX.tag<stageLength>
        | 384 -> 60000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        

    let sortableArrayType = sortableArrayType.Ints
  
    let sortingWidthValues = 
        [32; 48; 64;] |> List.map(fun d -> d.ToString())
       // [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)

    let sorterModelKeyValues () : string list =
        [ sorterModelKey.Mcse; 
          sorterModelKey.Mssi;
          sorterModelKey.Msrs; 
          sorterModelKey.Msuf4; 
          sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let paramMapFilter (runParameters: runParameters) = 
        let sorterModelKey = runParameters.GetSorterModelKey()
        let sortingWidth = %runParameters.GetSortingWidth()
        let has3factor = (sortingWidth % 3 = 0)

        match sorterModelKey with
        | sorterModelKey.Mcse -> Some runParameters
        | sorterModelKey.Mssi -> Some runParameters
        | sorterModelKey.Msrs -> Some runParameters
        | sorterModelKey.Msuf4 ->
                if has3factor then None else
                Some runParameters
        | sorterModelKey.Msuf6 -> 
                if has3factor then Some runParameters else
                None



    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        let mutable index = 0

        let enhancer (runParameters : runParameters) : runParameters =
            let repl = runParameters.GetRepl()
            let sorterModelKey = runParameters.GetSorterModelKey()
            let sortingWidth = runParameters.GetSortingWidth()

            let stageLength = getStageLengthForSortingWidth sortingWidth
            runParameters.SetStageLength stageLength

            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            runParameters.SetCeLength ceLength

            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor
            runParameters.SetSorterCount sorterCount
            runParameters

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = enhancer filtrate.Value
                        retVal.SetIndex (UMX.tag<indexNumber> index)
                        yield filtrate.Value
                        index <- index + 1
        }

    let parameterSet = 
        [ Project.repl1s(); sortingWidths(); sorterModelKeys() ]
        
    let reportNames = [|"Report1"; "Report2"; "Report3"; "Report4"|]

    let project = 
            Project.create 
                experimentName 
                experimentDesc 
                rootDir
                reportNames 
                parameterSet 
                paramMapRefiner


    let executor 
            (workspaceFolder: string)
            (runParameters: runParameters) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string>) : Async<unit> =

        async {

            let index = runParameters.GetIndex()
            let repl = runParameters.GetRepl()  
            let sorterModelKey = runParameters.GetSorterModelKey()
            let sortingWidth = runParameters.GetSortingWidth()
            let stageLength = runParameters.GetStageLength()
            let ceLength = runParameters.GetCeLength()
            let sorterCount = runParameters.GetSorterCount()

            cts.Token.ThrowIfCancellationRequested()
            progress.Report(sprintf "Executing Run %d  %s" index (runParameters.toString()))


            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelKey.Mcse -> (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) |> sorterModelMaker.SmmMsceRandGen
                | sorterModelKey.Mssi -> (MssiRandGen.create randomType sortingWidth stageLength) |> sorterModelMaker.SmmMssiRandGen
                | sorterModelKey.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelKey.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelKey.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) |> sorterModelMaker.SmmMsuf6RandGen


            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

            let sortableTests = SortableTestModel.makeSortableTestsForMerge sortableArrayType sortingWidth
            let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTests

            cts.Token.ThrowIfCancellationRequested()

            do! OutputData.saveToFile workspaceFolder (Some runParameters) (sorterSet |> outputData.SorterSet)
            do! OutputData.saveToFile workspaceFolder (Some runParameters) (sorterSetEval |> outputData.SorterSetEval)
            do! OutputData.saveToFile workspaceFolder (Some runParameters) (sorterModelSetMaker |> outputData.SorterModelSetMaker)

            progress.Report(sprintf "Finished executing Run %d  Cycle  %d \n" index %repl)
        }


    // Executor to generate a report for each SorterTest across all SorterTestSets, one line per SorterTest
    let binReportExecutor 
            (workspaceFolder: string)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string>) : unit =
            try
                progress.Report(sprintf "Generating Bin report in workspace %s"  project.WorkspaceFolder)
                let runParamsA = getRunParametersAsync 
                                    project.WorkspaceFolder
                                    (Some cts.Token) (Some progress) |> Async.RunSynchronously

                let summaries = 
                    runParamsA
                    |> Seq.map (fun runParams ->
                        let ssEvalPath = OutputData.getOutputDataFileName workspaceFolder (Some runParams) outputDataType.SorterSetEval
                        progress.Report (sprintf "Checking for file %s" ssEvalPath)
                        try
                            let swFull = runParams.GetSortingWidth() 
                            let sorterModelKey =  runParams.GetSorterModelKey()
                            let sorterSetEval = getSorterSetEval workspaceFolder runParams
                            let sorterSetEvalBins = SorterSetEvalBins.create 1 sorterSetEval

                            let prpt = SorterSetEvalBins.getBinCountReport sorterSetEvalBins
                            let appended = prpt |> Array.map(fun aa -> (swFull, (sorterModelKey |> SorterModelKey.toString), aa.[0], aa.[1], aa.[2], aa.[3]))
                            appended
                        with e ->
                         failwith (sprintf "Error processing file %s: %s" ssEvalPath e.Message)
                    )   
                    |> Array.concat
                    |> Seq.toList

                // Generate the Markdown report, one line per SorterTest
                let reportContent =
                    [ "# sorterEval Report"
                      sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
                      sprintf "Workspace: %s" project.WorkspaceFolder
                      ""
                      "Sorting Width\t SorterModel\t ceLength\t stageLength\t binCount\t unsortedReport"
                    ]
                    @ (summaries
                       |> List.map (
                            fun (sortingWidth, sorterModelKey, ceLength, stageLength, binCount, unsortedReport) ->
                                    sprintf "%d \t %s \t %s \t %s \t %s \t %s " %sortingWidth sorterModelKey ceLength stageLength binCount unsortedReport))
                    |> String.concat "\n"

                // Save the report to a file
                let reportFilePath = Path.Combine(project.WorkspaceFolder, sprintf "%s_SorterEvalReport_%s.txt" "SorterSetEvalSamples" (DateTime.Now.ToString("yyyyMMdd_HHmmss")))
                File.WriteAllText(reportFilePath, reportContent)

                Console.WriteLine(sprintf "SorterTest bin report saved to %s" reportFilePath)

            with ex ->
                progress.Report(sprintf "Error generating Bin report for %s: %s" "SorterTestSet" ex.Message)
                raise ex



    // Executor to generate a report for each SorterTest across all SorterTestSets, one line per SorterTest
    let ceUseProfileReportExecutor 
                (workspaceFolder: string)
                (cts: CancellationTokenSource) 
                (progress: IProgress<string>) : unit =
            try
                let binCount = 20
                let blockGrowthRate = 1.2

                let runParamsA = getRunParametersAsync 
                                        project.WorkspaceFolder
                                        (Some cts.Token) (Some progress) |> Async.RunSynchronously

                let summaries = 
                    runParamsA
                    |> Seq.map (fun runParams ->
                        let ssEvalPath = OutputData.getOutputDataFileName workspaceFolder (Some runParams) outputDataType.SorterSetEval
                        progress.Report (sprintf "Checking for file %s" ssEvalPath)
                        try
                            let swFull = runParams.GetSortingWidth() 
                            let sorterModelKey =  runParams.GetSorterModelKey()
                            let sorterSetEval = getSorterSetEval workspaceFolder runParams
                            let sorterSetCeUseProfile = SorterSetCeUseProfile.makeSorterSetCeUseProfile binCount blockGrowthRate sorterSetEval
                            let linePrefix = sprintf "%s \t %s" (%swFull.ToString()) (sorterModelKey |> SorterModelKey.toString)

                            SorterSetCeUseProfile.makeCsvLines linePrefix sorterSetCeUseProfile
                        with e ->
                         failwith (sprintf "Error processing file %s: %s" ssEvalPath e.Message)
                    )   
                    |> Array.concat
                    |> Seq.toList


                // Generate the Markdown report, one line per SorterTest
                let reportContent =
                    [ "# sorterCeProfile Report"
                      sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
                      sprintf "Workspace: %s" project.WorkspaceFolder
                      ""
                      "Sorting Width\tSorterModel\tsorterId\tsorterSetId\tsorterTestsId\tlastCe"
                    ]
                    @ summaries
                    |> String.concat "\n"


                // Save the report to a file
                let reportFilePath = Path.Combine(project.WorkspaceFolder, sprintf "SorterCeUseReport_%s.txt" (DateTime.Now.ToString("yyyyMMdd_HHmmss")))
                File.WriteAllText(reportFilePath, reportContent)

                progress.Report(sprintf "Ce Profile report saved to %s" reportFilePath)

            with ex ->
                progress.Report(sprintf "Error generating Ce Profile report for %s: %s" "SorterTestSet" ex.Message)
                raise ex



    // Progress reporter that prints to console
    let progress = 
        { new IProgress<string> with
            member _.Report(msg) = printfn "%s" msg }


    let RunAll() =
        let cts = new CancellationTokenSource()
        WorkspaceOps.executeRunParametersSeq project 8 executor project.RunParametersArray cts progress


    let RunSorterEvalReport() =
        let cts = new CancellationTokenSource()
        (binReportExecutor project.WorkspaceFolder cts progress)
        (ceUseProfileReportExecutor project.WorkspaceFolder cts progress)









