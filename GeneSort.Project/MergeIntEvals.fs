
namespace GeneSort.Project

open System
open System.IO

open FSharp.UMX
open MessagePack
open MessagePack.FSharp
open MessagePack.Resolvers

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Project.Params
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Rs


open GeneSort.Model.Sorter
open GeneSort.Model.Sortable
open GeneSort.SortingOps
open GeneSort.SortingResults
open GeneSort.SortingOps.Mp
open GeneSort.Model.Sorter.Uf6

module MergeIntEvals = 

    let projectDir = "c:\Projects"
    
    let experimentName = "MergeIntEvals"
    let experimentDesc = "MergeIntEvals on RandomSorters with SortingWidth from 4 to 16 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true

    
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (2 * factor) |> UMX.tag<sorterCount>
        | 384 -> (2 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 7 |> UMX.tag<stageLength>
        | 6 -> 10 |> UMX.tag<stageLength>
        | 8 -> 25 |> UMX.tag<stageLength>
        | 12 -> 40 |> UMX.tag<stageLength>
        | 16 -> 100 |> UMX.tag<stageLength>
        | 24 -> 200 |> UMX.tag<stageLength>
        | 32 -> 400 |> UMX.tag<stageLength>
        | 48 -> 1000 |> UMX.tag<stageLength>
        | 64 -> 2000 |> UMX.tag<stageLength>
        | 96 -> 5000 |> UMX.tag<stageLength>
        | 128 -> 6000 |> UMX.tag<stageLength>
        | 192 -> 15000 |> UMX.tag<stageLength>
        | 256 -> 30000 |> UMX.tag<stageLength>
        | 384 -> 60000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        

    let sortableArrayType = sortableArrayType.Ints
  
    let sortingWidthValues = 
        [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)

    let sorterModelKeyValues () : string list =
        [ sorterModelKey.Mcse; 
          sorterModelKey.Mssi;
          sorterModelKey.Msrs; 
          sorterModelKey.Msuf4; 
          sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )

    let paramMapRefiner (runParameters: runParameters) = 
        let sorterModelKey = runParameters.GetSorterModelKey()
        let sortingWidth = %runParameters.GetSortingWidth()
        let has3factor = (sortingWidth % 3 = 0)

        match sorterModelKey with
        | sorterModelKey.Mcse -> Some runParameters
        | sorterModelKey.Mssi -> Some runParameters
        | sorterModelKey.Msrs -> Some runParameters
        | sorterModelKey.Msuf4 ->
                if has3factor then None else
                Some runParameters
        | sorterModelKey.Msuf6 -> 
                if has3factor then Some runParameters else
                None

    let parameterSet = 
        [ sortingWidths(); sorterModelKeys() ]
        
    let reportNames = [|"Report1"; "Report2"; "Report3"; "Report4"|]

    let workspace = 
            Workspace.create 
                experimentName 
                experimentDesc 
                projectDir
                reportNames 
                parameterSet 
                paramMapRefiner


    let executor (workspace: workspace) (repl: int<replNumber>) (run: run) : Async<unit> =
        async {
            Console.WriteLine(sprintf "Executing Run %d  Cycle %d  %A" run.Index %repl (run.RunParameters.toString()))
            run.RunParameters.SetRepl repl

            let sorterModelKey = run.RunParameters.GetSorterModelKey()
            let sortingWidth = run.RunParameters.GetSortingWidth()

            let stageLength = getStageLengthForSortingWidth sortingWidth
            run.RunParameters.SetStageLength stageLength

            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            run.RunParameters.SetCeLength ceLength


            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelKey.Mcse -> (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) |> sorterModelMaker.SmmMsceRandGen
                | sorterModelKey.Mssi -> (MssiRandGen.create randomType sortingWidth stageLength) |> sorterModelMaker.SmmMssiRandGen
                | sorterModelKey.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelKey.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelKey.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) |> sorterModelMaker.SmmMsuf6RandGen

            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor
            run.RunParameters.SetSorterCount sorterCount

            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

            let sortableTests = SortableTestModel.makeSortableTestsForMerge sortableArrayType sortingWidth
            let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTests

            do! OutputData.saveToFileO workspace run.RunParameters (sorterSet |> outputData.SorterSet)
            do! OutputData.saveToFileO workspace run.RunParameters (sorterSetEval |> outputData.SorterSetEval)
            do! OutputData.saveToFileO workspace run.RunParameters (sorterModelSetMaker |> outputData.SorterModelSetMaker)

            Console.WriteLine(sprintf "Finished executing Run %d  Cycle  %d \n" run.Index %repl)
        }


    //// Executor to generate a report for each SorterTest across all SorterTestSets, one line per SorterTest
    //let evalReportExecutor (workspace: workspace) =
    //        try
    //            Console.WriteLine(sprintf "Generating SorterEval report in workspace %s"  workspace.WorkspaceFolder)
    //            let sorterSetEvalSamplesFolder = OutputData.getOutputDataFolder workspace outputDataType.SorterSetEval
    //            if not (Directory.Exists sorterSetEvalSamplesFolder) then
    //                failwith (sprintf "Output folder %s does not exist" sorterSetEvalSamplesFolder)

    //            // Find all .msgpack files in the output folder
    //            let files = Directory.GetFiles(sorterSetEvalSamplesFolder, "*.msgpack")

    //            // Initialize the MessagePack resolver
    //            let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    //            let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)


    //            // Process each file and collect data for each SorterTest
    //            let summaries : (string*string*string*string*string) list =
    //                files
    //                |> Seq.map (
    //                    fun ssEvalPath ->
    //                        try
    //                            use ssEvalStream = new FileStream(ssEvalPath, FileMode.Open, FileAccess.Read, FileShare.Read)
    //                            let ssEvalDto = MessagePackSerializer.Deserialize<sorterSetEvalDto>(ssEvalStream, options)
    //                            let sorterSetEval = SorterSetEvalDto.toDomain ssEvalDto  
                                                                
    //                            let runParams = OutputData.getRunParametersForOutputDataPath ssEvalPath
    //                            let sorterModelKey = // runParams[Run.sorterModelTypeKey]
    //                            let swFull = // runParams[Run.sortingWidthKey]
    //                            let cycle = runParams[Run.cycleKey]
    //                            let sortableArrayType = runParams[Run.sortableArrayTypeKey]

    //                            let prpt = sorterSetEval.SorterEvals |> Array.map (fun se -> SorterEval.reportLine se)
    //                            let appended = prpt |> Array.map(fun aa -> (cycle, swFull, sorterModelKey, sortableArrayType, aa))
    //                            appended
    //                        with e ->
    //                            failwith (sprintf "Error processing file %s: %s" ssEvalPath e.Message)
    //                )
    //                |> Array.concat
    //                |> Seq.toList


    //            // Generate the Markdown report, one line per SorterTest
    //            let reportContent =
    //                [ "# sorterEval Report"
    //                  sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
    //                  sprintf "Workspace: %s" workspace.WorkspaceFolder
    //                  ""
    //                  sprintf "Cycle\t Sorting Width\t SorterModel\t SortableArrayType\t %s" SorterEval.reportHeader
    //                ]
    //                @ (summaries
    //                   |> List.map (
    //                        fun (cycle, sortingWidth, sorterModelKey, sortableArrayType, evalReport) ->
    //                                sprintf "%s \t%s \t%s \t%s \t%s" cycle sortingWidth sorterModelKey sortableArrayType evalReport))
    //                |> String.concat "\n"


    //            // Save the report to a file
    //            let reportFilePath = Path.Combine(workspace.WorkspaceFolder, sprintf "%s_%s.txt" "SorterEvalSamples" (DateTime.Now.ToString("yyyyMMdd_HHmmss")))
    //            File.WriteAllText(reportFilePath, reportContent)

    //            Console.WriteLine(sprintf "SorterTest count report saved to %s" reportFilePath)
    //        with ex ->
    //            Console.WriteLine(sprintf "Error generating SorterTest count report for %s: %s" "SorterTestSet" ex.Message)
    //            raise ex




    //// Executor to generate a report for each SorterTest across all SorterTestSets, one line per SorterTest
    //let binReportExecutor (workspace: workspace) =
    //        try
    //            Console.WriteLine(sprintf "Generating SorterEval report in workspace %s"  workspace.WorkspaceFolder)
    //            let sorterSetEvalSamplesFolder = OutputData.getOutputDataFolder workspace outputDataType.SorterSetEval
    //            if not (Directory.Exists sorterSetEvalSamplesFolder) then
    //                failwith (sprintf "Output folder %s does not exist" sorterSetEvalSamplesFolder)

    //            // Find all .msgpack files in the output folder
    //            let files = Directory.GetFiles(sorterSetEvalSamplesFolder, "*.msgpack")

    //            // Initialize the MessagePack resolver
    //            let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    //            let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)


    //            // Process each file and collect data for each SorterTest
    //            let summaries : (string*string*string*string*string*string*string*string) list =
    //                files
    //                |> Seq.map (
    //                    fun ssEvalPath ->
    //                        try
    //                            use ssEvalStream = new FileStream(ssEvalPath, FileMode.Open, FileAccess.Read, FileShare.Read)
    //                            let ssEvalDto = MessagePackSerializer.Deserialize<sorterSetEvalDto>(ssEvalStream, options)
    //                            let sorterSetEval = SorterSetEvalDto.toDomain ssEvalDto          
    //                            let sorterSetEvalBins = SorterSetEvalBins.create 1 sorterSetEval

    //                            let runParams = OutputData.getRunParametersForOutputDataPath ssEvalPath
    //                            let sorterModelKey = runParams["SorterModel"]
    //                            let swFull = runParams["SortingWidth"]
    //                            let cycle = runParams[Run.cycleKey]
    //                            let sortableArrayType = runParams["SortableArrayType"]

    //                            let prpt = SorterSetEvalBins.getBinCountReport sorterSetEvalBins
    //                            let appended = prpt |> Array.map(fun aa -> (cycle, swFull, sorterModelKey, sortableArrayType, aa.[0], aa.[1], aa.[2], aa.[3]))
    //                            appended
    //                        with e ->
    //                            failwith (sprintf "Error processing file %s: %s" ssEvalPath e.Message)
    //                )
    //                |> Array.concat
    //                |> Seq.toList

    //            // Generate the Markdown report, one line per SorterTest
    //            let reportContent =
    //                [ "# sorterEval Report"
    //                  sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
    //                  sprintf "Workspace: %s" workspace.WorkspaceFolder
    //                  ""
    //                  "Cycle\t Sorting Width\t SorterModel\t SortableArrayType\t  ceLength\t stageLength\t binCount\t unsortedReport"
    //                ]
    //                @ (summaries
    //                   |> List.map (
    //                        fun (cycle, sortingWidth, sorterModelKey, sortableArrayType, ceLength, stageLength, binCount, unsortedReport) ->
    //                                sprintf "%s \t %s \t %s \t  %s \t %s \t %s \t %s \t %s " cycle sortingWidth sorterModelKey sortableArrayType ceLength stageLength binCount unsortedReport))
    //                |> String.concat "\n"

    //            // Save the report to a file
    //            let reportFilePath = Path.Combine(workspace.WorkspaceFolder, sprintf "%s_SorterEvalReport_%s.txt" "SorterSetEvalSamples" (DateTime.Now.ToString("yyyyMMdd_HHmmss")))
    //            File.WriteAllText(reportFilePath, reportContent)

    //            Console.WriteLine(sprintf "SorterTest count report saved to %s" reportFilePath)
    //        with ex ->
    //            Console.WriteLine(sprintf "Error generating SorterTest count report for %s: %s" "SorterTestSet" ex.Message)
    //            raise ex


    // Executor to generate a report for each SorterTest across all SorterTestSets, one line per SorterTest
    //let ceUseProfileReportExecutor (workspace: workspace) =
    //        try
    //            let binCount = 20
    //            let blockGrowthRate = 1.2
    //            Console.WriteLine(sprintf "Generating Ce Profile report in workspace %s"  workspace.WorkspaceFolder)
    //            let sorterSetEvalSamplesFolder = OutputData.getOutputDataFolder workspace outputDataType.SorterSetEval
    //            if not (Directory.Exists sorterSetEvalSamplesFolder) then
    //                failwith (sprintf "Output folder %s does not exist" sorterSetEvalSamplesFolder)

    //            // Find all .msgpack files in the output folder
    //            let files = Directory.GetFiles(sorterSetEvalSamplesFolder, "*.msgpack")

    //            // Initialize the MessagePack resolver
    //            let resolver = CompositeResolver.Create(FSharpResolver.Instance, StandardResolver.Instance)
    //            let options = MessagePackSerializerOptions.Standard.WithResolver(resolver)
                
    //            let summaries : string list =
    //                files
    //                |> Seq.map (
    //                    fun ssEvalPath ->
    //                        try
    //                            use ssEvalStream = new FileStream(ssEvalPath, FileMode.Open, FileAccess.Read, FileShare.Read)
    //                            let ssEvalDto = MessagePackSerializer.Deserialize<sorterSetEvalDto>(ssEvalStream, options)
    //                            let sorterSetEval = SorterSetEvalDto.toDomain ssEvalDto     
    //                            let sorterSetCeUseProfile = SorterSetCeUseProfile.makeSorterSetCeUseProfile binCount blockGrowthRate sorterSetEval
  
    //                            let runParams = OutputData.getRunParametersForOutputDataPath ssEvalPath
    //                            let sorterModelKey =   runParams.GetSorterModelKey() 
    //                            let swFull = runParams.GetSortingWidth() 

    //                            let linePrefix = sprintf "%s \t %s" (%swFull.ToString()) (sorterModelKey |> SorterModelKey.toString)
    //                            SorterSetCeUseProfile.makeCsvLines linePrefix sorterSetCeUseProfile
    //                        with e ->
    //                            failwith (sprintf "Error processing file %s: %s" ssEvalPath e.Message)
    //                )
    //                |> Array.concat
    //                |> Seq.toList

    //            // Generate the Markdown report, one line per SorterTest
    //            let reportContent =
    //                [ "# sorterCeProfile Report"
    //                  sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
    //                  sprintf "Workspace: %s" workspace.WorkspaceFolder
    //                  ""
    //                  "Sorting Width\tSorterModel\tsorterId\tsorterSetId\tsorterTestsId\tlastCe"
    //                ]
    //                @ summaries
    //                |> String.concat "\n"


    //            // Save the report to a file
    //            let reportFilePath = Path.Combine(workspace.WorkspaceFolder, sprintf "SorterCeUseReport_%s.txt" (DateTime.Now.ToString("yyyyMMdd_HHmmss")))
    //            File.WriteAllText(reportFilePath, reportContent)

    //            Console.WriteLine(sprintf "Ce Profile report saved to %s" reportFilePath)
    //        with ex ->
    //            Console.WriteLine(sprintf "Error generating Ce Profile report for %s: %s" "SorterTestSet" ex.Message)
    //            raise ex



    let RunAll() =
        for i in 0 .. 0 do
            let repl = i |> UMX.tag<replNumber>
            WorkspaceOps.executeWorkspace workspace repl 8 executor


    //let RunSorterEvalReport() =
    ////     (binReportExecutor workspace)
    //   (ceUseProfileReportExecutor workspace)









