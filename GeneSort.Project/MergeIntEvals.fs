namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorting
open GeneSort.Runs
open GeneSort.Db
open GeneSort.SortingOps
open ProjectOps
open GeneSort.Model.Sorter


module MergeIntEvals =

    let projectName = "MergeIntEvals"  |> UMX.tag<projectName>
    let projectFolder = "MergeIntEvals" |> UMX.tag<projectFolder>
    let projectDesc = "MergeIntEvals on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (outputDataType: outputDataType)
            (sortingWidth: int<sortingWidth> option)
            (sorterModelType: sorterModelType option)
            (sortableDataFormat: sortableDataFormat option)
            (mergeDimension: int<mergeDimension> option)
            (mergeFillType: mergeSuffixType option) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> UmxExt.intToString ); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
                (runParameters.mergeDimensionKey, mergeDimension |> UmxExt.intToString );
                (runParameters.mergeSuffixTypeKey, mergeFillType |> Option.map MergeFillType.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType)  =
        makeQueryParams
            (runParams.GetRepl())
            outputDataType
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataFormat())
            (runParams.GetMergeDimension())
            (runParams.GetMergeSuffixType())



    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Mcse -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
         
    let mergeDimensionDividesSortingWidth (rp: runParameters) =
        let sw = rp.GetSortingWidth().Value
        let md = rp.GetMergeDimension().Value
        if (%sw % %md = 0) then Some rp else None
           
    let limitForMergeFillType (rp: runParameters) =
        let sw = rp.GetSortingWidth().Value
        let ft = rp.GetMergeSuffixType().Value
        if (ft.IsNoSuffix && %sw > 64) then None else Some rp

    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth
        |> Option.bind limitForMergeFillType
        |> Option.bind mergeDimensionDividesSortingWidth


    // --- Project Refinement ---
    let enhancer (rp : runParameters) : runParameters =
        let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)

        rp.WithProjectName(Some projectName)
            .WithRunFinished(Some false)
            .WithId (Some qp.Id )


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let sortableDataTypes () : string*string list =
        let values = [ 
                        //sortableDataFormat.IntArray; 
                        //sortableDataFormat.BoolArray;
                        sortableDataFormat.Int8Vector512;
                        //sortableDataFormat.BitVector512
                     ] |> List.map(SortableDataFormat.toString)
        (runParameters.sortableDataFormatKey, values )

  
    let sortingWidths () : string * string list =
        //let values = [16; 18; 24; 32; 36; 48; 64; 96; 128; 192; 256] |> List.map string
        let values = [ 16; 32;]  |> List.map string
        (runParameters.sortingWidthKey, values)


    let mergeDimensions () : string * string list =
      //let values = [2; 3; 4; 6; 8 ] |> List.map string
        let values = [2; 3;] |> List.map string
        (runParameters.mergeDimensionKey, values)


    let mergeFillTypes () : string * string list =
        let values = [ 
                        mergeSuffixType.NoSuffix; 
                        mergeSuffixType.VV_1 
                     ] |> List.map MergeFillType.toString
        (runParameters.mergeSuffixTypeKey, values)


    let sorterModelTypes () : string*string list =
        let values =         
            [ sorterModelType.Mcse; 
              sorterModelType.Mssi;
              sorterModelType.Msrs; 
              sorterModelType.Msuf4; 
           //   sorterModelType.Msuf6;
              ]  |> List.map(SorterModelType.toString)
        (runParameters.sorterModelTypeKey, values )


    let parameterSpans = 
        [
            sortingWidths(); 
            sorterModelTypes(); 
            sortableDataTypes(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [| 
                outputDataType.RunParameters;
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) runId %repl)

                // 2. Safe Param Extraction
                let! (repl, width, mDim, mFill, dType, sModel) = 
                    maybe {
                        let! r = runParameters.GetRepl()
                        let! w = runParameters.GetSortingWidth()
                        let! dt = runParameters.GetSortableDataFormat()
                        let! md = runParameters.GetMergeDimension()
                        let! mf = runParameters.GetMergeSuffixType()
                        let! sm = runParameters.GetSorterModelType()
                        return (r, w, md, mf, dt, sm)
                    } |> Result.ofOption "Missing domain parameters"

                // 3. Load Sortable Tests (Cross-project query) (MergeTests are all repl 0)
                let qpTests = SortableMergeTests.makeQueryParams 
                                            (Some (0 |> UMX.tag<replNumber>)) 
                                            (Some width) 
                                            (Some mDim) 
                                            (Some mFill) 
                                            (Some dType) 
                                            (outputDataType.SortableTest "")

                let! rawTestData = db.loadAsync SortableMergeTests.projectFolder qpTests 
                let! sortableTest = rawTestData |> OutputData.asSortableTest

                //// 4. Load Sorter Set (Cross-project query)
                //let qpSorters = RandomSorters.makeQueryParams (Some repl) (Some width) (Some sModel) (outputDataType.SorterSet "")
                //let! rawSorterData = db.loadAsync RandomSorters.projectFolder qpSorters
                //let! sorterSet = rawSorterData |> OutputData.asSorterSet

                // 4. Load SortingModelSet (Cross-project query)
                let qpSorterModelSet = RandomSorters.makeQueryParams (Some repl) (Some width) (Some sModel) (outputDataType.SortingModelSet "")
                let! smsOutput = db.loadAsync RandomSorters.projectFolder qpSorterModelSet
                let! sortingModelSet = smsOutput |> OutputData.asSortingModelSet

                // 5. Computation
                let sorterSet = SortingModelSet.makeSorterSet sortingModelSet
                let! _ = checkCancellation cts.Token
                let sorterSetEval = SorterModelSetEval.makeSorterSetEval sorterSet sortableTest false

                // 6. Save
                let! _ = checkCancellation cts.Token
                let qpEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                let! _ = db.saveAsync projectFolder qpEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite
                let qpSorterSetPass = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSet "Pass")
                let passingSorterSet = 
                    SorterModelSetEval.makePassingSorterSet sorterSet sorterSetEval
                let! _ = db.saveAsync projectFolder qpSorterSetPass (passingSorterSet |> outputData.SorterSet) allowOverwrite

                // 7. Success
                return runParameters.WithRunFinished (Some true)

            with e ->
                let runId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Fatal error in Run %s: %s" runId e.Message
            
                // Bypass the builder's ReturnFrom ambiguity by wrapping manually
                return! async { return Error msg }
        }