
namespace GeneSort.Project.Old

open System

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Runs.Params


open GeneSort.Runs
open System.Threading
open GeneSort.Db
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sortable
open GeneSort.SortingOps
open GeneSort.SortingResults


module MergeIntEvals =

    let projectName = "MergeIntEvals"  |> UMX.tag<projectName>
    let experimentDesc = "MergeIntEvals on RandomSorters with SortingWidth from 4 to 16 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true

    
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (2 * factor) |> UMX.tag<sorterCount>
        | 384 -> (2 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 7 |> UMX.tag<stageLength>
        | 6 -> 10 |> UMX.tag<stageLength>
        | 8 -> 25 |> UMX.tag<stageLength>
        | 12 -> 40 |> UMX.tag<stageLength>
        | 16 -> 100 |> UMX.tag<stageLength>
        | 24 -> 200 |> UMX.tag<stageLength>
        | 32 -> 400 |> UMX.tag<stageLength>
        | 48 -> 1000 |> UMX.tag<stageLength>
        | 64 -> 2000 |> UMX.tag<stageLength>
        | 96 -> 5000 |> UMX.tag<stageLength>
        | 128 -> 6000 |> UMX.tag<stageLength>
        | 192 -> 15000 |> UMX.tag<stageLength>
        | 256 -> 30000 |> UMX.tag<stageLength>
        | 384 -> 60000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        

    let sortableArrayType = sortableArrayType.Ints
  
    let sortingWidthValues = 
        [32; 48; 64;] |> List.map(fun d -> d.ToString())
       // [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)

    let sorterModelKeyValues () : string list =
        [ Some sorterModelKey.Mcse; 
          Some sorterModelKey.Mssi;
          Some sorterModelKey.Msrs; 
          Some sorterModelKey.Msuf4; 
          Some sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let paramMapFilter (runParameters: runParameters) = 
        let sorterModelKey = runParameters.GetSorterModelKey().Value
        let sortingWidth = %runParameters.GetSortingWidth().Value
        let has3factor = (sortingWidth % 3 = 0)

        match sorterModelKey with
        | sorterModelKey.Mcse -> Some runParameters
        | sorterModelKey.Mssi -> Some runParameters
        | sorterModelKey.Msrs -> Some runParameters
        | sorterModelKey.Msuf4 ->
                if has3factor then None else
                Some runParameters
        | sorterModelKey.Msuf6 -> 
                if has3factor then Some runParameters else
                None



    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        let mutable index = 0

        let enhancer (runParameters : runParameters) : runParameters =
            runParameters.SetRunFinished false
            runParameters.SetProjectName projectName

            let repl = runParameters.GetRepl().Value
            let sortingWidth = runParameters.GetSortingWidth().Value

            let stageLength = getStageLengthForSortingWidth sortingWidth
            runParameters.SetStageLength stageLength

            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            runParameters.SetCeLength ceLength

            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor
            runParameters.SetSorterCount sorterCount
            runParameters

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = enhancer filtrate.Value
                        retVal.SetIndex (UMX.tag<indexNumber> index)
                        yield filtrate.Value
                        index <- index + 1
        }

    let parameterSet = 
        [ Project.repl1s(); sortingWidths(); sorterModelKeys() ]
        
    let reportNames = [|"Report1"; "Report2"; "Report3"; "Report4"|]

    let project = 
            Project.create 
                projectName 
                experimentDesc
                reportNames 
                parameterSet 
                paramMapRefiner


    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<unit> =

        async {
            let projectName = runParameters.GetProjectName().Value
            let index = runParameters.GetIndex().Value  
            let repl = runParameters.GetRepl().Value
            let sorterModelKey = runParameters.GetSorterModelKey().Value
            let sortingWidth = runParameters.GetSortingWidth().Value
            let stageLength = runParameters.GetStageLength().Value
            let ceLength = runParameters.GetCeLength().Value
            let sorterCount = runParameters.GetSorterCount().Value
        
            match progress with
            | Some p -> p.Report(sprintf "Executing Run %d_%d  %s" index %repl (runParameters.toString()))
            | None -> ()
        
            // Check cancellation before starting expensive operations
            cts.Token.ThrowIfCancellationRequested()

            // Create sorter model maker
            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelKey.Mcse -> 
                    (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) 
                    |> sorterModelMaker.SmmMsceRandGen
                | sorterModelKey.Mssi -> 
                    (MssiRandGen.create randomType sortingWidth stageLength) 
                    |> sorterModelMaker.SmmMssiRandGen
                | sorterModelKey.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) 
                    |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelKey.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelKey.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf6RandGen
        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Creating sorter set" index %repl)
            | None -> ()
        
            // Check cancellation before generating sorters
            cts.Token.ThrowIfCancellationRequested()
        
            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet
            let sortableTests = SortableTestModel.makeSortableTestsForMerge sortableArrayType sortingWidth

        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Evaluating sorter set" index %repl)
            | None -> ()


            let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTests

            cts.Token.ThrowIfCancellationRequested()
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Saving sorterSet test results" index %repl)
            | None -> ()

            // Save sorter set
            let queryParamsForSorterSet = queryParams.createFromRunParams outputDataType.SorterSet runParameters
            do! db.saveAsync queryParamsForSorterSet (sorterSet |> outputData.SorterSet)

            // Save sorterSetEval
            let queryParamsForSorterSetEval = queryParams.createFromRunParams outputDataType.SorterSetEval runParameters
            do! db.saveAsync queryParamsForSorterSetEval (sorterSetEval |> outputData.SorterSetEval)

            // Save sorterModelSetMaker
            let queryParamsForSorterModelSetMaker = 
                queryParams.createFromRunParams outputDataType.SorterModelSetMaker runParameters
            do! db.saveAsync queryParamsForSorterModelSetMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker)

            // Mark run as finished
            runParameters.SetRunFinished true
        
            match progress with
            | Some p -> p.Report(sprintf "✓ Finished executing Run %d_%d" index %repl)
            | None -> ()
        }



    let binReportExecutor
            (db: IGeneSortDb)
            (projectName: string<projectName>) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<unit> =

        async {
            match progress with
            | Some p -> p.Report(sprintf "Making performace bin report for project: %s" %projectName)
            | None -> ()

            let! runParamsResult = db.getAllProjectRunParametersAsync projectName (Some cts.Token) progress
            let runParamsArray =
                match runParamsResult with
                | Ok rpArray -> rpArray
                | Error msg -> failwithf "Error retrieving RunParameters for project %s: %s" %projectName msg

            let dataTableFile1 = 
                        DataTableFile.create "SorterEval_Bin_Report" 
                                [| "Sorting Width"; "SorterModel"; "ceLength"; "stageLength"; "binCount"; "unsortedReport" |]
                                |> DataTableFile.addSource (sprintf "Generated: %s" (DateTime.Now.ToLongTimeString()))
                                |> DataTableFile.addSource (sprintf "Sources (%d):" runParamsArray.Length)



            let csvRows = (RunParameters.makeIndexAndReplTable runParamsArray) |> RunParameters.tableToTabDelimited


            let dataTableFile2 = DataTableFile.addSources csvRows dataTableFile1

            let queryParams = queryParams.createForTextReport projectName ("SorterEval_Bin_Report" |> UMX.tag<textReportName> )
            let outputData =  dataTableFile2 |> outputData.TextReport
            do! db.saveAsync queryParams outputData

                
            //let summaries =
            //    runParamsArray
            //    |> Seq.map (fun runParams ->
            //        dataTable
            //        let queryParamsForSorterSetEval = queryParams.createFromRunParams outputDataType.SorterSetEval runParams
            //        let sorterModelKey =  runParams.GetSorterModelKey()
            //        let swFull = runParams.GetSortingWidth() 
            //        let sorterSetEval = 
            //            match db.loadAsync queryParamsForSorterSetEval outputDataType.SorterSetEval 
            //                    |> Async.RunSynchronously with
            //            | Ok (SorterSetEval sse) -> sse
            //            | Ok _ -> failwith (sprintf "Unexpected output data type for SorterSetEval")
            //            | Error err -> failwith (sprintf "Error loading SorterSetEval: %s" err)
            //        let sorterSetEvalBins = SorterSetEvalBins.create 1 sorterSetEval
            //        let prpt = SorterSetEvalBins.getBinCountReport sorterSetEvalBins
            //        let appended = prpt |> Array.map(fun aa -> (swFull, (sorterModelKey |> SorterModelKey.toString), aa.[0], aa.[1], aa.[2], aa.[3]))
            //        appended
            //    )   
            //    |> Array.concat
            //    |> Seq.toList

            //db.saveAsync (queryParams.create(
            //        Some projectName,
            //        None,
            //        None,
            //        None,
            //        outputDataType.TextReport))
            //    ( 
            //        let reportContent =
            //            [ "# sorterEval Report"
            //              sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
            //              sprintf "Project: %s" %projectName
            //              ""
            //              "Sorting Width\t SorterModel\t ceLength\t stageLength\t binCount\t unsortedReport"
            //            ]
            //            @ (summaries
            //               |> List.map (
            //                    fun (sortingWidth, sorterModelKey, ceLength, stageLength, binCount, unsortedReport) ->
            //                            sprintf "%d \t %s \t %s \t %s \t %s \t %s " %(sortingWidth.Value) sorterModelKey ceLength stageLength binCount unsortedReport))
            //            |> String.concat "\n"
            //        reportContent |> outputData.TextReport
            //    )
            //    |> Async.RunSynchronously

            return ()
        }



    //let binReportExecutor
    //        (db: IGeneSortDb)
    //        (projectName: string<projectName>) 
    //        (cts: CancellationTokenSource) 
    //        (progress: IProgress<string> option) : Async<unit> =

    //    async {
    //        match progress with
    //        | Some p -> p.Report(sprintf "Making performace bin report for project: %s" %projectName)
    //        | None -> ()

    //        let! runParamsResult = db.getAllProjectRunParametersAsync projectName (Some cts.Token) progress
    //        let runParamsArray =
    //            match runParamsResult with
    //            | Ok rpArray -> rpArray
    //            | Error msg -> failwithf "Error retrieving RunParameters for project %s: %s" %projectName msg


    //        let summaries = 
    //            runParamsArray
    //            |> Seq.map (fun runParams ->

    //                let queryParamsForSorterSetEval = queryParams.createFromRunParams outputDataType.SorterSetEval runParams
    //                let sorterModelKey =  runParams.GetSorterModelKey()
    //                let swFull = runParams.GetSortingWidth() 
    //                let sorterSetEval = 
    //                    match db.loadAsync queryParamsForSorterSetEval outputDataType.SorterSetEval 
    //                            |> Async.RunSynchronously with
    //                    | Ok (SorterSetEval sse) -> sse
    //                    | Ok _ -> failwith (sprintf "Unexpected output data type for SorterSetEval")
    //                    | Error err -> failwith (sprintf "Error loading SorterSetEval: %s" err)
    //                let sorterSetEvalBins = SorterSetEvalBins.create 1 sorterSetEval
    //                let prpt = SorterSetEvalBins.getBinCountReport sorterSetEvalBins
    //                let appended = prpt |> Array.map(fun aa -> (swFull, (sorterModelKey |> SorterModelKey.toString), aa.[0], aa.[1], aa.[2], aa.[3]))
    //                appended
    //            )   
    //            |> Array.concat
    //            |> Seq.toList

    //        db.saveAsync (queryParams.create(
    //                Some projectName,
    //                None,
    //                None,
    //                None,
    //                outputDataType.TextReport))
    //            ( 
    //                let reportContent =
    //                    [ "# sorterEval Report"
    //                      sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
    //                      sprintf "Project: %s" %projectName
    //                      ""
    //                      "Sorting Width\t SorterModel\t ceLength\t stageLength\t binCount\t unsortedReport"
    //                    ]
    //                    @ (summaries
    //                       |> List.map (
    //                            fun (sortingWidth, sorterModelKey, ceLength, stageLength, binCount, unsortedReport) ->
    //                                    sprintf "%d \t %s \t %s \t %s \t %s \t %s " %(sortingWidth.Value) sorterModelKey ceLength stageLength binCount unsortedReport))
    //                    |> String.concat "\n"
    //                reportContent |> outputData.TextReport
    //            )
    //            |> Async.RunSynchronously

    //        return ()
    //    }


    //// Executor to generate a report for each SorterTest across all SorterTestSets, one line per SorterTest
    //let ceUseProfileReportExecutor 
    //            (projectFolder: string)
    //            (cts: CancellationTokenSource) 
    //            (progress: IProgress<string>) : unit =
    //        try
    //            let binCount = 20
    //            let blockGrowthRate = 1.2

    //            let runParamsA = OutputDataFile2.getAllRunParametersAsync 
    //                                    projectFolder
    //                                    (Some cts.Token) (Some progress) |> Async.RunSynchronously

    //            let summaries = 
    //                runParamsA
    //                |> Seq.map (fun runParams ->
    //                    let ssEvalPath = OutputDataFile2.getAllOutputDataFilePaths projectFolder (Some runParams) outputDataType.SorterSetEval
    //                    progress.Report (sprintf "Checking for file %s" ssEvalPath)
    //                    try
    //                        let swFull = runParams.GetSortingWidth() 
    //                        let sorterModelKey =  runParams.GetSorterModelKey()
    //                        let sorterSetEval = (OutputDataFile2.getSorterSetEvalAsync projectFolder runParams)
    //                                            |> MonadUtils.getValue
    //                        let sorterSetCeUseProfile = SorterSetCeUseProfile.makeSorterSetCeUseProfile binCount blockGrowthRate sorterSetEval
    //                        let linePrefix = sprintf "%s \t %s" (%swFull.ToString()) (sorterModelKey |> SorterModelKey.toString)

    //                        SorterSetCeUseProfile.makeCsvLines linePrefix sorterSetCeUseProfile
    //                    with e ->
    //                     failwith (sprintf "Error processing file %s: %s" ssEvalPath e.Message)
    //                )   
    //                |> Array.concat
    //                |> Seq.toList


    //            // Generate the Markdown report, one line per SorterTest
    //            let reportContent =
    //                [ "# sorterCeProfile Report"
    //                  sprintf "Generated on %s" (DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"))
    //                  sprintf "Project: %s" project.ProjectName
    //                  ""
    //                  "Sorting Width\tSorterModel\tsorterId\tsorterSetId\tsorterTestsId\tlastCe"
    //                ]
    //                @ summaries
    //                |> String.concat "\n"


    //            // Save the report to a file
    //            let reportFilePath = Path.Combine(projectFolder, sprintf "SorterCeUseReport_%s.txt" (DateTime.Now.ToString("yyyyMMdd_HHmmss")))
    //            File.WriteAllText(reportFilePath, reportContent)

    //            progress.Report(sprintf "Ce Profile report saved to %s" reportFilePath)

    //        with ex ->
    //            progress.Report(sprintf "Error generating Ce Profile report for %s: %s" "SorterTestSet" ex.Message)
    //            raise ex











