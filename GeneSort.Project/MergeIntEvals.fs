namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Runs
open GeneSort.Db
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sortable
open GeneSort.SortingOps


module MergeIntEvals =

    let projectName = "MergeIntEvals"  |> UMX.tag<projectName>
    let projectDesc = "MergeIntEvals on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (outputDataType: outputDataType)
            (sortingWidth: int<sortingWidth> option)
            (sorterModelType: sorterModelType option)
            (sortableDataType: sortableDataType option)
            (mergeDimension: int<mergeDimension> option)
            (mergeFillType: mergeFillType option) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> SortingWidth.toString); 
                (runParameters.sorterModelTypeKey, sorterModelType |> SorterModelType.toString);
                (runParameters.sortableDataTypeKey, sortableDataType |> SortableDataType.toString);
                (runParameters.mergeDimensionKey, mergeDimension |> MergeDimension.toString);
                (runParameters.mergeFillTypeKey, mergeFillType |> MergeFillType.toString);
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType)  =
        makeQueryParams
            (runParams.GetRepl())
            outputDataType
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataType())
            (runParams.GetMergeDimension())
            (runParams.GetMergeFillType())



    
    //let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
    //    match %sortingWidth with
    //    | 4 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 6 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 8 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 12 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 16 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 24 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 32 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 48 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 64 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 96 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 128 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 192 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 256 -> (2 * factor) |> UMX.tag<sorterCount>
    //    | 384 -> (2 * factor) |> UMX.tag<sorterCount>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

        
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (10 * factor) |> UMX.tag<sorterCount>
        | 384 -> (4 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 4 -> 6 |> UMX.tag<stageLength>
    //    | 6 -> 8 |> UMX.tag<stageLength>
    //    | 8 -> 20 |> UMX.tag<stageLength>
    //    | 12 -> 35 |> UMX.tag<stageLength>
    //    | 16 -> 80 |> UMX.tag<stageLength>
    //    | 24 -> 180 |> UMX.tag<stageLength>
    //    | 32 -> 300 |> UMX.tag<stageLength>
    //    | 48 -> 800 |> UMX.tag<stageLength>
    //    | 64 -> 1200 |> UMX.tag<stageLength>
    //    | 96 -> 5000 |> UMX.tag<stageLength>
    //    | 128 -> 6000 |> UMX.tag<stageLength>
    //    | 192 -> 15000 |> UMX.tag<stageLength>
    //    | 256 -> 30000 |> UMX.tag<stageLength>
    //    | 384 -> 60000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        

    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 4 -> 6 |> UMX.tag<stageLength>
    //    | 6 -> 8 |> UMX.tag<stageLength>
    //    | 8 -> 20 |> UMX.tag<stageLength>
    //    | 12 -> 35 |> UMX.tag<stageLength>
    //    | 16 -> 80 |> UMX.tag<stageLength>
    //    | 24 -> 180 |> UMX.tag<stageLength>
    //    | 32 -> 300 |> UMX.tag<stageLength>
    //    | 48 -> 800 |> UMX.tag<stageLength>
    //    | 64 -> 1000 |> UMX.tag<stageLength>
    //    | 96 -> 2000 |> UMX.tag<stageLength>
    //    | 128 -> 2500 |> UMX.tag<stageLength>
    //    | 192 -> 4000 |> UMX.tag<stageLength>
    //    | 256 -> 6000 |> UMX.tag<stageLength>
    //    | 384 -> 10000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        
    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 12 -> 300 |> UMX.tag<stageLength>
    //    | 24 -> 1500 |> UMX.tag<stageLength>
    //    | 48 -> 10000 |> UMX.tag<stageLength>
    //    | 96 -> 30000 |> UMX.tag<stageLength>
    //    | 192 -> 15000 |> UMX.tag<stageLength>
    //    | 384 -> 40000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 16 -> 400 |> UMX.tag<stageLength>
        | 24 -> 1800 |> UMX.tag<stageLength>
        | 32 -> 10000 |> UMX.tag<stageLength>
        | 48 -> 15000 |> UMX.tag<stageLength>
        | 64 -> 25000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let sortableDataTypeKeyValues = 
            [ 
                Some sortableDataType.Ints; 
                Some sortableDataType.Bools ] |> List.map(SortableDataType.toString)
  
    let sortableDataTypeKeys () : string*string list =
        (runParameters.sortableDataTypeKey, sortableDataTypeKeyValues )

  
    let sortingWidthValues = 
        [16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      //[4; 6; 8; 12; 16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      // [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())
      //[12; 24; 48; 96;] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let mergeDimensionValues = 
        [2; 4; ] |> List.map(fun d -> d.ToString())


    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)

    let mergeFillTypeValues = 
         [mergeFillType.VanVoorhis;] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)


    let sorterModelKeyValues () : string list =
        [ Some sorterModelType.Mcse;]      |> List.map(SorterModelType.toString)



    //let sorterModelKeyValues () : string list =
    //    [ Some sorterModelKey.Mcse; 
    //      Some sorterModelKey.Mssi;
    //      Some sorterModelKey.Msrs; 
    //      Some sorterModelKey.Msuf4; 
    //      Some sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)


    let sorterModelTypeKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )

    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Mcse -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth



    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor

            rp.WithProjectName(projectName)
              .WithRunFinished(false)
              .WithCeLength(ceLength)
              .WithStageLength(stageLength)
              .WithSorterCount(sorterCount)
              .WithId (qp.Id.ToString() |> UMX.tag<idValue>)

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }


    let parameterSpans = 
        [
            sortingWidths(); 
            sorterModelTypeKeys(); 
            sortableDataTypeKeys(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [| 
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes




    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup
                let! _ = checkCancellation cts.Token
                let runId = runParameters.GetId() |> Option.defaultValue (% "unknown")
                progress |> Option.iter (fun p -> p.Report(sprintf "Starting Run %s" %runId))

                // 2. Safe Param Extraction
                // Note: No async.Return needed anymore because of the Bind overload
                let! (repl, width, mDim, mFill, dType, sModel) = 
                    maybe {
                        let! r = runParameters.GetRepl()
                        let! w = runParameters.GetSortingWidth()
                        let! dt = runParameters.GetSortableDataType()
                        let! md = runParameters.GetMergeDimension()
                        let! mf = runParameters.GetMergeFillType()
                        let! sm = runParameters.GetSorterModelType()
                        return (r, w, md, mf, dt, sm)
                    } |> Result.ofOption "Missing domain parameters"

                // 3. Load Sortable Tests (Cross-project query)
                let qpTests = SortableIntMerges.makeQueryParams (Some repl) (Some width) (Some mDim) (Some mFill) (Some dType) (outputDataType.SortableTest "")
                let! rawTestData = db.loadAsync qpTests 
                let! sortableTest = rawTestData |> OutputData.asSortableTest

                // 4. Load Sorter Set (Cross-project query)
                let qpSorters = RandomSorters4to64.makeQueryParams (Some repl) (Some width) (Some sModel) (outputDataType.SorterSet "")
                let! rawSorterData = db.loadAsync qpSorters
                let! sorterSet = rawSorterData |> OutputData.asSorterSet

                // 5. Computation
                let! _ = checkCancellation cts.Token
                let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTest

                // 6. Save
                let! _ = checkCancellation cts.Token
                let qpEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                let! _ = db.saveAsync qpEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite

                // 7. Success
                progress |> Option.iter (fun p -> p.Report(sprintf "Run %s completed." %runId))
                return runParameters.WithRunFinished true

            with e ->
                let rawId = runParameters.GetId() |> Option.map UMX.untag |> Option.defaultValue "unknown"
                let msg = sprintf "Fatal error in Run %s: %s" rawId e.Message
            
                // Bypass the builder's ReturnFrom ambiguity by wrapping manually
                return! async { return Error msg }
        }