namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Runs
open GeneSort.Db
open GeneSort.SortingOps
open ProjectOps


module MergeIntEvals =

    let projectName = "MergeIntEvals"  |> UMX.tag<projectName>
    let projectFolder = "MergeIntEvals" |> UMX.tag<projectFolder>
    let projectDesc = "MergeIntEvals on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (outputDataType: outputDataType)
            (sortingWidth: int<sortingWidth> option)
            (sorterModelType: sorterModelType option)
            (sortableDataType: sortableDataType option)
            (mergeDimension: int<mergeDimension> option)
            (mergeFillType: mergeFillType option) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> UmxExt.intToString ); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
                (runParameters.sortableDataTypeKey, sortableDataType |> Option.map SortableDataType.toString |> UmxExt.stringToString );
                (runParameters.mergeDimensionKey, mergeDimension |> UmxExt.intToString );
                (runParameters.mergeFillTypeKey, mergeFillType |> Option.map MergeFillType.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType)  =
        makeQueryParams
            (runParams.GetRepl())
            outputDataType
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataType())
            (runParams.GetMergeDimension())
            (runParams.GetMergeFillType())

        
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (10 * factor) |> UMX.tag<sorterCount>
        | 384 -> (4 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 16 -> 400 |> UMX.tag<stageLength>
        | 24 -> 1800 |> UMX.tag<stageLength>
        | 32 -> 10000 |> UMX.tag<stageLength>
        | 48 -> 15000 |> UMX.tag<stageLength>
        | 64 -> 25000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let sortableDataTypeKeyValues = 
            [ 
                sortableDataType.Ints; 
                sortableDataType.Bools ] |> List.map(SortableDataType.toString)
  
    let sortableDataTypeKeys () : string*string list =
        (runParameters.sortableDataTypeKey, sortableDataTypeKeyValues )

  
    let sortingWidthValues = 
        [16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      //[4; 6; 8; 12; 16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      // [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())
      //[12; 24; 48; 96;] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let mergeDimensionValues = 
        [2; 4; ] |> List.map(fun d -> d.ToString())


    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)

    let mergeFillTypeValues = 
         [mergeFillType.VanVoorhis;] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)


    let sorterModelKeyValues () : string list =
        [ sorterModelType.Mcse;]      |> List.map(SorterModelType.toString)

    let sorterModelTypeKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )

    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Mcse -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth



    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor

            rp.WithProjectName(Some projectName)
              .WithRunFinished(Some false)
              .WithCeLength(Some ceLength)
              .WithStageLength(Some stageLength)
              .WithSorterCount(Some sorterCount)
              .WithId (Some qp.Id )

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }


    let parameterSpans = 
        [
            sortingWidths(); 
            sorterModelTypeKeys(); 
            sortableDataTypeKeys(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [| 
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) runId %repl)

                // 2. Safe Param Extraction
                let! (repl, width, mDim, mFill, dType, sModel) = 
                    maybe {
                        let! r = runParameters.GetRepl()
                        let! w = runParameters.GetSortingWidth()
                        let! dt = runParameters.GetSortableDataType()
                        let! md = runParameters.GetMergeDimension()
                        let! mf = runParameters.GetMergeFillType()
                        let! sm = runParameters.GetSorterModelType()
                        return (r, w, md, mf, dt, sm)
                    } |> Result.ofOption "Missing domain parameters"

                // 3. Load Sortable Tests (Cross-project query)
                let qpTests = SortableIntMerges.makeQueryParams 
                                            (Some repl) 
                                            (Some width) 
                                            (Some mDim) 
                                            (Some mFill) 
                                            (Some dType) 
                                            (outputDataType.SortableTest "")

                let! rawTestData = db.loadAsync SortableIntMerges.projectFolder qpTests 
                let! sortableTest = rawTestData |> OutputData.asSortableTest

                // 4. Load Sorter Set (Cross-project query)
                let qpSorters = RandomSorters4to64.makeQueryParams (Some repl) (Some width) (Some sModel) (outputDataType.SorterSet "")
                let! rawSorterData = db.loadAsync RandomSorters4to64.projectFolder qpSorters
                let! sorterSet = rawSorterData |> OutputData.asSorterSet

                // 5. Computation
                let! _ = checkCancellation cts.Token
                let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTest

                // 6. Save
                let! _ = checkCancellation cts.Token
                let qpEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                let! _ = db.saveAsync projectFolder qpEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite

                // 7. Success
                report progress (sprintf "%s Finished Run %s Repl %d" (MathUtils.getTimestampString()) %runId %repl)
                return runParameters.WithRunFinished (Some true)

            with e ->
                let runId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Fatal error in Run %s: %s" runId e.Message
            
                // Bypass the builder's ReturnFrom ambiguity by wrapping manually
                return! async { return Error msg }
        }