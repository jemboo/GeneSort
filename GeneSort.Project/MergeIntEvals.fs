namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Runs
open GeneSort.Db
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sortable
open GeneSort.SortingOps


module MergeIntEvals =

    let projectName = "MergeIntEvals"  |> UMX.tag<projectName>
    let projectDesc = "MergeIntEvals on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (outputDataType: outputDataType)
            (sortingWidth: int<sortingWidth> option)
            (sorterModelType: sorterModelType option)
            (sortableDataType: sortableDataType option)
            (mergeDimension: int<mergeDimension> option)
            (mergeFillType: mergeFillType option) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> SortingWidth.toString); 
                (runParameters.sorterModelTypeKey, sorterModelType |> SorterModelType.toString);
                (runParameters.sortableDataTypeKey, sortableDataType |> SortableDataType.toString);
                (runParameters.mergeDimensionKey, mergeDimension |> MergeDimension.toString);
                (runParameters.mergeFillTypeKey, mergeFillType |> MergeFillType.toString);
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType)  =
        makeQueryParams
            (runParams.GetRepl())
            outputDataType
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataType())
            (runParams.GetMergeDimension())
            (runParams.GetMergeFillType())



    
    //let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
    //    match %sortingWidth with
    //    | 4 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 6 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 8 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 12 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 16 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 24 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 32 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 48 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 64 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 96 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 128 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 192 -> (10 * factor) |> UMX.tag<sorterCount>
    //    | 256 -> (2 * factor) |> UMX.tag<sorterCount>
    //    | 384 -> (2 * factor) |> UMX.tag<sorterCount>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

        
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (10 * factor) |> UMX.tag<sorterCount>
        | 384 -> (4 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 4 -> 6 |> UMX.tag<stageLength>
    //    | 6 -> 8 |> UMX.tag<stageLength>
    //    | 8 -> 20 |> UMX.tag<stageLength>
    //    | 12 -> 35 |> UMX.tag<stageLength>
    //    | 16 -> 80 |> UMX.tag<stageLength>
    //    | 24 -> 180 |> UMX.tag<stageLength>
    //    | 32 -> 300 |> UMX.tag<stageLength>
    //    | 48 -> 800 |> UMX.tag<stageLength>
    //    | 64 -> 1200 |> UMX.tag<stageLength>
    //    | 96 -> 5000 |> UMX.tag<stageLength>
    //    | 128 -> 6000 |> UMX.tag<stageLength>
    //    | 192 -> 15000 |> UMX.tag<stageLength>
    //    | 256 -> 30000 |> UMX.tag<stageLength>
    //    | 384 -> 60000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        

    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 4 -> 6 |> UMX.tag<stageLength>
    //    | 6 -> 8 |> UMX.tag<stageLength>
    //    | 8 -> 20 |> UMX.tag<stageLength>
    //    | 12 -> 35 |> UMX.tag<stageLength>
    //    | 16 -> 80 |> UMX.tag<stageLength>
    //    | 24 -> 180 |> UMX.tag<stageLength>
    //    | 32 -> 300 |> UMX.tag<stageLength>
    //    | 48 -> 800 |> UMX.tag<stageLength>
    //    | 64 -> 1000 |> UMX.tag<stageLength>
    //    | 96 -> 2000 |> UMX.tag<stageLength>
    //    | 128 -> 2500 |> UMX.tag<stageLength>
    //    | 192 -> 4000 |> UMX.tag<stageLength>
    //    | 256 -> 6000 |> UMX.tag<stageLength>
    //    | 384 -> 10000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)
        
    //let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
    //    match %sortingWidth with
    //    | 12 -> 300 |> UMX.tag<stageLength>
    //    | 24 -> 1500 |> UMX.tag<stageLength>
    //    | 48 -> 10000 |> UMX.tag<stageLength>
    //    | 96 -> 30000 |> UMX.tag<stageLength>
    //    | 192 -> 15000 |> UMX.tag<stageLength>
    //    | 384 -> 40000 |> UMX.tag<stageLength>
    //    | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 16 -> 400 |> UMX.tag<stageLength>
        | 24 -> 1800 |> UMX.tag<stageLength>
        | 32 -> 10000 |> UMX.tag<stageLength>
        | 48 -> 15000 |> UMX.tag<stageLength>
        | 64 -> 25000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

    let sortableDataTypeKeyValues = 
            [ 
                Some sortableDataType.Ints; 
                Some sortableDataType.Bools ] |> List.map(SortableDataType.toString)
  
    let sortableDataTypeKeys () : string*string list =
        (runParameters.sortableDataTypeKey, sortableDataTypeKeyValues )

  
    let sortingWidthValues = 
        [16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      //[4; 6; 8; 12; 16; 24; 32; 48; 64;] |> List.map(fun d -> d.ToString())
      // [32; 48; 64; 96; 128; 192; 256; 384] |> List.map(fun d -> d.ToString())
      //[12; 24; 48; 96;] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let mergeDimensionValues = 
        [2; 4; ] |> List.map(fun d -> d.ToString())


    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)

    let mergeFillTypeValues = 
         [mergeFillType.VanVoorhis;] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)


    let sorterModelKeyValues () : string list =
        [ Some sorterModelType.Mcse;]      |> List.map(SorterModelType.toString)



    //let sorterModelKeyValues () : string list =
    //    [ Some sorterModelKey.Mcse; 
    //      Some sorterModelKey.Mssi;
    //      Some sorterModelKey.Msrs; 
    //      Some sorterModelKey.Msuf4; 
    //      Some sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)


    let sorterModelTypeKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )

    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Mcse -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth



    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor

            rp.WithProjectName(projectName)
              .WithRunFinished(false)
              .WithCeLength(ceLength)
              .WithStageLength(stageLength)
              .WithSorterCount(sorterCount)
              .WithId (qp.Id.ToString() |> UMX.tag<idValue>)

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }


    let parameterSpans = 
        [
            sortingWidths(); 
            sorterModelTypeKeys(); 
            sortableDataTypeKeys(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [| 
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        async {
            try
                // 1. Safe extraction of IDs
                let runId = runParameters.GetId() |> Option.defaultValue (% (sprintf "unknown_%O" (Guid.NewGuid())))
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
            
                progress |> Option.iter (fun p -> p.Report(sprintf "Executing Run %s, Repl %d:\n  %s" %runId %repl (runParameters.toString())))
                cts.Token.ThrowIfCancellationRequested()

                // 2. Safe extraction of all domain parameters
                let domainParams = maybe {
                    let! sorterModelKey = runParameters.GetSorterModelType()
                    let! sortingWidth = runParameters.GetSortingWidth()
                    let! stageLength = runParameters.GetStageLength()
                    let! ceLength = runParameters.GetCeLength()
                    let! sorterCount = runParameters.GetSorterCount()
                    let! mergeDim = runParameters.GetMergeDimension()
                    let! mergeFill = runParameters.GetMergeFillType()
                    let! sortableDataType = runParameters.GetSortableDataType()
                    return (sorterModelKey, sortingWidth, stageLength, ceLength, sorterCount, mergeDim, mergeFill, sortableDataType)
                }

                match domainParams with
                | None -> return Error (sprintf "Run %s, Repl %d: Missing one or more required parameters in paramMap" %runId %repl)
                | Some (sorterModelKey, sortingWidth, stageLength, ceLength, sorterCount, mergeDimension, mergeFillType, sortableDataType) ->


                    // 3. Sorter Generation Logic
                    let sorterModelMaker =
                        match sorterModelKey with
                        | sorterModelType.Mcse -> (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) |> sorterModelMaker.SmmMsceRandGen
                        | sorterModelType.Mssi -> (MssiRandGen.create randomType sortingWidth stageLength) |> sorterModelMaker.SmmMssiRandGen
                        | sorterModelType.Msrs -> 
                            let rates = OpsGenRatesArray.createUniform %stageLength
                            (msrsRandGen.create randomType sortingWidth rates) |> sorterModelMaker.SmmMsrsRandGen
                        | sorterModelType.Msuf4 -> 
                            let rates = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                            (msuf4RandGen.create randomType sortingWidth stageLength rates) |> sorterModelMaker.SmmMsuf4RandGen
                        | sorterModelType.Msuf6 -> 
                            let rates = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                            (msuf6RandGen.create randomType sortingWidth stageLength rates) |> sorterModelMaker.SmmMsuf6RandGen
            
                    let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
                    let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
                    let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
                    let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

                    // 4. Sortable Test & Eval Logic
                    let sortableTestModel = msasM.create sortingWidth mergeDimension mergeFillType |> sortableTestModel.MsasMi
                    let sortableTests = SortableTestModel.makeSortableTests sortableTestModel sortableDataType
                    let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTests

                    cts.Token.ThrowIfCancellationRequested()

                    // 5. Sequential Saves (Atomic Flow)
                    // Save SorterSet
                    let qpSS = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSet "") 
                    let! res1 = db.saveAsync qpSS (sorterSet |> outputData.SorterSet) allowOverwrite
                    match res1 with
                    | Error e -> return Error (sprintf "Failed SorterSet save: %s" e)
                    | Ok () ->
                    
                        // Save SorterSetEval
                        let qpEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                        let! res2 = db.saveAsync qpEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite
                        match res2 with
                        | Error e -> return Error (sprintf "Failed SorterSetEval save: %s" e)
                        | Ok () ->

                            // Save SorterModelSetMaker
                            let qpMaker = makeQueryParamsFromRunParams runParameters (outputDataType.SorterModelSetMaker "")
                            let! res3 = db.saveAsync qpMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker) allowOverwrite
                            match res3 with
                            | Error e -> return Error (sprintf "Failed SorterModelSetMaker save: %s" e)
                            | Ok () ->
                                progress |> Option.iter (fun p -> p.Report(sprintf "Run %s finished successfully." %runId))
                                // Final Success Return
                                return Ok (runParameters.WithRunFinished true)

            with e -> 
                let rawId = runParameters.GetId() |> Option.map UMX.untag |> Option.defaultValue "unknown"
                return Error (sprintf "Unexpected error in run %s: %s" rawId e.Message)
        }

    let executor2
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        async {
            try
                // 1. Safe extraction of IDs
                let runId = runParameters.GetId() |> Option.defaultValue (% (sprintf "unknown_%O" (Guid.NewGuid())))
                let repl = runParameters.GetRepl() |> Option.defaultValue (0 |> UMX.tag)
                            
                progress |> Option.iter (fun p -> p.Report(sprintf "Executing Run %s, Repl %d:\n  %s" %runId %repl (runParameters.toString())))
                cts.Token.ThrowIfCancellationRequested()

                // 2. Safe extraction of all domain parameters
                let domainParams = maybe {
                    let! sorterModelKey = runParameters.GetSorterModelType()
                    let! sortingWidth = runParameters.GetSortingWidth()
                    let! stageLength = runParameters.GetStageLength()
                    let! ceLength = runParameters.GetCeLength()
                    let! sorterCount = runParameters.GetSorterCount()
                    let! mergeDim = runParameters.GetMergeDimension()
                    let! mergeFill = runParameters.GetMergeFillType()
                    let! sortableDataType = runParameters.GetSortableDataType()
                    return (sorterModelKey, sortingWidth, stageLength, ceLength, sorterCount, mergeDim, mergeFill, sortableDataType)
                }

                match domainParams with
                | None -> return Error (sprintf "Run %s: Missing one or more required parameters in paramMap" %runId)
                | Some (sorterModelKey, sortingWidth, stageLength, ceLength, sorterCount, mergeDimension, mergeFillType, sortableDataType) ->

                    // 3. Load merge type SortableTests
                    let queryParamsForSortableTests = SortableIntMerges.makeQueryParamsFromRunParams runParameters (outputDataType.SortableTest "")
                    let! loadResult = db.loadAsync queryParamsForSortableTests
            
                    return! match loadResult with
                            | Error err -> async { return Error (sprintf "SortableTests Load failed: %s" err) }
                            | Ok (outputData.SortableTest sortableTest) -> 
                                async {

                                    // 3. Save Results
                                    let queryParamsSoratbleTest = makeQueryParamsFromRunParams runParameters (outputDataType.SortableTest "")
                                    let! saveResult = db.saveAsync queryParamsSoratbleTest (sortableTest |> outputData.SortableTest) allowOverwrite
                            
                                    match saveResult with
                                    | Ok _ -> return Ok (runParameters.WithRunFinished true)
                                    | Error err -> return Error (sprintf "Save results failed: %s" err)
                                }
                            | Ok _ -> async { return Error "Unexpected data type loaded from DB" }

            with e -> 
                return Error (sprintf "Execution exception: %s" e.Message)
        }