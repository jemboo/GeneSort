namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorting
open GeneSort.Runs
open GeneSort.Db
open GeneSort.SortingOps
open ProjectOps


module MergeIntQa =

    let projectName = "MergeIntQa"  |> UMX.tag<projectName>
    let projectFolder = "MergeIntQa"  |> UMX.tag<projectFolder>
    let projectDesc = "MergeIntQa on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth: int<sortingWidth> option)
            (sorterModelType: sorterModelType option)
            (sortableDataFormat: sortableDataFormat option)
            (mergeDimension: int<mergeDimension> option)
            (mergeFillType: mergeFillType option)
            (outputDataType: outputDataType) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> UmxExt.intToString ); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
                (runParameters.sortableDataFormatKey, sortableDataFormat |> Option.map SortableDataFormat.toString |> UmxExt.stringToString );
                (runParameters.mergeDimensionKey, mergeDimension |> UmxExt.intToString );
                (runParameters.mergeFillTypeKey, mergeFillType |> Option.map MergeFillType.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataFormat())
            (runParams.GetMergeDimension())
            (runParams.GetMergeFillType())
            outputDataType

        
    let getSorterCountForSortingWidth (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> 10 |> UMX.tag<sorterCount>
        | 6 -> 10 |> UMX.tag<sorterCount>
        | 8 -> 10 |> UMX.tag<sorterCount>
        | 9 -> 10 |> UMX.tag<sorterCount>
        | 12 -> 10 |> UMX.tag<sorterCount>
        | 16 -> 10 |> UMX.tag<sorterCount>
        | 18 -> 10 |> UMX.tag<sorterCount>
        | 24 -> 10 |> UMX.tag<sorterCount>
        | 32 -> 10 |> UMX.tag<sorterCount>
        | 36 -> 10 |> UMX.tag<sorterCount>
        | 48 -> 10 |> UMX.tag<sorterCount>
        | 64 -> 10 |> UMX.tag<sorterCount>
        | 96 -> 10 |> UMX.tag<sorterCount>
        | 128 -> 10 |> UMX.tag<sorterCount>
        | 192 -> 10 |> UMX.tag<sorterCount>
        | 256 -> 10 |> UMX.tag<sorterCount>
        | 384 -> 4 |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 50 |> UMX.tag<stageLength>
        | 6 -> 75 |> UMX.tag<stageLength>
        | 8 -> 100 |> UMX.tag<stageLength>
        | 9 -> 120 |> UMX.tag<stageLength>
        | 12 -> 150 |> UMX.tag<stageLength>
        | 16 -> 200 |> UMX.tag<stageLength>
        | 18 -> 230 |> UMX.tag<stageLength>
        | 24 -> 300 |> UMX.tag<stageLength>
        | 32 -> 450 |> UMX.tag<stageLength>
        | 36 -> 500 |> UMX.tag<stageLength>
        | 48 -> 800 |> UMX.tag<stageLength>
        | 64 -> 1000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    // sortableDataFormat
    let sortableDataFormatKeyValues = 
            [ 
                sortableDataFormat.IntArray; 
                sortableDataFormat.BoolArray;
                sortableDataFormat.Int8Vector256 
            ] |> List.map(SortableDataFormat.toString)
  
    let sortableDataFormatKeys () : string*string list =
        (runParameters.sortableDataFormatKey, sortableDataFormatKeyValues )


    // sortingWidth
    let sortingWidthValues = 
        [16; 18; 24; 32; 36; 48; 64] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    // mergeDimension
    let mergeDimensionValues = 
        [2; 3; 4;] |> List.map(fun d -> d.ToString())

    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)


    // mergeFillType
    let mergeFillTypeValues = 
         [mergeFillType.VanVoorhis; mergeFillType.NoFill] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)



    let paramMapFilter (runParameters: runParameters) = 
        Some runParameters


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth |> (*) replFactor

            rp.WithProjectName(Some projectName)
              .WithRunFinished(Some false)
              .WithCeLength(Some ceLength)
              .WithStageLength(Some stageLength)
              .WithSorterCount(Some sorterCount)
              .WithSorterModelType(Some sorterModelType.Mcse)
              .WithId (Some qp.Id )

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let parameterSpans = 
        [
            sortingWidths();
            sortableDataFormatKeys(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [|  
                outputDataType.RunParameters;
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) runId %repl)

                // 2. Safe Param Extraction
                let! (repl, sortingWidth, mergeDimension, mergeFillType, sortableDataFormat, sModel, stageLength, ceLength, sorterCount) = 
                    maybe {
                        let! r = runParameters.GetRepl()
                        let! w = runParameters.GetSortingWidth()
                        let! dt = runParameters.GetSortableDataFormat()
                        let! md = runParameters.GetMergeDimension()
                        let! mf = runParameters.GetMergeFillType()
                        let! sm = runParameters.GetSorterModelType()
                        let! sl = runParameters.GetStageLength()
                        let! ce = runParameters.GetCeLength()
                        let! sc = runParameters.GetSorterCount()
                        return (r, w, md, mf, dt, sm, sl, ce, sc)
                    } |> Result.ofOption "Missing domain parameters"


                // 3. Load Sortable Tests (Cross-project query)
                let rpl0 = 0 |> UMX.tag<replNumber>
                let qpTests = SortableIntMerges.makeQueryParams 
                                        (Some rpl0) 
                                        (Some sortingWidth) 
                                        (Some mergeDimension) 
                                        (Some mergeFillType) 
                                        (Some sortableDataFormat) 
                                        (outputDataType.SortableTest "")

                // 4. Load Sorter Set (Cross-project query)
                let qpSorters = RandomSorters.makeQueryParams 
                                        (Some repl) 
                                        (Some sortingWidth) 
                                        (Some sModel) 
                                        (outputDataType.SorterSet "")
                let! rawSorterData = db.loadAsync RandomSorters.projectFolder qpSorters
                let! sorterSet = rawSorterData |> OutputData.asSorterSet
                let! rawTestData = db.loadAsync SortableIntMerges.projectFolder qpTests 
                let! sortableTest = rawTestData |> OutputData.asSortableTest

                let! _ = checkCancellation cts.Token

                // 5. Computation
                let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTest false
                
                report progress (sprintf "%s Saving sorterSet test results %s repl %d" (MathUtils.getTimestampString()) runId %repl)
                let! _ = checkCancellation cts.Token

                // 6. Save
                let queryParamsForSorterSetEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                let! _ = db.saveAsync projectFolder queryParamsForSorterSetEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite

                // 7. Success
                return runParameters.WithRunFinished (Some true)



            with e ->
                let runId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Fatal error in Run %s: %s" runId e.Message
            
                return! async { return Error msg }
        
        }