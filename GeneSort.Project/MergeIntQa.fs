namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Runs
open GeneSort.Db
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sortable
open GeneSort.SortingOps
open ProjectOps


module MergeIntQa =

    let projectName = "MergeIntQa"  |> UMX.tag<projectName>
    let projectFolder = "MergeIntQa"  |> UMX.tag<projectFolder>
    let projectDesc = "MergeIntQa on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true

    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth: int<sortingWidth> option)
            (sorterModelType: sorterModelType option)
            (sortableDataType: sortableDataType option)
            (mergeDimension: int<mergeDimension> option)
            (mergeFillType: mergeFillType option)
            (outputDataType: outputDataType) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> UmxExt.intToString ); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
                (runParameters.sortableDataTypeKey, sortableDataType |> Option.map SortableDataType.toString |> UmxExt.stringToString );
                (runParameters.mergeDimensionKey, mergeDimension |> UmxExt.intToString );
                (runParameters.mergeFillTypeKey, mergeFillType |> Option.map MergeFillType.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataType())
            (runParams.GetMergeDimension())
            (runParams.GetMergeFillType())
            outputDataType

        
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 9 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (10 * factor) |> UMX.tag<sorterCount>
        | 384 -> (4 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 50 |> UMX.tag<stageLength>
        | 6 -> 75 |> UMX.tag<stageLength>
        | 8 -> 100 |> UMX.tag<stageLength>
        | 9 -> 120 |> UMX.tag<stageLength>
        | 12 -> 150 |> UMX.tag<stageLength>
        | 16 -> 200 |> UMX.tag<stageLength>
        | 24 -> 300 |> UMX.tag<stageLength>
        | 32 -> 450 |> UMX.tag<stageLength>
        | 48 -> 800 |> UMX.tag<stageLength>
        | 64 -> 1000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)



    let sortableArrayDataTypeKeyValues = 
            [ 
                sortableDataType.Ints; 
                sortableDataType.Bools ] |> List.map(SortableDataType.toString)
  
    let sortableArrayDataTypeKeys () : string*string list =
        (runParameters.sortableDataTypeKey, sortableArrayDataTypeKeyValues )



    let sortingWidthValues = 
        [16; 18; 24; 32; 36; 48; 64] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)

    let mergeDimensionValues = 
        [2; 3; 4; 6; 8 ] |> List.map(fun d -> d.ToString())

    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)


    let mergeFillTypeValues = 
         [mergeFillType.VanVoorhis; mergeFillType.NoFill] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)


    let sorterModelKeyValues () : string list =
        [ sorterModelType.Mcse;]      |> List.map(SorterModelType.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let paramMapFilter (runParameters: runParameters) = 
        Some runParameters


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor

            rp.WithProjectName(Some projectName)
              .WithRunFinished(Some false)
              .WithCeLength(Some ceLength)
              .WithStageLength(Some stageLength)
              .WithSorterCount(Some sorterCount)
              .WithId (Some qp.Id )

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let parameterSpans = 
        [
            sortingWidths(); 
            sorterModelKeys(); 
            sortableArrayDataTypeKeys(); 
            mergeDimensions(); 
            mergeFillTypes(); 
        ]
        
    let outputDataTypes = 
            [|  
                outputDataType.RunParameters;              
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) runId %repl)

                // 2. Safe Param Extraction
                let! (repl, sortingWidth, mergeDimension, mergeFillType, sortableDataType, sModel, stageLength, ceLength, sorterCount) = 
                    maybe {
                        let! r = runParameters.GetRepl()
                        let! w = runParameters.GetSortingWidth()
                        let! dt = runParameters.GetSortableDataType()
                        let! md = runParameters.GetMergeDimension()
                        let! mf = runParameters.GetMergeFillType()
                        let! sm = runParameters.GetSorterModelType()
                        let! sl = runParameters.GetStageLength()
                        let! ce = runParameters.GetCeLength()
                        let! sc = runParameters.GetSorterCount()
                        return (r, w, md, mf, dt, sm, sl, ce, sc)
                    } |> Result.ofOption "Missing domain parameters"


                // 3. Load Sortable Tests (Cross-project query)
                let qpTests = SortableIntMerges.makeQueryParams 
                                        (Some repl) 
                                        (Some sortingWidth) 
                                        (Some mergeDimension) 
                                        (Some mergeFillType) 
                                        (Some sortableDataType) 
                                        (outputDataType.SortableTest "")

                let! rawTestData = db.loadAsync SortableIntMerges.projectFolder qpTests 
                let! sortableTest = rawTestData |> OutputData.asSortableTest

                // 4. Make the sorterSet
                let sorterModelMaker =
                    match sModel with
                    | sorterModelType.Mcse -> 
                        (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) 
                        |> sorterModelMaker.SmmMsceRandGen
                    | sorterModelType.Mssi -> 
                        (MssiRandGen.create randomType sortingWidth stageLength) 
                        |> sorterModelMaker.SmmMssiRandGen
                    | sorterModelType.Msrs -> 
                        let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                        (msrsRandGen.create randomType sortingWidth opsGenRatesArray) 
                        |> sorterModelMaker.SmmMsrsRandGen
                    | sorterModelType.Msuf4 -> 
                        let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                        (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) 
                        |> sorterModelMaker.SmmMsuf4RandGen
                    | sorterModelType.Msuf6 -> 
                        let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                        (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) 
                        |> sorterModelMaker.SmmMsuf6RandGen
        
                let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
                let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
                let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
                let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

                let! _ = checkCancellation cts.Token

                // 5. Computation
                let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTest
                
                report progress (sprintf "%s Saving sorterSet test results %s repl %d" (MathUtils.getTimestampString()) runId %repl)
                let! _ = checkCancellation cts.Token

                // 6. Save

                // Save sorter set
                let queryParamsForSorterSet = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSet "")
                let! _ = db.saveAsync projectFolder queryParamsForSorterSet (sorterSet |> outputData.SorterSet) allowOverwrite

                // Save sorterSetEval
                let queryParamsForSorterSetEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                let! _ = db.saveAsync projectFolder queryParamsForSorterSetEval (sorterSetEval |> outputData.SorterSetEval) allowOverwrite

                // Save sorterModelSetMaker
                let queryParamsForSorterModelSetMaker = makeQueryParamsFromRunParams runParameters (outputDataType.SorterModelSetMaker "")
                let! _ = db.saveAsync projectFolder queryParamsForSorterModelSetMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker) allowOverwrite


                // 7. Success
                report progress (sprintf "%s Finished Run %s Repl %d" (MathUtils.getTimestampString()) %runId %repl)
                return runParameters.WithRunFinished (Some true)



            with e ->
                let runId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Fatal error in Run %s: %s" runId e.Message
            
                // Bypass the builder's ReturnFrom ambiguity by wrapping manually
                return! async { return Error msg }
        
        }