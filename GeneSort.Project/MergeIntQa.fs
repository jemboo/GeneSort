namespace GeneSort.Project

open System

open FSharp.UMX
open System.Threading

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Sorter.Sortable
open GeneSort.Runs
open GeneSort.Db
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Uf6
open GeneSort.Model.Sortable
open GeneSort.SortingOps


module MergeIntQa =

    let projectName = "MergeIntQa2"  |> UMX.tag<projectName>
    let projectDesc = "MergeIntQa on RandomSorters with SortingWidth from 16 to 64 generated by Msce, Mssi, Msrs, and Msuf"

    let randomType = rngType.Lcg
    let excludeSelfCe = true

        
    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 9 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (10 * factor) |> UMX.tag<sorterCount>
        | 24 -> (10 * factor) |> UMX.tag<sorterCount>
        | 32 -> (10 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | 128 -> (10 * factor) |> UMX.tag<sorterCount>
        | 192 -> (10 * factor) |> UMX.tag<sorterCount>
        | 256 -> (10 * factor) |> UMX.tag<sorterCount>
        | 384 -> (4 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 50 |> UMX.tag<stageLength>
        | 6 -> 75 |> UMX.tag<stageLength>
        | 8 -> 100 |> UMX.tag<stageLength>
        | 9 -> 120 |> UMX.tag<stageLength>
        | 12 -> 150 |> UMX.tag<stageLength>
        | 16 -> 200 |> UMX.tag<stageLength>
        | 24 -> 300 |> UMX.tag<stageLength>
        | 32 -> 450 |> UMX.tag<stageLength>
        | 48 -> 800 |> UMX.tag<stageLength>
        | 64 -> 1000 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)



    let sortableArrayDataTypeKeyValues = 
            [ 
                Some sortableArrayDataType.Ints; 
                Some sortableArrayDataType.Bools ] |> List.map(SortableArrayDataType.toString)
  
    let sortableArrayDataTypeKeys () : string*string list =
        (runParameters.sortableArrayDataTypeKey, sortableArrayDataTypeKeyValues )



    //let sortingWidthValues = 
    //    [16; 32] |> List.map(fun d -> d.ToString())

    let sortingWidthValues = 
        [6; 9; 12;] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    //let mergeDimensionValues = 
    //    [2; 4; 8;] |> List.map(fun d -> d.ToString())

    let mergeDimensionValues = 
        [3;] |> List.map(fun d -> d.ToString())


    let mergeDimensions() : string*string list =
        (runParameters.mergeDimensionKey, mergeDimensionValues)



    let mergeFillTypeValues = 
         [mergeFillType.Full; mergeFillType.VanVoorhis;] |> List.map(fun d -> d.ToString())

    let mergeFillTypes() : string*string list =
        (runParameters.mergeFillTypeKey, mergeFillTypeValues)


    let sorterModelKeyValues () : string list =
        [ Some sorterModelKey.Mcse;]      |> List.map(SorterModelKey.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let paramMapFilter (runParameters: runParameters) = 
        Some runParameters


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        let mutable lastRepl: int<replNumber> option = None
        let mutable index = 0

        let assignRepl (runParams: runParameters) : runParameters =
            match lastRepl with
            | None ->
                lastRepl <- runParams.GetRepl()
                runParams.SetIndex (UMX.tag<indexNumber> index)

            | Some lastRplV ->
                match runParams.GetRepl() with
                | None ->
                    failwith "repl should be present"
                | Some paramRpl ->
                    if not (%paramRpl = %lastRplV) then 
                        index <- 0
                        lastRepl <- runParams.GetRepl()
                    runParams.SetIndex (UMX.tag<indexNumber> index)

            index <- index + 1
            runParams


        let enhancer (runParameters : runParameters) : runParameters =
            runParameters.SetRunFinished false
            runParameters.SetProjectName projectName

            let repl = runParameters.GetRepl().Value
            let sortingWidth = runParameters.GetSortingWidth().Value

            let stageLength = getStageLengthForSortingWidth sortingWidth
            runParameters.SetStageLength stageLength

            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            runParameters.SetCeLength ceLength

            let replFactor = 1 // if (%repl = 0) then 10 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor
            runParameters.SetSorterCount sorterCount
            runParameters


        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer |> assignRepl
                        yield retVal
        }

    let parameterSpans = 
        [
                Project.repl1s(); 
                sortingWidths(); 
                sorterModelKeys(); 
                sortableArrayDataTypeKeys(); 
                mergeDimensions(); 
                mergeFillTypes(); ]
        
    let outputDataTypes = 
            [|                
                outputDataType.SorterModelSetMaker None;
                outputDataType.SorterSet None;
                outputDataType.SorterSetEval None;
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]

    let project = 
            Project.create 
                projectName 
                projectDesc
                parameterSpans
                1<replNumber>
                outputDataTypes
                paramMapRefiner


    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<unit> =

        async {
            let index = runParameters.GetIndex().Value  
            let repl = runParameters.GetRepl().Value
            let sorterModelKey = runParameters.GetSorterModelKey().Value
            let sortingWidth = runParameters.GetSortingWidth().Value
            let stageLength = runParameters.GetStageLength().Value
            let ceLength = runParameters.GetCeLength().Value
            let sorterCount = runParameters.GetSorterCount().Value
            let mergeDimension = runParameters.GetMergeDimension().Value
            let mergeFillType = runParameters.GetMergeFillType().Value
            let sortableArrayDataType = runParameters.GetSortableArrayDataType().Value

            match progress with
            | Some p -> p.Report(sprintf "Executing Run %d_%d  %s" index %repl (runParameters.toString()))
            | None -> ()
        
            // Check cancellation before starting expensive operations
            cts.Token.ThrowIfCancellationRequested()

            // Create sorter model maker
            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelKey.Mcse -> 
                    (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) 
                    |> sorterModelMaker.SmmMsceRandGen
                | sorterModelKey.Mssi -> 
                    (MssiRandGen.create randomType sortingWidth stageLength) 
                    |> sorterModelMaker.SmmMssiRandGen
                | sorterModelKey.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) 
                    |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelKey.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelKey.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf6RandGen
        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Creating sorter set" index %repl)
            | None -> ()
        
            // Check cancellation before generating sorters
            cts.Token.ThrowIfCancellationRequested()
        
            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet
            let sortableTestModel = msasM.create sortingWidth mergeDimension mergeFillType |> sortableTestModel.MsasMi
            let sortableTests = SortableTestModel.makeSortableTests sortableTestModel sortableArrayDataType

        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Evaluating sorter set" index %repl)
            | None -> ()


            let sorterSetEval = SorterSetEval.makeSorterSetEval sorterSet sortableTests

            cts.Token.ThrowIfCancellationRequested()
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Saving sorterSet test results" index %repl)
            | None -> ()

            // Save sorter set
            let queryParamsForSorterSet = queryParams.createFromRunParams (outputDataType.SorterSet None) runParameters
            do! db.saveAsync queryParamsForSorterSet (sorterSet |> outputData.SorterSet)

            // Save sorterSetEval
            let queryParamsForSorterSetEval = queryParams.createFromRunParams (outputDataType.SorterSetEval None) runParameters
            do! db.saveAsync queryParamsForSorterSetEval (sorterSetEval |> outputData.SorterSetEval)

            // Save sorterModelSetMaker
            let queryParamsForSorterModelSetMaker = 
                queryParams.createFromRunParams (outputDataType.SorterModelSetMaker None) runParameters
            do! db.saveAsync queryParamsForSorterModelSetMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker)

            // Mark run as finished
            runParameters.SetRunFinished true
        
            match progress with
            | Some p -> p.Report(sprintf "✓ Finished executing Run %d_%d" index %repl)
            | None -> ()
        }