namespace GeneSort.Project

open System
open System.Threading

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorting
open GeneSort.Model.Sortable
open GeneSort.SortingOps
open GeneSort.Runs
open GeneSort.Db
open ProjectOps
open GeneSort.Model.Sorting
open GeneSort.Model.Sorting.ModelParams


module FullBoolMutate =
    // fixed values for this project
    let projectName = "FullBoolMutate" |> UMX.tag<projectName>
    let projectFolder = "FullBoolEvals" |> UMX.tag<projectFolder>
    let projectDesc = "FullBoolMutate on RandomSorters with SortingWidth from 4 to 24 generated by Msce, Mssi, Msrs, and Msuf"
    let randomType = rngType.Lcg
    let firstSortingIndex = 0<sorterCount>
    let sortingCount = 100<sorterCount>


    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth:int<sortingWidth> option)
            (sorterModelType:sorterModelType option)
            (sortableDataFormat:sortableDataFormat option)
            (outputDataType: outputDataType) =
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> UmxExt.intToString ); 
                (runParameters.sorterModelTypeKey, sorterModelType |> Option.map SorterModelType.toString |> UmxExt.stringToString );
                (runParameters.sortableDataFormatKey, sortableDataFormat |> Option.map SortableDataFormat.toString |> UmxExt.stringToString );
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            (runParams.GetSortableDataFormat())
            outputDataType


    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Msce -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth


    let enhancer (rp : runParameters) : runParameters =
        let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)

        rp.WithProjectName(Some projectName)
            .WithRunFinished(Some false)
            .WithId (Some qp.Id)


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        let refined =
            seq {
                for runParameters in runParametersSeq do
                        let filtrate = paramMapFilter runParameters
                        if filtrate.IsSome then
                            let retVal = filtrate.Value |> enhancer
                            yield retVal
            } |> Seq.toArray

        refined


    let mutationRateKeys() : string*string list =
        let values = 
            [ 0.005; 0.01; 0.015; ] |> List.map(fun d -> d.ToString())
        (runParameters.maxOrbitKey , values)
        
    let sortingWidthKeys() : string*string list =
        let sortingWidthValues = 
            [ 16; ] |> List.map(fun d -> d.ToString())
        //let sortingWidthValues = 
        //    [ 4; 6; 8; 12; 16; 18; 20; 22; 24 ] |> List.map(fun d -> d.ToString())
        (runParameters.sortingWidthKey, sortingWidthValues)
        

    let sorterModelKeys() : string*string list =
        let sorterModelKeyValues() : string list =
                [ sorterModelType.Msce; 
                  //sorterModelType.Mssi;
                  //sorterModelType.Msrs; 
                  //sorterModelType.Msuf4; 
                  //sorterModelType.Msuf6; 
                  ]  |> List.map(SorterModelType.toString)
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let sortableDataFormatKeys () : string * string list =
        let values = [ 
                        //sortableDataFormat.IntArray; 
                        //sortableDataFormat.BoolArray;
                        //sortableDataFormat.Int8Vector256;
                        //sortableDataFormat.Int8Vector512;
                        sortableDataFormat.BitVector512;

                     ] |> List.map SortableDataFormat.toString
        (runParameters.sortableDataFormatKey, values)



    let parameterSpans = 
        [ sortingWidthKeys(); sorterModelKeys(); sortableDataFormatKeys(); mutationRateKeys()]



    let outputDataTypes = 
            [|
                outputDataType.RunParameters;
                outputDataType.SorterSetEval "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
            |]


    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes

    let executor
            (db: IGeneSortDb)
            (projectFolder: string<projectFolder>)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup & ID Extraction
                let! _ = checkCancellation cts.Token
                let runId = runParameters |> RunParameters.getIdString
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) %runId %repl)

                // 2. Safe Domain Parameter Extraction
                let! (sorterModelType, sortingWidth, sortableDataFormat, mutationRate) = 
                    maybe {
                        let! smt = runParameters.GetSorterModelType()
                        let! sw = runParameters.GetSortingWidth()
                        let! sdt = runParameters.GetSortableDataFormat()
                        let! mr = runParameters.GetMutationRate()
                        return (smt, sw, sdt, mr)
                    } |> Result.ofOption (sprintf "Run %s, Repl %d: Missing required parameters" %runId %repl)

                // 3. Load SortingModelSet
                let qpSorters = RandomSorters.makeQueryParams (Some repl) (Some sortingWidth) (Some sorterModelType) (outputDataType.SortingModelSet "")
                let! loadRes = db.loadAsync RandomSorters.projectFolder qpSorters
                let! sortingModelSetParent = loadRes |> OutputData.asSortingModelSet |> asAsync

                // 4. Perform Computation
                let! _ = checkCancellation cts.Token
                let sortableTestModel = msasF.create sortingWidth |> sortableTestModel.MsasF
                let sortableTests = SortableTestModel.makeSortableTests sortableTestModel sortableDataFormat
                let sorterSetParent = sortingModelSetParent |> SortingModelSet.makeSorterSet
                let sorterSetEvalParent = SorterSetEval.makeSorterModelSetEval sorterSetParent sortableTests false

                let sorterModelMutateParams = 
                    SorterMutateParams.makeUniformMutatorForSorterModel 
                                sorterModelType 
                                sortingModelSetParent.StageLength 
                                sortingModelSetParent.SortingWidth 
                                mutationRate 
                                randomType

                let sorterSetsMutated = SorterMutateParamsOps.mutateSortingModelsWithMutateParams
                                            (Rando.create)
                                            sortingModelSetParent.SortingModels
                                            sorterModelMutateParams
                                            firstSortingIndex
                                            sortingCount
                                        |> Seq.toArray
                //let sorterSetEvalMutated = SorterSetEval.makeSorterModelSetEval (Sorter


                // 5. Save Results
                let qpEval = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSetEval "")
                let! _ = db.saveAsync projectFolder qpEval (sorterSetEvalParent |> outputData.SorterSetEval) allowOverwrite
                let passingSortingModelSet = 
                        SorterSetEval.makePassingSortingModelSet sortingModelSetParent sorterSetEvalParent
                let qpSorterModelSetPass = makeQueryParamsFromRunParams runParameters (outputDataType.SortingModelSet "Pass")
                let! _ = db.saveAsync projectFolder qpSorterModelSetPass (passingSortingModelSet |> outputData.SortingModelSet) allowOverwrite


                // 6. Final Success
                return runParameters.WithRunFinished (Some true)

            with e ->
                let rawId = runParameters |> RunParameters.getIdString
                let msg = sprintf "Execution exception in Run %s: %s" rawId e.Message
                return! async { return Error msg }
        }