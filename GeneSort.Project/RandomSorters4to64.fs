
namespace GeneSort.Project

open System

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter
open GeneSort.Runs.Params
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter.Uf6
open System.Threading
open GeneSort.Runs
open GeneSort.Db


module RandomSorters4to64 =

    let projectName = "RandomSorters4to64"  |> UMX.tag<projectName>
    let projectDesc = "RandomSorters with SortingWidth from 4 to 64, generated by Msce, Mssi, Msrs, and Msuf"
    
    // Progress reporter that prints to console
    let progress = 
        { new IProgress<string> with
            member _.Report(msg) = printfn "%s" msg }



    let randomType = rngType.Lcg
    let excludeSelfCe = true


    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (50 * factor) |> UMX.tag<sorterCount>
        | 24 -> (50 * factor) |> UMX.tag<sorterCount>
        | 32 -> (50 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getCeLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<ceLength> =
        match %sortingWidth with
        | 4 -> 300 |> UMX.tag<ceLength>
        | 6 -> 600 |> UMX.tag<ceLength>
        | 8 -> 16 |> UMX.tag<ceLength>
        | 12 -> 24 |> UMX.tag<ceLength>
        | 16 -> 32 |> UMX.tag<ceLength>
        | 24 -> 48 |> UMX.tag<ceLength>
        | 32 -> 64 |> UMX.tag<ceLength>
        | 48 -> 96 |> UMX.tag<ceLength>
        | 64 -> 128 |> UMX.tag<ceLength>
        | 96 -> 192 |> UMX.tag<ceLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 5 |> UMX.tag<stageLength>
        | 6 -> 10 |> UMX.tag<stageLength>
        | 8 -> 20 |> UMX.tag<stageLength>
        | 12 -> 30 |> UMX.tag<stageLength>
        | 16 -> 100 |> UMX.tag<stageLength>
        | 24 -> 150 |> UMX.tag<stageLength>
        | 32 -> 200 |> UMX.tag<stageLength>
        | 48 -> 300 |> UMX.tag<stageLength>
        | 64 -> 400 |> UMX.tag<stageLength>
        | 96 -> 600 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let sortingWidthValues = 
        [4; 6; 8; 12; 16; 24; 32; 48; 64] |> List.map(fun d -> d.ToString())

    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let sorterModelKeyValues () : string list =
        [ sorterModelKey.Mcse; 
          sorterModelKey.Mssi;
          sorterModelKey.Msrs; 
          sorterModelKey.Msuf4; 
          sorterModelKey.Msuf6; ]      |> List.map(SorterModelKey.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let paramMapFilter (runParameters: runParameters) = 
        let sorterModelKey = runParameters.GetSorterModelKey().Value
        let sortingWidth = runParameters.GetSortingWidth().Value
        let has3factor = (%sortingWidth % 3 = 0)

        match sorterModelKey with
        | sorterModelKey.Mcse -> Some runParameters
        | sorterModelKey.Mssi -> Some runParameters
        | sorterModelKey.Msrs -> Some runParameters
        | sorterModelKey.Msuf4 ->
                if has3factor then None else
                Some runParameters
        | sorterModelKey.Msuf6 -> 
                if has3factor then Some runParameters else
                None


    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 
        let mutable index = 0

        let enhancer (runParameters : runParameters) : runParameters =
            runParameters.SetRunFinished false
            runParameters.SetProjectName projectName

            let repl = runParameters.GetRepl().Value
            let sortingWidth = runParameters.GetSortingWidth().Value

            let stageLength = getStageLengthForSortingWidth sortingWidth
            runParameters.SetStageLength stageLength

            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            runParameters.SetCeLength ceLength

            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor
            runParameters.SetSorterCount sorterCount
            runParameters

        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = enhancer filtrate.Value
                        retVal.SetIndex (UMX.tag<indexNumber> index)
                        yield filtrate.Value
                        index <- index + 1
        }

    let reportNames = [||]

    let parameterSpans = 
        [ Project.repl1s(); sortingWidths(); sorterModelKeys() ]


    let project = Project.create projectName projectDesc reportNames parameterSpans paramMapRefiner


    let executorOld 
            (db:IGeneSortDb)
            (runParameters: runParameters) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string>) : Async<unit> =
        async {
            let projectName = runParameters.GetProjectName().Value
            let index = runParameters.GetIndex().Value  
            let repl = runParameters.GetRepl().Value
            let sorterModelKey = runParameters.GetSorterModelKey().Value
            let sortingWidth = runParameters.GetSortingWidth().Value
            let stageLength = runParameters.GetStageLength().Value
            let ceLength = runParameters.GetCeLength().Value
            let sorterCount = runParameters.GetSorterCount().Value

            progress.Report(sprintf "Executing Run %d  %s" index (runParameters.toString()))


            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelKey.Mcse -> (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) |> sorterModelMaker.SmmMsceRandGen
                | sorterModelKey.Mssi -> (MssiRandGen.create randomType sortingWidth stageLength) |> sorterModelMaker.SmmMssiRandGen
                | sorterModelKey.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelKey.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelKey.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) |> sorterModelMaker.SmmMsuf6RandGen

            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

            let queryParamsForSorterSet = queryParams.Create(projectName, Some index, Some repl, None, outputDataType.SorterSet)
            do! db.saveAsync queryParamsForSorterSet (sorterSet |> outputData.SorterSet)
            
            let queryParamsForSorterModelSetMaker = queryParams.Create(projectName, Some index, Some repl, None, outputDataType.SorterModelSetMaker)
            do! db.saveAsync queryParamsForSorterModelSetMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker)

            runParameters.SetRunFinished true

            progress.Report(sprintf "Finished executing Run %d  Repl  %d \n" index %repl)
        }

    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<unit> =
        async {
            let projectName = runParameters.GetProjectName().Value
            let index = runParameters.GetIndex().Value  
            let repl = runParameters.GetRepl().Value
            let sorterModelKey = runParameters.GetSorterModelKey().Value
            let sortingWidth = runParameters.GetSortingWidth().Value
            let stageLength = runParameters.GetStageLength().Value
            let ceLength = runParameters.GetCeLength().Value
            let sorterCount = runParameters.GetSorterCount().Value
        
            match progress with
            | Some p -> p.Report(sprintf "Executing Run %d_%d  %s" index %repl (runParameters.toString()))
            | None -> ()
        
            // Check cancellation before starting expensive operations
            cts.Token.ThrowIfCancellationRequested()
        
            // Create sorter model maker
            let sorterModelMaker =
                match sorterModelKey with
                | sorterModelKey.Mcse -> 
                    (MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength) 
                    |> sorterModelMaker.SmmMsceRandGen
                | sorterModelKey.Mssi -> 
                    (MssiRandGen.create randomType sortingWidth stageLength) 
                    |> sorterModelMaker.SmmMssiRandGen
                | sorterModelKey.Msrs -> 
                    let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                    (msrsRandGen.create randomType sortingWidth opsGenRatesArray) 
                    |> sorterModelMaker.SmmMsrsRandGen
                | sorterModelKey.Msuf4 -> 
                    let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf4RandGen
                | sorterModelKey.Msuf6 -> 
                    let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                    (msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray) 
                    |> sorterModelMaker.SmmMsuf6RandGen
        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Creating sorter model set" index %repl)
            | None -> ()
        
            // Check cancellation before generating sorters
            cts.Token.ThrowIfCancellationRequested()
        
            let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
            let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
            let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
            let sorterSet = SorterModelSet.makeSorterSet sorterModelSet
        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Saving sorter set" index %repl)
            | None -> ()
        
            // Check cancellation before saving
            cts.Token.ThrowIfCancellationRequested()
        
            // Save sorter set
            let queryParamsForSorterSet = 
                queryParams.Create(projectName, Some index, Some repl, None, outputDataType.SorterSet)
            do! db.saveAsync queryParamsForSorterSet (sorterSet |> outputData.SorterSet)
        
            match progress with
            | Some p -> p.Report(sprintf "Run %d_%d: Saving sorter model set maker" index %repl)
            | None -> ()
        
            // Save sorter model set maker
            let queryParamsForSorterModelSetMaker = 
                queryParams.Create(projectName, Some index, Some repl, None, outputDataType.SorterModelSetMaker)
            do! db.saveAsync queryParamsForSorterModelSetMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker)
        
            // Mark run as finished
            runParameters.SetRunFinished true
        
            match progress with
            | Some p -> p.Report(sprintf "✓ Finished executing Run %d_%d" index %repl)
            | None -> ()
        }


    let initParametersFiles 
            (db: IGeneSortDb)
            (projectName: string<projectName>)
            (runParameterArray: runParameters[]) 
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<unit, string>> =
        async {
            try
                match progress with
                | Some p -> p.Report(sprintf "Saving RunParameter files for %s" %projectName)
                | None -> ()
            
                cts.Token.ThrowIfCancellationRequested()
            
                do! db.saveAllRunParametersAsync runParameterArray (Some cts.Token) progress
            
                match progress with
                | Some p -> p.Report(sprintf "Successfully saved %d RunParameter files" runParameterArray.Length)
                | None -> ()
            
                return Ok ()
            
            with 
            | :? OperationCanceledException ->
                let msg = sprintf "Saving RunParameter files was cancelled"
                match progress with
                | Some p -> p.Report(msg)
                | None -> ()
                return Error msg
            | e ->
                let msg = sprintf "Failed to save RunParameter files for %s: %s" %projectName e.Message
                match progress with
                | Some p -> p.Report(msg)
                | None -> ()
                return Error msg
        }


    let InitProjectFiles
        (db: IGeneSortDb)
        (queryParams: queryParams)
        (cts: CancellationTokenSource) 
        (progress: IProgress<string> option) : Async<Result<unit, string>> =
        async {
            try
                match progress with
                | Some p -> p.Report(sprintf "Saving project file: %s" %projectName)
                | None -> ()
            
                do! db.saveAsync queryParams (project |> outputData.Project)
            
                match progress with
                | Some p -> p.Report(sprintf "Saving run parameters files: (%d)" project.RunParametersArray.Length)
                | None -> ()
            
                let! initResult = initParametersFiles db projectName project.RunParametersArray cts progress
            
                match initResult with
                | Ok () ->
                    match progress with
                    | Some p -> p.Report("Project initialization completed successfully")
                    | None -> ()
                    return Ok ()
                | Error msg ->
                    return Error (sprintf "Project initialization failed: %s" msg)
            
            with e ->
                let errorMsg = sprintf "Failed to initialize project files: %s" e.Message
                match progress with
                | Some p -> p.Report(errorMsg)
                | None -> ()
                return Error errorMsg
        }


    let ExecuteRuns
        (db: IGeneSortDb)
        (cts: CancellationTokenSource) 
        (progress: IProgress<string> option) : Async<Result<RunResult[], string>> =
        async {
            try
                match progress with
                | Some p -> p.Report(sprintf "Executing Runs for %s" %projectName)
                | None -> ()
            
                let! runParamsResult = db.getAllRunParametersForProjectAsync projectName None progress
            
                match runParamsResult with
                | Error msg ->
                    match progress with
                    | Some p -> p.Report(sprintf "Failed to load run parameters: %s" msg)
                    | None -> ()
                    return Error msg
                
                | Ok runParametersArray ->
                    match progress with
                    | Some p -> p.Report(sprintf "Found %d runs to execute" runParametersArray.Length)
                    | None -> ()
                
                    if runParametersArray.Length = 0 then
                        match progress with
                        | Some p -> p.Report("No runs found to execute")
                        | None -> ()
                        return Ok [||]
                    else
                        let! results = ProjectOps.executeRunParametersSeq db 8 executor runParametersArray cts progress
                        return Ok results
            
            with e ->
                let msg = sprintf "Fatal error executing runs: %s" e.Message
                match progress with
                | Some p -> p.Report(msg)
                | None -> ()
                return Error msg
        }