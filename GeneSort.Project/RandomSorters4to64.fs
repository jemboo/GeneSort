namespace GeneSort.Project

open System

open FSharp.UMX

open GeneSort.Core
open GeneSort.Sorter
open GeneSort.Model.Sorter
open GeneSort.Model.Sorter.Ce
open GeneSort.Model.Sorter.Si
open GeneSort.Model.Sorter.Uf4
open GeneSort.Model.Sorter.Rs
open GeneSort.Model.Sorter.Uf6
open System.Threading
open GeneSort.Runs
open GeneSort.Db
open ProjectOps


module RandomSorters4to64 =
    
    // Progress reporter that prints to console
    let progress = 
        { new IProgress<string> with
            member _.Report(msg) = printfn "%s" msg }


    let projectName = "RandomSorters4to64"  |> UMX.tag<projectName>
    let projectDesc = "RandomSorters with SortingWidth from 4 to 64, generated by Msce, Mssi, Msrs, and Msuf"

    // Fixed parameters:
    let randomType = rngType.Lcg
    let excludeSelfCe = true
    let allowOverwrite = false |> UMX.tag<allowOverwrite>


    let makeQueryParams 
            (repl: int<replNumber> option) 
            (sortingWidth:int<sortingWidth> option)
            (sorterModelType:sorterModelType option)
            (outputDataType: outputDataType) =
             
        queryParams.create(
            Some projectName,
            repl,
            outputDataType,
            [|
                (runParameters.sortingWidthKey, sortingWidth |> SortingWidth.toString); 
                (runParameters.sorterModelTypeKey, sorterModelType |> SorterModelType.toString);
            |])


    let makeQueryParamsFromRunParams
            (runParams: runParameters) 
            (outputDataType: outputDataType) =
        makeQueryParams
            (runParams.GetRepl())
            (runParams.GetSortingWidth())
            (runParams.GetSorterModelType())
            outputDataType



    // Parameter spans:
    
    //let sortingWidthValues = 
    //    [4; 6; 8; 12; 16; 24; 32; 48; 64] |> List.map(fun d -> d.ToString())
    let sortingWidthValues = 
        [4; 6; 8; 16; 24; 32; 48; 64; ] |> List.map(fun d -> d.ToString())


    let sortingWidths() : string*string list =
        (runParameters.sortingWidthKey, sortingWidthValues)


    let sorterModelKeyValues () : string list =
        [ Some sorterModelType.Mcse; 
          Some sorterModelType.Mssi;
          Some sorterModelType.Msrs; 
          Some sorterModelType.Msuf4; 
          Some sorterModelType.Msuf6; ]      |> List.map(SorterModelType.toString)

    let sorterModelKeys () : string*string list =
        (runParameters.sorterModelTypeKey, sorterModelKeyValues() )


    let getSorterCountForSortingWidth (factor:int) (sortingWidth: int<sortingWidth>) : int<sorterCount> =
        match %sortingWidth with
        | 4 -> (10 * factor) |> UMX.tag<sorterCount>
        | 6 -> (10 * factor) |> UMX.tag<sorterCount>
        | 8 -> (10 * factor) |> UMX.tag<sorterCount>
        | 12 -> (10 * factor) |> UMX.tag<sorterCount>
        | 16 -> (50 * factor) |> UMX.tag<sorterCount>
        | 24 -> (50 * factor) |> UMX.tag<sorterCount>
        | 32 -> (50 * factor) |> UMX.tag<sorterCount>
        | 48 -> (10 * factor) |> UMX.tag<sorterCount>
        | 64 -> (10 * factor) |> UMX.tag<sorterCount>
        | 96 -> (10 * factor) |> UMX.tag<sorterCount>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getCeLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<ceLength> =
        match %sortingWidth with
        | 4 -> 300 |> UMX.tag<ceLength>
        | 6 -> 600 |> UMX.tag<ceLength>
        | 8 -> 16 |> UMX.tag<ceLength>
        | 12 -> 24 |> UMX.tag<ceLength>
        | 16 -> 32 |> UMX.tag<ceLength>
        | 24 -> 48 |> UMX.tag<ceLength>
        | 32 -> 64 |> UMX.tag<ceLength>
        | 48 -> 96 |> UMX.tag<ceLength>
        | 64 -> 128 |> UMX.tag<ceLength>
        | 96 -> 192 |> UMX.tag<ceLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)


    let getStageLengthForSortingWidth (sortingWidth: int<sortingWidth>) : int<stageLength> =
        match %sortingWidth with
        | 4 -> 5 |> UMX.tag<stageLength>
        | 6 -> 10 |> UMX.tag<stageLength>
        | 8 -> 20 |> UMX.tag<stageLength>
        | 12 -> 30 |> UMX.tag<stageLength>
        | 16 -> 100 |> UMX.tag<stageLength>
        | 24 -> 150 |> UMX.tag<stageLength>
        | 32 -> 200 |> UMX.tag<stageLength>
        | 48 -> 300 |> UMX.tag<stageLength>
        | 64 -> 400 |> UMX.tag<stageLength>
        | 96 -> 600 |> UMX.tag<stageLength>
        | _ -> failwithf "Unsupported sorting width: %d" (%sortingWidth)

     
     // --- Filters ---

    let mergeDimensionDividesSortingWidth (rp: runParameters) =
        let sw = rp.GetSortingWidth().Value
        let md = rp.GetMergeDimension().Value
        if (%sw % %md = 0) then Some rp else None


    let sorterModelTypeForSortingWidth (rp: runParameters) =
        let sorterModelKey = rp.GetSorterModelType().Value
        let sortingWidth = rp.GetSortingWidth().Value
        let has2factor = (%sortingWidth % 2 = 0)
        let isMuf4able = (MathUtils.isAPowerOfTwo %sortingWidth)
        let isMuf6able = (%sortingWidth % 3 = 0) && (MathUtils.isAPowerOfTwo (%sortingWidth / 3))

        match sorterModelKey with
        | sorterModelType.Mcse -> Some rp
        | sorterModelType.Mssi
        | sorterModelType.Msrs -> if has2factor then Some rp else None
        | sorterModelType.Msuf4 ->
                if isMuf4able then Some rp else None
        | sorterModelType.Msuf6 -> 
                if isMuf6able then Some rp else None
                


    let paramMapFilter (rp: runParameters) = 
        Some rp
        |> Option.bind sorterModelTypeForSortingWidth


    // --- Project Refinement ---

    let paramMapRefiner (runParametersSeq: runParameters seq) : runParameters seq = 

        let enhancer (rp : runParameters) : runParameters =
            let repl = rp.GetRepl().Value
            let sortingWidth = rp.GetSortingWidth().Value
            let qp = makeQueryParamsFromRunParams rp (outputDataType.RunParameters)
            let stageLength = getStageLengthForSortingWidth sortingWidth
            let ceLength = (((float %stageLength) * (float %sortingWidth) * 0.6) |> int) |> UMX.tag<ceLength>
            let replFactor = if (%repl = 0) then 1 else 10
            let sorterCount = sortingWidth |> getSorterCountForSortingWidth replFactor

            rp.WithProjectName(projectName)
              .WithRunFinished(false)
              .WithCeLength(ceLength)
              .WithStageLength(stageLength)
              .WithSorterCount(sorterCount)
              .WithId (qp.Id.ToString() |> UMX.tag<idValue>)


        seq {
            for runParameters in runParametersSeq do
                    let filtrate = paramMapFilter runParameters
                    if filtrate.IsSome then
                        let retVal = filtrate.Value |> enhancer
                        yield retVal
        }

    let outputDataTypes = 
            [|
                outputDataType.RunParameters;
                outputDataType.SorterModelSetMaker "";
                outputDataType.SorterSet "";
                outputDataType.TextReport ("Bins" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Profiles" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report3" |> UMX.tag<textReportName>); 
                outputDataType.TextReport ("Report4" |> UMX.tag<textReportName>);
            |]

    let parameterSpans = 
        [ sortingWidths(); sorterModelKeys() ]

    let project = 
            project.create 
                projectName 
                projectDesc
                parameterSpans
                outputDataTypes


    let executor
            (db: IGeneSortDb)
            (runParameters: runParameters) 
            (allowOverwrite: bool<allowOverwrite>)
            (cts: CancellationTokenSource) 
            (progress: IProgress<string> option) : Async<Result<runParameters, string>> =

        asyncResult {
            try
                // 1. Setup & ID Extraction
                let! _ = checkCancellation cts.Token
                let runId = runParameters.GetId() |> Option.defaultValue (% "unknown")
                let repl = runParameters.GetRepl() |> Option.defaultValue (-1 |> UMX.tag)
                report progress (sprintf "%s Starting Run %s repl %d" (MathUtils.getTimestampString()) %runId %repl)

                // 2. Safe Parameter Extraction
                let! (sorterModelType, sortingWidth, stageLength, ceLength, sorterCount) = 
                    maybe {
                        let! smk = runParameters.GetSorterModelType()
                        let! sw = runParameters.GetSortingWidth()
                        let! sl = runParameters.GetStageLength()
                        let! cl = runParameters.GetCeLength()
                        let! sc = runParameters.GetSorterCount()
                        return (smk, sw, sl, cl, sc)
                    } |> Result.ofOption (sprintf "Run %s: Missing required parameters" %runId) |> asAsync

                progress |> Option.iter (fun p ->  
                    p.Report(sprintf "%s Executing Run %s, Repl %d: %s" (MathUtils.getTimestampString()) %runId %repl (runParameters.toString())))

                // 3. Sorter Model Logic (Pure Computation)
                let sorterModelMaker =
                    match sorterModelType with
                    | sorterModelType.Mcse -> 
                        MsceRandGen.create randomType sortingWidth excludeSelfCe ceLength 
                        |> sorterModelMaker.SmmMsceRandGen
                    | sorterModelType.Mssi -> 
                        MssiRandGen.create randomType sortingWidth stageLength 
                        |> sorterModelMaker.SmmMssiRandGen
                    | sorterModelType.Msrs -> 
                        let opsGenRatesArray = OpsGenRatesArray.createUniform %stageLength
                        msrsRandGen.create randomType sortingWidth opsGenRatesArray 
                        |> sorterModelMaker.SmmMsrsRandGen
                    | sorterModelType.Msuf4 -> 
                        let uf4GenRatesArray = Uf4GenRatesArray.createUniform %stageLength %sortingWidth
                        msuf4RandGen.create randomType sortingWidth stageLength uf4GenRatesArray 
                        |> sorterModelMaker.SmmMsuf4RandGen
                    | sorterModelType.Msuf6 -> 
                        let uf6GenRatesArray = Uf6GenRatesArray.createUniform %stageLength %sortingWidth
                        msuf6RandGen.create randomType sortingWidth stageLength uf6GenRatesArray 
                        |> sorterModelMaker.SmmMsuf6RandGen

                let firstIndex = (%repl * %sorterCount) |> UMX.tag<sorterCount>
                let sorterModelSetMaker = sorterModelSetMaker.create sorterModelMaker firstIndex sorterCount
                let sorterModelSet = sorterModelSetMaker.MakeSorterModelSet (Rando.create)
                let sorterSet = SorterModelSet.makeSorterSet sorterModelSet

                let! _ = checkCancellation cts.Token

                // 4. Sequential Saves
                let qpSorterSet = makeQueryParamsFromRunParams runParameters (outputDataType.SorterSet "") 
                let! _ = db.saveAsync qpSorterSet (sorterSet |> outputData.SorterSet) allowOverwrite
            
                progress |> Option.iter (fun p -> 
                    p.Report(sprintf "Saved sorterSet %s for run: %s" (%sorterSet.Id.ToString()) %runId))

                let qpMaker = makeQueryParamsFromRunParams runParameters (outputDataType.SorterModelSetMaker "") 
                let! _ = db.saveAsync qpMaker (sorterModelSetMaker |> outputData.SorterModelSetMaker) allowOverwrite
            
                progress |> Option.iter (fun p -> 
                    p.Report(sprintf "Saved SorterModelSetMaker %s for run: %s" (%sorterModelSetMaker.Id.ToString()) %runId))

                // 5. Final Return
                report progress (sprintf "%s Finished Run %s Repl %d" (MathUtils.getTimestampString()) %runId %repl)
                return runParameters.WithRunFinished true

            with e -> 
                let rawId = runParameters.GetId() |> Option.map UMX.untag |> Option.defaultValue "unknown"
                let msg = sprintf "Unexpected error in run %s: %s" rawId e.Message
                return! async { return Error msg }
        }